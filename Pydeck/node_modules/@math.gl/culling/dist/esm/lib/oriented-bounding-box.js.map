{"version":3,"sources":["../../../src/lib/oriented-bounding-box.js"],"names":["Vector3","Matrix3","BoundingSphere","Intersect","makeOrientedBoundingBoxfromPoints","scratchVector","scratchOffset","scratchVectorU","scratchVectorV","scratchVectorW","scratchPPrime","scratchCorner","scratchToCenter","fromOrientedBoundingBoxScratchU","fromOrientedBoundingBoxScratchV","fromOrientedBoundingBoxScratchW","MATRIX3","COLUMN0ROW0","COLUMN0ROW1","COLUMN0ROW2","COLUMN1ROW0","COLUMN1ROW1","COLUMN1ROW2","COLUMN2ROW0","COLUMN2ROW1","COLUMN2ROW2","OrientedBoundingBox","center","halfAxes","from","result","points","right","Boolean","equals","u","getColumn","v","w","cornerVector","copy","add","radius","magnitude","plane","normal","normalX","x","normalY","y","normalZ","z","radEffective","Math","abs","distanceToPlane","dot","distance","OUTSIDE","INSIDE","INTERSECTING","point","sqrt","distanceSquaredTo","offset","subtract","uHalf","vHalf","wHalf","normalize","pPrime","distanceSquared","d","position","direction","minDist","Number","POSITIVE_INFINITY","maxDist","NEGATIVE_INFINITY","corner","toCenter","mag","min","max","start","stop"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3, Matrix3} from 'math.gl';\nimport BoundingSphere from './bounding-sphere';\nimport {Intersect} from '../constants';\nimport makeOrientedBoundingBoxfromPoints from '../algorithms/bounding-box-from-points';\nconst scratchVector = new Vector3();\n\nconst scratchOffset = new Vector3();\nconst scratchVectorU = new Vector3();\nconst scratchVectorV = new Vector3();\nconst scratchVectorW = new Vector3();\nconst scratchPPrime = new Vector3();\nconst scratchCorner = new Vector3();\nconst scratchToCenter = new Vector3();\n\nconst fromOrientedBoundingBoxScratchU = new Vector3();\nconst fromOrientedBoundingBoxScratchV = new Vector3();\nconst fromOrientedBoundingBoxScratchW = new Vector3();\n\nconst MATRIX3 = {\n  COLUMN0ROW0: 0,\n  COLUMN0ROW1: 1,\n  COLUMN0ROW2: 2,\n  COLUMN1ROW0: 3,\n  COLUMN1ROW1: 4,\n  COLUMN1ROW2: 5,\n  COLUMN2ROW0: 6,\n  COLUMN2ROW1: 7,\n  COLUMN2ROW2: 8\n};\n\nexport default class OrientedBoundingBox {\n  // An OrientedBoundingBox of some object is a closed and convex cuboid. It can provide a tighter bounding volume than {@link BoundingSphere} or {@link AxisAlignedBoundingBox} in many cases.\n  constructor(center = [0, 0, 0], halfAxes = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {\n    this.center = new Vector3().from(center);\n    this.halfAxes = new Matrix3(halfAxes);\n  }\n\n  // Duplicates a OrientedBoundingBox instance.\n  clone(result) {\n    return new OrientedBoundingBox(this.center, this.halfAxes);\n  }\n\n  fromPoints(points, result = new OrientedBoundingBox()) {\n    return makeOrientedBoundingBoxfromPoints(points, result);\n  }\n\n  // Compares the provided OrientedBoundingBox componentwise and returns\n  equals(right) {\n    return (\n      this === right ||\n      (Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes))\n    );\n  }\n\n  // Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box.\n  getBoundingSphere(result = new BoundingSphere()) {\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, fromOrientedBoundingBoxScratchU);\n    const v = halfAxes.getColumn(1, fromOrientedBoundingBoxScratchV);\n    const w = halfAxes.getColumn(2, fromOrientedBoundingBoxScratchW);\n\n    // Calculate \"corner\" vector\n    const cornerVector = scratchVector\n      .copy(u)\n      .add(v)\n      .add(w);\n\n    result.center.copy(this.center);\n    result.radius = cornerVector.magnitude();\n\n    return result;\n  }\n\n  /**\n   * Determines which side of a plane the oriented bounding box is located.\n   *\n   * @param {OrientedBoundingBox} box The oriented bounding box to test.\n   * @param {Plane} plane The plane to test against.\n   * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is on the opposite side, and {@link Intersect.INTERSECTING} if the box intersects the plane.\n   */\n  intersectPlane(plane) {\n    const center = this.center;\n    const normal = plane.normal;\n    const halfAxes = this.halfAxes;\n\n    const normalX = normal.x;\n    const normalY = normal.y;\n    const normalZ = normal.z;\n\n    // Plane is used as if it is its normal; the first three components are assumed to be normalized\n    const radEffective =\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN0ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN0ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN0ROW2]\n      ) +\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN1ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN1ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN1ROW2]\n      ) +\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN2ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN2ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN2ROW2]\n      );\n    const distanceToPlane = normal.dot(center) + plane.distance;\n\n    if (distanceToPlane <= -radEffective) {\n      // The entire box is on the negative side of the plane normal\n      return Intersect.OUTSIDE;\n    } else if (distanceToPlane >= radEffective) {\n      // The entire box is on the positive side of the plane normal\n      return Intersect.INSIDE;\n    }\n    return Intersect.INTERSECTING;\n  }\n\n  // Computes the estimated distance from the closest point on a bounding box to a point.\n  distanceTo(point) {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n\n  // Computes the estimated distance squared from the closest point on a bounding box to a point.\n  // See Geometric Tools for Computer Graphics 10.4.2\n\n  // eslint-disable-next-line max-statements\n  distanceSquaredTo(point) {\n    const offset = scratchOffset.copy(point).subtract(this.center);\n\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n\n    const uHalf = u.magnitude();\n    const vHalf = v.magnitude();\n    const wHalf = w.magnitude();\n\n    u.normalize();\n    v.normalize();\n    w.normalize();\n\n    const pPrime = scratchPPrime;\n    pPrime.x = offset.dot(u);\n    pPrime.y = offset.dot(v);\n    pPrime.z = offset.dot(w);\n\n    let distanceSquared = 0.0;\n    let d;\n\n    if (pPrime.x < -uHalf) {\n      d = pPrime.x + uHalf;\n      distanceSquared += d * d;\n    } else if (pPrime.x > uHalf) {\n      d = pPrime.x - uHalf;\n      distanceSquared += d * d;\n    }\n\n    if (pPrime.y < -vHalf) {\n      d = pPrime.y + vHalf;\n      distanceSquared += d * d;\n    } else if (pPrime.y > vHalf) {\n      d = pPrime.y - vHalf;\n      distanceSquared += d * d;\n    }\n\n    if (pPrime.z < -wHalf) {\n      d = pPrime.z + wHalf;\n      distanceSquared += d * d;\n    } else if (pPrime.z > wHalf) {\n      d = pPrime.z - wHalf;\n      distanceSquared += d * d;\n    }\n\n    return distanceSquared;\n  }\n\n  // The distances calculated by the vector from the center of the bounding box\n  // to position projected onto direction.\n\n  // eslint-disable-next-line max-statements\n  computePlaneDistances(position, direction, result = [[], []]) {\n    let minDist = Number.POSITIVE_INFINITY;\n    let maxDist = Number.NEGATIVE_INFINITY;\n\n    const center = this.center;\n    const halfAxes = this.halfAxes;\n\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n\n    // project first corner\n    const corner = scratchCorner\n      .copy(u)\n      .add(v)\n      .add(w)\n      .add(center);\n\n    const toCenter = scratchToCenter.copy(corner).subtract(position);\n    let mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project second corner\n    corner\n      .copy(center)\n      .add(u)\n      .add(v)\n      .subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project third corner\n    corner\n      .copy(center)\n      .add(u)\n      .subtract(v)\n      .add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project fourth corner\n    corner\n      .copy(center)\n      .add(u)\n      .subtract(v)\n      .subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project fifth corner\n    center\n      .copy(corner)\n      .subtract(u)\n      .add(v)\n      .add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project sixth corner\n    center\n      .copy(corner)\n      .subtract(u)\n      .add(v)\n      .subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project seventh corner\n    center\n      .copy(corner)\n      .subtract(u)\n      .subtract(v)\n      .add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project eighth corner\n    center\n      .copy(corner)\n      .subtract(u)\n      .subtract(v)\n      .subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    result.start = minDist;\n    result.stop = maxDist;\n    return result;\n  }\n\n  getTransform() {\n    // const modelMatrix = Matrix4.fromRotationTranslation(this.boundingVolume.halfAxes, this.boundingVolume.center);\n    // return modelMatrix;\n  }\n}\n"],"file":"oriented-bounding-box.js"}