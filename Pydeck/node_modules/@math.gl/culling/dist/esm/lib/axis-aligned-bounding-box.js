import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import { Vector3 } from 'math.gl';
import { Intersect } from '../constants';
var scratchVector = new Vector3();
var scratchNormal = new Vector3();

var AxisAlignedBoundingBox = function () {
  function AxisAlignedBoundingBox() {
    var minimum = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];
    var maximum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
    var center = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    _classCallCheck(this, AxisAlignedBoundingBox);

    center = center || scratchVector.copy(minimum).add(maximum).scale(0.5);
    this.minimum = new Vector3(minimum);
    this.maximum = new Vector3(maximum);
    this.center = new Vector3(center);
  }

  _createClass(AxisAlignedBoundingBox, [{
    key: "fromPoints",
    value: function fromPoints(positions) {
      if (!positions || positions.length === 0) {
        this.minimum.set(0, 0, 0);
        this.maximum.set(0, 0, 0);
        this.center.set(0, 0, 0);
        return this;
      }

      var minimumX = positions[0][0];
      var minimumY = positions[0][1];
      var minimumZ = positions[0][2];
      var maximumX = positions[0][0];
      var maximumY = positions[0][1];
      var maximumZ = positions[0][2];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = positions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var p = _step.value;
          var x = p[0];
          var y = p[1];
          var z = p[2];
          minimumX = Math.min(x, minimumX);
          maximumX = Math.max(x, maximumX);
          minimumY = Math.min(y, minimumY);
          maximumY = Math.max(y, maximumY);
          minimumZ = Math.min(z, minimumZ);
          maximumZ = Math.max(z, maximumZ);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.minimum.set(minimumX, minimumY, minimumZ);
      this.maximum.set(maximumX, maximumY, maximumZ);
      this.center.copy(this.minimum).add(this.maximum).scale(0.5);
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);
    }
  }, {
    key: "equals",
    value: function equals(right) {
      return this === right || Boolean(right) && this.center.equals(right.center) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum);
    }
  }, {
    key: "intersectPlane",
    value: function intersectPlane(plane) {
      var h = scratchVector.copy(this.maximum).subtract(this.minimum).scale(0.5);
      var normal = scratchNormal.from(plane.normal);
      var e = h.x * Math.abs(normal.x) + h.y * Math.abs(normal.y) + h.z * Math.abs(normal.z);
      var s = this.center.dot(normal) + plane.distance;

      if (s - e > 0) {
        return Intersect.INSIDE;
      }

      if (s + e < 0) {
        return Intersect.OUTSIDE;
      }

      return Intersect.INTERSECTING;
    }
  }]);

  return AxisAlignedBoundingBox;
}();

export { AxisAlignedBoundingBox as default };
//# sourceMappingURL=axis-aligned-bounding-box.js.map