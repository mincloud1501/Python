import _objectSpread from "@babel/runtime/helpers/esm/objectSpread";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import { Vector3, Vector4, Matrix4, assert } from 'math.gl';
import CullingVolume from './culling-volume';
var scratchPlaneRightVector = new Vector3();
var scratchPlaneNearCenter = new Vector3();
var scratchPlaneFarCenter = new Vector3();
var scratchPlaneNormal = new Vector3();

var PerspectiveOffCenterFrustum = function () {
  function PerspectiveOffCenterFrustum() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, PerspectiveOffCenterFrustum);

    options = _objectSpread({
      near: 1.0,
      far: 500000000.0
    }, options);
    this.left = options.left;
    this._left = undefined;
    this.right = options.right;
    this._right = undefined;
    this.top = options.top;
    this._top = undefined;
    this.bottom = options.bottom;
    this._bottom = undefined;
    this.near = options.near;
    this._near = this.near;
    this.far = options.far;
    this._far = this.far;
    this._cullingVolume = new CullingVolume();
    this._perspectiveMatrix = new Matrix4();
    this._infinitePerspective = new Matrix4();
  }

  _createClass(PerspectiveOffCenterFrustum, [{
    key: "clone",
    value: function clone() {
      return new PerspectiveOffCenterFrustum({
        right: this.right,
        left: this.left,
        top: this.top,
        bottom: this.bottom,
        near: this.near,
        far: this.far
      });
    }
  }, {
    key: "equals",
    value: function equals(other) {
      return other && other instanceof PerspectiveOffCenterFrustum && this.right === other.right && this.left === other.left && this.top === other.top && this.bottom === other.bottom && this.near === other.near && this.far === other.far;
    }
  }, {
    key: "computeCullingVolume",
    value: function computeCullingVolume(position, direction, up) {
      assert(position, 'position is required.');
      assert(direction, 'direction is required.');
      assert(up, 'up is required.');
      var planes = this._cullingVolume.planes;
      var right = scratchPlaneRightVector.copy(direction).cross(up);
      var nearCenter = scratchPlaneNearCenter.copy(direction).multiplyByScalar(this.near).add(position);
      var farCenter = scratchPlaneFarCenter.copy(direction).multiplyByScalar(this.far).add(position);
      var normal = scratchPlaneNormal;
      normal.copy(right).multiplyByScalar(this.left).add(nearCenter).subtract(position).normalize().cross(up).normalize();
      planes[0] = planes[0] || new Vector4();
      var plane = planes[0];
      plane.x = normal.x;
      plane.y = normal.y;
      plane.z = normal.z;
      plane.w = -normal.dot(position);
      normal.copy(right).multiplyByScalar(this.right).add(nearCenter).subtract(position).normalize().cross(up).normalize();
      planes[1] = planes[1] || new Vector4();
      plane = planes[1];
      plane.x = normal.x;
      plane.y = normal.y;
      plane.z = normal.z;
      plane.w = -normal.dot(position);
      normal.copy(up).multiplyByScalar(this.bottom).add(nearCenter).subtract(position).normalize().cross(right).normalize();
      planes[2] = planes[2] || new Vector4();
      plane = planes[2];
      plane.x = normal.x;
      plane.y = normal.y;
      plane.z = normal.z;
      plane.w = -normal.dot(position);
      normal.copy(up).multiplyByScalar(this.top).add(nearCenter).subtract(position).normalize().cross(right).normalize();
      planes[3] = planes[3] || new Vector4();
      plane = planes[3];
      plane.x = normal.x;
      plane.y = normal.y;
      plane.z = normal.z;
      plane.w = -normal.dot(position);
      normal = new Vector3().copy(direction).normalize();
      planes[4] = planes[4] || new Vector4();
      plane = planes[4];
      plane.x = direction.x;
      plane.y = direction.y;
      plane.z = direction.z;
      plane.w = -direction.dot(nearCenter);
      normal.copy(direction).negate().normalize();
      planes[5] = planes[5] || new Vector4();
      plane = planes[5];
      plane.x = normal.x;
      plane.y = normal.y;
      plane.z = normal.z;
      plane.w = -normal.dot(farCenter);
      return this._cullingVolume;
    }
  }, {
    key: "getPixelDimensions",
    value: function getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, result) {
      update(this);
      assert(Number.isFinite(drawingBufferWidth) && Number.isFinite(drawingBufferHeight));
      assert(drawingBufferWidth > 0);
      assert(drawingBufferHeight > 0);
      assert(distance > 0);
      assert(result);
      var inverseNear = 1.0 / this.near;
      var tanTheta = this.top * inverseNear;
      var pixelHeight = 2.0 * distance * tanTheta / drawingBufferHeight;
      tanTheta = this.right * inverseNear;
      var pixelWidth = 2.0 * distance * tanTheta / drawingBufferWidth;
      result.x = pixelWidth;
      result.y = pixelHeight;
      return result;
    }
  }, {
    key: "projectionMatrix",
    get: function get() {
      update(this);
      return this._perspectiveMatrix;
    }
  }, {
    key: "infiniteProjectionMatrix",
    get: function get() {
      update(this);
      return this._infinitePerspective;
    }
  }]);

  return PerspectiveOffCenterFrustum;
}();

export { PerspectiveOffCenterFrustum as default };

function update(frustum) {
  assert(Number.isFinite(frustum.right) && Number.isFinite(frustum.left) && Number.isFinite(frustum.top) && Number.isFinite(frustum.bottom) && Number.isFinite(frustum.near) && Number.isFinite(frustum.far));
  var top = frustum.top,
      bottom = frustum.bottom,
      right = frustum.right,
      left = frustum.left,
      near = frustum.near,
      far = frustum.far;

  if (top !== frustum._top || bottom !== frustum._bottom || left !== frustum._left || right !== frustum._right || near !== frustum._near || far !== frustum._far) {
    assert(frustum.near > 0 && frustum.near < frustum.far, 'near must be greater than zero and less than far.');
    frustum._left = left;
    frustum._right = right;
    frustum._top = top;
    frustum._bottom = bottom;
    frustum._near = near;
    frustum._far = far;
    frustum._perspectiveMatrix = new Matrix4().frustum({
      left: left,
      right: right,
      bottom: bottom,
      top: top,
      near: near,
      far: far
    });
    frustum._infinitePerspective = new Matrix4().frustum({
      left: left,
      right: right,
      bottom: bottom,
      top: top,
      near: near,
      far: Infinity
    });
  }
}
//# sourceMappingURL=perspective-off-center-frustum.js.map