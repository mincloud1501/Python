"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _math = require("math.gl");

var _cullingVolume = _interopRequireDefault(require("./culling-volume"));

var scratchPlaneRightVector = new _math.Vector3();
var scratchPlaneNearCenter = new _math.Vector3();
var scratchPlaneFarCenter = new _math.Vector3();
var scratchPlaneNormal = new _math.Vector3();

var PerspectiveOffCenterFrustum = function () {
  function PerspectiveOffCenterFrustum() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, PerspectiveOffCenterFrustum);
    options = (0, _objectSpread2["default"])({
      near: 1.0,
      far: 500000000.0
    }, options);
    this.left = options.left;
    this._left = undefined;
    this.right = options.right;
    this._right = undefined;
    this.top = options.top;
    this._top = undefined;
    this.bottom = options.bottom;
    this._bottom = undefined;
    this.near = options.near;
    this._near = this.near;
    this.far = options.far;
    this._far = this.far;
    this._cullingVolume = new _cullingVolume["default"]();
    this._perspectiveMatrix = new _math.Matrix4();
    this._infinitePerspective = new _math.Matrix4();
  }

  (0, _createClass2["default"])(PerspectiveOffCenterFrustum, [{
    key: "clone",
    value: function clone() {
      return new PerspectiveOffCenterFrustum({
        right: this.right,
        left: this.left,
        top: this.top,
        bottom: this.bottom,
        near: this.near,
        far: this.far
      });
    }
  }, {
    key: "equals",
    value: function equals(other) {
      return other && other instanceof PerspectiveOffCenterFrustum && this.right === other.right && this.left === other.left && this.top === other.top && this.bottom === other.bottom && this.near === other.near && this.far === other.far;
    }
  }, {
    key: "computeCullingVolume",
    value: function computeCullingVolume(position, direction, up) {
      (0, _math.assert)(position, 'position is required.');
      (0, _math.assert)(direction, 'direction is required.');
      (0, _math.assert)(up, 'up is required.');
      var planes = this._cullingVolume.planes;
      var right = scratchPlaneRightVector.copy(direction).cross(up);
      var nearCenter = scratchPlaneNearCenter.copy(direction).multiplyByScalar(this.near).add(position);
      var farCenter = scratchPlaneFarCenter.copy(direction).multiplyByScalar(this.far).add(position);
      var normal = scratchPlaneNormal;
      normal.copy(right).multiplyByScalar(this.left).add(nearCenter).subtract(position).normalize().cross(up).normalize();
      planes[0] = planes[0] || new _math.Vector4();
      var plane = planes[0];
      plane.x = normal.x;
      plane.y = normal.y;
      plane.z = normal.z;
      plane.w = -normal.dot(position);
      normal.copy(right).multiplyByScalar(this.right).add(nearCenter).subtract(position).normalize().cross(up).normalize();
      planes[1] = planes[1] || new _math.Vector4();
      plane = planes[1];
      plane.x = normal.x;
      plane.y = normal.y;
      plane.z = normal.z;
      plane.w = -normal.dot(position);
      normal.copy(up).multiplyByScalar(this.bottom).add(nearCenter).subtract(position).normalize().cross(right).normalize();
      planes[2] = planes[2] || new _math.Vector4();
      plane = planes[2];
      plane.x = normal.x;
      plane.y = normal.y;
      plane.z = normal.z;
      plane.w = -normal.dot(position);
      normal.copy(up).multiplyByScalar(this.top).add(nearCenter).subtract(position).normalize().cross(right).normalize();
      planes[3] = planes[3] || new _math.Vector4();
      plane = planes[3];
      plane.x = normal.x;
      plane.y = normal.y;
      plane.z = normal.z;
      plane.w = -normal.dot(position);
      normal = new _math.Vector3().copy(direction).normalize();
      planes[4] = planes[4] || new _math.Vector4();
      plane = planes[4];
      plane.x = direction.x;
      plane.y = direction.y;
      plane.z = direction.z;
      plane.w = -direction.dot(nearCenter);
      normal.copy(direction).negate().normalize();
      planes[5] = planes[5] || new _math.Vector4();
      plane = planes[5];
      plane.x = normal.x;
      plane.y = normal.y;
      plane.z = normal.z;
      plane.w = -normal.dot(farCenter);
      return this._cullingVolume;
    }
  }, {
    key: "getPixelDimensions",
    value: function getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, result) {
      update(this);
      (0, _math.assert)(Number.isFinite(drawingBufferWidth) && Number.isFinite(drawingBufferHeight));
      (0, _math.assert)(drawingBufferWidth > 0);
      (0, _math.assert)(drawingBufferHeight > 0);
      (0, _math.assert)(distance > 0);
      (0, _math.assert)(result);
      var inverseNear = 1.0 / this.near;
      var tanTheta = this.top * inverseNear;
      var pixelHeight = 2.0 * distance * tanTheta / drawingBufferHeight;
      tanTheta = this.right * inverseNear;
      var pixelWidth = 2.0 * distance * tanTheta / drawingBufferWidth;
      result.x = pixelWidth;
      result.y = pixelHeight;
      return result;
    }
  }, {
    key: "projectionMatrix",
    get: function get() {
      update(this);
      return this._perspectiveMatrix;
    }
  }, {
    key: "infiniteProjectionMatrix",
    get: function get() {
      update(this);
      return this._infinitePerspective;
    }
  }]);
  return PerspectiveOffCenterFrustum;
}();

exports["default"] = PerspectiveOffCenterFrustum;

function update(frustum) {
  (0, _math.assert)(Number.isFinite(frustum.right) && Number.isFinite(frustum.left) && Number.isFinite(frustum.top) && Number.isFinite(frustum.bottom) && Number.isFinite(frustum.near) && Number.isFinite(frustum.far));
  var top = frustum.top,
      bottom = frustum.bottom,
      right = frustum.right,
      left = frustum.left,
      near = frustum.near,
      far = frustum.far;

  if (top !== frustum._top || bottom !== frustum._bottom || left !== frustum._left || right !== frustum._right || near !== frustum._near || far !== frustum._far) {
    (0, _math.assert)(frustum.near > 0 && frustum.near < frustum.far, 'near must be greater than zero and less than far.');
    frustum._left = left;
    frustum._right = right;
    frustum._top = top;
    frustum._bottom = bottom;
    frustum._near = near;
    frustum._far = far;
    frustum._perspectiveMatrix = new _math.Matrix4().frustum({
      left: left,
      right: right,
      bottom: bottom,
      top: top,
      near: near,
      far: far
    });
    frustum._infinitePerspective = new _math.Matrix4().frustum({
      left: left,
      right: right,
      bottom: bottom,
      top: top,
      near: near,
      far: Infinity
    });
  }
}
//# sourceMappingURL=perspective-off-center-frustum.js.map