"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _math = require("math.gl");

var _constants = require("../constants");

var scratchVector = new _math.Vector3();
var scratchNormal = new _math.Vector3();

var AxisAlignedBoundingBox = function () {
  function AxisAlignedBoundingBox() {
    var minimum = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];
    var maximum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
    var center = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    (0, _classCallCheck2["default"])(this, AxisAlignedBoundingBox);
    center = center || scratchVector.copy(minimum).add(maximum).scale(0.5);
    this.minimum = new _math.Vector3(minimum);
    this.maximum = new _math.Vector3(maximum);
    this.center = new _math.Vector3(center);
  }

  (0, _createClass2["default"])(AxisAlignedBoundingBox, [{
    key: "fromPoints",
    value: function fromPoints(positions) {
      if (!positions || positions.length === 0) {
        this.minimum.set(0, 0, 0);
        this.maximum.set(0, 0, 0);
        this.center.set(0, 0, 0);
        return this;
      }

      var minimumX = positions[0][0];
      var minimumY = positions[0][1];
      var minimumZ = positions[0][2];
      var maximumX = positions[0][0];
      var maximumY = positions[0][1];
      var maximumZ = positions[0][2];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = positions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var p = _step.value;
          var x = p[0];
          var y = p[1];
          var z = p[2];
          minimumX = Math.min(x, minimumX);
          maximumX = Math.max(x, maximumX);
          minimumY = Math.min(y, minimumY);
          maximumY = Math.max(y, maximumY);
          minimumZ = Math.min(z, minimumZ);
          maximumZ = Math.max(z, maximumZ);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.minimum.set(minimumX, minimumY, minimumZ);
      this.maximum.set(maximumX, maximumY, maximumZ);
      this.center.copy(this.minimum).add(this.maximum).scale(0.5);
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);
    }
  }, {
    key: "equals",
    value: function equals(right) {
      return this === right || Boolean(right) && this.center.equals(right.center) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum);
    }
  }, {
    key: "intersectPlane",
    value: function intersectPlane(plane) {
      var h = scratchVector.copy(this.maximum).subtract(this.minimum).scale(0.5);
      var normal = scratchNormal.from(plane.normal);
      var e = h.x * Math.abs(normal.x) + h.y * Math.abs(normal.y) + h.z * Math.abs(normal.z);
      var s = this.center.dot(normal) + plane.distance;

      if (s - e > 0) {
        return _constants.Intersect.INSIDE;
      }

      if (s + e < 0) {
        return _constants.Intersect.OUTSIDE;
      }

      return _constants.Intersect.INTERSECTING;
    }
  }]);
  return AxisAlignedBoundingBox;
}();

exports["default"] = AxisAlignedBoundingBox;
//# sourceMappingURL=axis-aligned-bounding-box.js.map