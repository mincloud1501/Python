{"version":3,"sources":["../../../src/lib/axis-aligned-bounding-box.js"],"names":["scratchVector","Vector3","scratchNormal","AxisAlignedBoundingBox","minimum","maximum","center","copy","add","scale","positions","length","set","minimumX","minimumY","minimumZ","maximumX","maximumY","maximumZ","p","x","y","z","Math","min","max","right","Boolean","equals","plane","h","subtract","normal","from","e","abs","s","dot","distance","Intersect","INSIDE","OUTSIDE","INTERSECTING"],"mappings":"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","sourcesContent":["import {Vector3} from 'math.gl';\nimport {Intersect} from '../constants';\n\nconst scratchVector = new Vector3();\nconst scratchNormal = new Vector3();\n\n/**\n * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.\n * @alias AxisAlignedBoundingBox\n * @constructor\n *\n * @param {Vector3} [minimum=0, 0, 0] The minimum point along the x, y, and z axes.\n * @param {Vector3} [maximum=0, 0, 0] The maximum point along the x, y, and z axes.\n * @param {Vector3} [center] The center of the box; automatically computed if not supplied.\n *\n * @see BoundingSphere\n * @see BoundingRectangle\n */\nexport default class AxisAlignedBoundingBox {\n  constructor(minimum = [0, 0, 0], maximum = [0, 0, 0], center = null) {\n    // If center was not defined, compute it.\n    center =\n      center ||\n      scratchVector\n        .copy(minimum)\n        .add(maximum)\n        .scale(0.5);\n\n    /**\n     * The minimum point defining the bounding box.\n     * @type {Vector3}\n     * @default {@link 0, 0, 0}\n     */\n    this.minimum = new Vector3(minimum);\n\n    /**\n     * The maximum point defining the bounding box.\n     * @type {Vector3}\n     * @default {@link 0, 0, 0}\n     */\n    this.maximum = new Vector3(maximum);\n\n    /**\n     * The center point of the bounding box.\n     * @type {Vector3}\n     */\n    this.center = new Vector3(center);\n  }\n\n  /**\n   * Computes an instance of an AxisAlignedBoundingBox. The box is determined by\n   * finding the points spaced the farthest apart on the x, y, and z axes.\n   *\n   * @param {Vector3[]} positions List of points that the bounding box will enclose.  Each point must have a <code>x</code>, <code>y</code>, and <code>z</code> properties.\n   * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n   * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\n   *\n   * @example\n   * // Compute an axis aligned bounding box enclosing two points.\n   * const box = Cesium.AxisAlignedBoundingBox.fromPoints([new Cesium.Vector3(2, 0, 0), new Cesium.Vector3(-2, 0, 0)]);\n   */\n  // eslint-disable-next-line\n  fromPoints(positions) {\n    if (!positions || positions.length === 0) {\n      this.minimum.set(0, 0, 0);\n      this.maximum.set(0, 0, 0);\n      this.center.set(0, 0, 0);\n      return this;\n    }\n\n    let minimumX = positions[0][0];\n    let minimumY = positions[0][1];\n    let minimumZ = positions[0][2];\n\n    let maximumX = positions[0][0];\n    let maximumY = positions[0][1];\n    let maximumZ = positions[0][2];\n\n    for (const p of positions) {\n      const x = p[0];\n      const y = p[1];\n      const z = p[2];\n\n      minimumX = Math.min(x, minimumX);\n      maximumX = Math.max(x, maximumX);\n      minimumY = Math.min(y, minimumY);\n      maximumY = Math.max(y, maximumY);\n      minimumZ = Math.min(z, minimumZ);\n      maximumZ = Math.max(z, maximumZ);\n    }\n\n    this.minimum.set(minimumX, minimumY, minimumZ);\n    this.maximum.set(maximumX, maximumY, maximumZ);\n    this.center\n      .copy(this.minimum)\n      .add(this.maximum)\n      .scale(0.5);\n\n    return this;\n  }\n\n  /**\n   * Duplicates a AxisAlignedBoundingBox instance.\n   *\n   * @returns {AxisAlignedBoundingBox} A new AxisAlignedBoundingBox instance.\n   */\n  clone() {\n    return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);\n  }\n\n  /**\n   * Compares the provided AxisAlignedBoundingBox componentwise and returns\n   * <code>true</code> if they are equal, <code>false</code> otherwise.\n   *\n   * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox to compare with.\n   * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n   */\n  equals(right) {\n    return (\n      this === right ||\n      (Boolean(right) &&\n        this.center.equals(right.center) &&\n        this.minimum.equals(right.minimum) &&\n        this.maximum.equals(right.maximum))\n    );\n  }\n\n  /**\n   * Determines which side of a plane a box is located.\n   *\n   * @param {Plane} plane The plane to test against.\n   * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n   *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n   *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n   *                      intersects the plane.\n   */\n  intersectPlane(plane) {\n    const h = scratchVector\n      .copy(this.maximum)\n      .subtract(this.minimum)\n      .scale(0.5); // The positive half diagonal\n    const normal = scratchNormal.from(plane.normal);\n    const e = h.x * Math.abs(normal.x) + h.y * Math.abs(normal.y) + h.z * Math.abs(normal.z);\n    const s = this.center.dot(normal) + plane.distance; // signed distance from center\n\n    if (s - e > 0) {\n      return Intersect.INSIDE;\n    }\n\n    if (s + e < 0) {\n      // Not in front because normals point inward\n      return Intersect.OUTSIDE;\n    }\n\n    return Intersect.INTERSECTING;\n  }\n}\n"],"file":"axis-aligned-bounding-box.js"}