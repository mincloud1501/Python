"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _math = require("math.gl");

var _boundingSphere = _interopRequireDefault(require("./bounding-sphere"));

var _constants = require("../constants");

var _boundingBoxFromPoints = _interopRequireDefault(require("../algorithms/bounding-box-from-points"));

var scratchVector = new _math.Vector3();
var scratchOffset = new _math.Vector3();
var scratchVectorU = new _math.Vector3();
var scratchVectorV = new _math.Vector3();
var scratchVectorW = new _math.Vector3();
var scratchPPrime = new _math.Vector3();
var scratchCorner = new _math.Vector3();
var scratchToCenter = new _math.Vector3();
var fromOrientedBoundingBoxScratchU = new _math.Vector3();
var fromOrientedBoundingBoxScratchV = new _math.Vector3();
var fromOrientedBoundingBoxScratchW = new _math.Vector3();
var MATRIX3 = {
  COLUMN0ROW0: 0,
  COLUMN0ROW1: 1,
  COLUMN0ROW2: 2,
  COLUMN1ROW0: 3,
  COLUMN1ROW1: 4,
  COLUMN1ROW2: 5,
  COLUMN2ROW0: 6,
  COLUMN2ROW1: 7,
  COLUMN2ROW2: 8
};

var OrientedBoundingBox = function () {
  function OrientedBoundingBox() {
    var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];
    var halfAxes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0, 0, 0, 0, 0, 0, 0];
    (0, _classCallCheck2["default"])(this, OrientedBoundingBox);
    this.center = new _math.Vector3().from(center);
    this.halfAxes = new _math.Matrix3(halfAxes);
  }

  (0, _createClass2["default"])(OrientedBoundingBox, [{
    key: "clone",
    value: function clone(result) {
      return new OrientedBoundingBox(this.center, this.halfAxes);
    }
  }, {
    key: "fromPoints",
    value: function fromPoints(points) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new OrientedBoundingBox();
      return (0, _boundingBoxFromPoints["default"])(points, result);
    }
  }, {
    key: "equals",
    value: function equals(right) {
      return this === right || Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes);
    }
  }, {
    key: "getBoundingSphere",
    value: function getBoundingSphere() {
      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _boundingSphere["default"]();
      var halfAxes = this.halfAxes;
      var u = halfAxes.getColumn(0, fromOrientedBoundingBoxScratchU);
      var v = halfAxes.getColumn(1, fromOrientedBoundingBoxScratchV);
      var w = halfAxes.getColumn(2, fromOrientedBoundingBoxScratchW);
      var cornerVector = scratchVector.copy(u).add(v).add(w);
      result.center.copy(this.center);
      result.radius = cornerVector.magnitude();
      return result;
    }
  }, {
    key: "intersectPlane",
    value: function intersectPlane(plane) {
      var center = this.center;
      var normal = plane.normal;
      var halfAxes = this.halfAxes;
      var normalX = normal.x;
      var normalY = normal.y;
      var normalZ = normal.z;
      var radEffective = Math.abs(normalX * halfAxes[MATRIX3.COLUMN0ROW0] + normalY * halfAxes[MATRIX3.COLUMN0ROW1] + normalZ * halfAxes[MATRIX3.COLUMN0ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN1ROW0] + normalY * halfAxes[MATRIX3.COLUMN1ROW1] + normalZ * halfAxes[MATRIX3.COLUMN1ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN2ROW0] + normalY * halfAxes[MATRIX3.COLUMN2ROW1] + normalZ * halfAxes[MATRIX3.COLUMN2ROW2]);
      var distanceToPlane = normal.dot(center) + plane.distance;

      if (distanceToPlane <= -radEffective) {
        return _constants.Intersect.OUTSIDE;
      } else if (distanceToPlane >= radEffective) {
        return _constants.Intersect.INSIDE;
      }

      return _constants.Intersect.INTERSECTING;
    }
  }, {
    key: "distanceTo",
    value: function distanceTo(point) {
      return Math.sqrt(this.distanceSquaredTo(point));
    }
  }, {
    key: "distanceSquaredTo",
    value: function distanceSquaredTo(point) {
      var offset = scratchOffset.copy(point).subtract(this.center);
      var halfAxes = this.halfAxes;
      var u = halfAxes.getColumn(0, scratchVectorU);
      var v = halfAxes.getColumn(1, scratchVectorV);
      var w = halfAxes.getColumn(2, scratchVectorW);
      var uHalf = u.magnitude();
      var vHalf = v.magnitude();
      var wHalf = w.magnitude();
      u.normalize();
      v.normalize();
      w.normalize();
      var pPrime = scratchPPrime;
      pPrime.x = offset.dot(u);
      pPrime.y = offset.dot(v);
      pPrime.z = offset.dot(w);
      var distanceSquared = 0.0;
      var d;

      if (pPrime.x < -uHalf) {
        d = pPrime.x + uHalf;
        distanceSquared += d * d;
      } else if (pPrime.x > uHalf) {
        d = pPrime.x - uHalf;
        distanceSquared += d * d;
      }

      if (pPrime.y < -vHalf) {
        d = pPrime.y + vHalf;
        distanceSquared += d * d;
      } else if (pPrime.y > vHalf) {
        d = pPrime.y - vHalf;
        distanceSquared += d * d;
      }

      if (pPrime.z < -wHalf) {
        d = pPrime.z + wHalf;
        distanceSquared += d * d;
      } else if (pPrime.z > wHalf) {
        d = pPrime.z - wHalf;
        distanceSquared += d * d;
      }

      return distanceSquared;
    }
  }, {
    key: "computePlaneDistances",
    value: function computePlaneDistances(position, direction) {
      var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [[], []];
      var minDist = Number.POSITIVE_INFINITY;
      var maxDist = Number.NEGATIVE_INFINITY;
      var center = this.center;
      var halfAxes = this.halfAxes;
      var u = halfAxes.getColumn(0, scratchVectorU);
      var v = halfAxes.getColumn(1, scratchVectorV);
      var w = halfAxes.getColumn(2, scratchVectorW);
      var corner = scratchCorner.copy(u).add(v).add(w).add(center);
      var toCenter = scratchToCenter.copy(corner).subtract(position);
      var mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      corner.copy(center).add(u).add(v).subtract(w);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      corner.copy(center).add(u).subtract(v).add(w);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      corner.copy(center).add(u).subtract(v).subtract(w);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      center.copy(corner).subtract(u).add(v).add(w);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      center.copy(corner).subtract(u).add(v).subtract(w);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      center.copy(corner).subtract(u).subtract(v).add(w);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      center.copy(corner).subtract(u).subtract(v).subtract(w);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      result.start = minDist;
      result.stop = maxDist;
      return result;
    }
  }, {
    key: "getTransform",
    value: function getTransform() {}
  }]);
  return OrientedBoundingBox;
}();

exports["default"] = OrientedBoundingBox;
//# sourceMappingURL=oriented-bounding-box.js.map