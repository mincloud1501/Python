"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = makeOrientedBoundingBoxfromPoints;

var _math = require("math.gl");

var _computeEigenDecomposition = _interopRequireDefault(require("./compute-eigen-decomposition"));

var scratchVector2 = new _math.Vector3();
var scratchVector3 = new _math.Vector3();
var scratchVector4 = new _math.Vector3();
var scratchVector5 = new _math.Vector3();
var scratchVector6 = new _math.Vector3();
var scratchCovarianceResult = new _math.Matrix3();
var scratchEigenResult = {
  diagonal: new _math.Matrix3(),
  unitary: new _math.Matrix3()
};

function makeOrientedBoundingBoxfromPoints(positions, result) {
  if (!positions || positions.length === 0) {
    result.halfAxes = new _math.Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);
    result.center = new _math.Vector3();
    return result;
  }

  var length = positions.length;
  var meanPoint = new _math.Vector3(0, 0, 0);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = positions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var position = _step.value;
      meanPoint.add(position);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var invLength = 1.0 / length;
  meanPoint.multiplyByScalar(invLength);
  var exx = 0.0;
  var exy = 0.0;
  var exz = 0.0;
  var eyy = 0.0;
  var eyz = 0.0;
  var ezz = 0.0;
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = positions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _position = _step2.value;
      var p = scratchVector2.copy(_position).subtract(meanPoint);
      exx += p.x * p.x;
      exy += p.x * p.y;
      exz += p.x * p.z;
      eyy += p.y * p.y;
      eyz += p.y * p.z;
      ezz += p.z * p.z;
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  exx *= invLength;
  exy *= invLength;
  exz *= invLength;
  eyy *= invLength;
  eyz *= invLength;
  ezz *= invLength;
  var covarianceMatrix = scratchCovarianceResult;
  covarianceMatrix[0] = exx;
  covarianceMatrix[1] = exy;
  covarianceMatrix[2] = exz;
  covarianceMatrix[3] = exy;
  covarianceMatrix[4] = eyy;
  covarianceMatrix[5] = eyz;
  covarianceMatrix[6] = exz;
  covarianceMatrix[7] = eyz;
  covarianceMatrix[8] = ezz;

  var _computeEigenDecompos = (0, _computeEigenDecomposition["default"])(covarianceMatrix, scratchEigenResult),
      unitary = _computeEigenDecompos.unitary;

  var rotation = result.halfAxes.copy(unitary);
  var v1 = rotation.getColumn(0, scratchVector4);
  var v2 = rotation.getColumn(1, scratchVector5);
  var v3 = rotation.getColumn(2, scratchVector6);
  var u1 = -Number.MAX_VALUE;
  var u2 = -Number.MAX_VALUE;
  var u3 = -Number.MAX_VALUE;
  var l1 = Number.MAX_VALUE;
  var l2 = Number.MAX_VALUE;
  var l3 = Number.MAX_VALUE;
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = positions[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var _position2 = _step3.value;
      u1 = Math.max(_position2.dot(v1), u1);
      u2 = Math.max(_position2.dot(v2), u2);
      u3 = Math.max(_position2.dot(v3), u3);
      l1 = Math.min(_position2.dot(v1), l1);
      l2 = Math.min(_position2.dot(v2), l2);
      l3 = Math.min(_position2.dot(v3), l3);
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  v1 = v1.multiplyByScalar(0.5 * (l1 + u1));
  v2 = v2.multiplyByScalar(0.5 * (l2 + u2));
  v3 = v3.multiplyByScalar(0.5 * (l3 + u3));
  result.center.copy(v1).add(v2).add(v3);
  var scale = scratchVector3.set(u1 - l1, u2 - l2, u3 - l3).multiplyByScalar(0.5);
  result.halfAxes.multiplyByScalar(scale);
  return result;
}
//# sourceMappingURL=bounding-box-from-points.js.map