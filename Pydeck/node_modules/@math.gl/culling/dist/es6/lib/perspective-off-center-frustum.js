import _objectSpread from "@babel/runtime/helpers/esm/objectSpread";
import { Vector3, Vector4, Matrix4, assert } from 'math.gl';
import CullingVolume from './culling-volume';
const scratchPlaneRightVector = new Vector3();
const scratchPlaneNearCenter = new Vector3();
const scratchPlaneFarCenter = new Vector3();
const scratchPlaneNormal = new Vector3();
export default class PerspectiveOffCenterFrustum {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    options = _objectSpread({
      near: 1.0,
      far: 500000000.0
    }, options);
    this.left = options.left;
    this._left = undefined;
    this.right = options.right;
    this._right = undefined;
    this.top = options.top;
    this._top = undefined;
    this.bottom = options.bottom;
    this._bottom = undefined;
    this.near = options.near;
    this._near = this.near;
    this.far = options.far;
    this._far = this.far;
    this._cullingVolume = new CullingVolume();
    this._perspectiveMatrix = new Matrix4();
    this._infinitePerspective = new Matrix4();
  }

  clone() {
    return new PerspectiveOffCenterFrustum({
      right: this.right,
      left: this.left,
      top: this.top,
      bottom: this.bottom,
      near: this.near,
      far: this.far
    });
  }

  equals(other) {
    return other && other instanceof PerspectiveOffCenterFrustum && this.right === other.right && this.left === other.left && this.top === other.top && this.bottom === other.bottom && this.near === other.near && this.far === other.far;
  }

  get projectionMatrix() {
    update(this);
    return this._perspectiveMatrix;
  }

  get infiniteProjectionMatrix() {
    update(this);
    return this._infinitePerspective;
  }

  computeCullingVolume(position, direction, up) {
    assert(position, 'position is required.');
    assert(direction, 'direction is required.');
    assert(up, 'up is required.');
    const planes = this._cullingVolume.planes;
    const right = scratchPlaneRightVector.copy(direction).cross(up);
    const nearCenter = scratchPlaneNearCenter.copy(direction).multiplyByScalar(this.near).add(position);
    const farCenter = scratchPlaneFarCenter.copy(direction).multiplyByScalar(this.far).add(position);
    let normal = scratchPlaneNormal;
    normal.copy(right).multiplyByScalar(this.left).add(nearCenter).subtract(position).normalize().cross(up).normalize();
    planes[0] = planes[0] || new Vector4();
    let plane = planes[0];
    plane.x = normal.x;
    plane.y = normal.y;
    plane.z = normal.z;
    plane.w = -normal.dot(position);
    normal.copy(right).multiplyByScalar(this.right).add(nearCenter).subtract(position).normalize().cross(up).normalize();
    planes[1] = planes[1] || new Vector4();
    plane = planes[1];
    plane.x = normal.x;
    plane.y = normal.y;
    plane.z = normal.z;
    plane.w = -normal.dot(position);
    normal.copy(up).multiplyByScalar(this.bottom).add(nearCenter).subtract(position).normalize().cross(right).normalize();
    planes[2] = planes[2] || new Vector4();
    plane = planes[2];
    plane.x = normal.x;
    plane.y = normal.y;
    plane.z = normal.z;
    plane.w = -normal.dot(position);
    normal.copy(up).multiplyByScalar(this.top).add(nearCenter).subtract(position).normalize().cross(right).normalize();
    planes[3] = planes[3] || new Vector4();
    plane = planes[3];
    plane.x = normal.x;
    plane.y = normal.y;
    plane.z = normal.z;
    plane.w = -normal.dot(position);
    normal = new Vector3().copy(direction).normalize();
    planes[4] = planes[4] || new Vector4();
    plane = planes[4];
    plane.x = direction.x;
    plane.y = direction.y;
    plane.z = direction.z;
    plane.w = -direction.dot(nearCenter);
    normal.copy(direction).negate().normalize();
    planes[5] = planes[5] || new Vector4();
    plane = planes[5];
    plane.x = normal.x;
    plane.y = normal.y;
    plane.z = normal.z;
    plane.w = -normal.dot(farCenter);
    return this._cullingVolume;
  }

  getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, result) {
    update(this);
    assert(Number.isFinite(drawingBufferWidth) && Number.isFinite(drawingBufferHeight));
    assert(drawingBufferWidth > 0);
    assert(drawingBufferHeight > 0);
    assert(distance > 0);
    assert(result);
    const inverseNear = 1.0 / this.near;
    let tanTheta = this.top * inverseNear;
    const pixelHeight = 2.0 * distance * tanTheta / drawingBufferHeight;
    tanTheta = this.right * inverseNear;
    const pixelWidth = 2.0 * distance * tanTheta / drawingBufferWidth;
    result.x = pixelWidth;
    result.y = pixelHeight;
    return result;
  }

}

function update(frustum) {
  assert(Number.isFinite(frustum.right) && Number.isFinite(frustum.left) && Number.isFinite(frustum.top) && Number.isFinite(frustum.bottom) && Number.isFinite(frustum.near) && Number.isFinite(frustum.far));
  const {
    top,
    bottom,
    right,
    left,
    near,
    far
  } = frustum;

  if (top !== frustum._top || bottom !== frustum._bottom || left !== frustum._left || right !== frustum._right || near !== frustum._near || far !== frustum._far) {
    assert(frustum.near > 0 && frustum.near < frustum.far, 'near must be greater than zero and less than far.');
    frustum._left = left;
    frustum._right = right;
    frustum._top = top;
    frustum._bottom = bottom;
    frustum._near = near;
    frustum._far = far;
    frustum._perspectiveMatrix = new Matrix4().frustum({
      left,
      right,
      bottom,
      top,
      near,
      far
    });
    frustum._infinitePerspective = new Matrix4().frustum({
      left,
      right,
      bottom,
      top,
      near,
      far: Infinity
    });
  }
}
//# sourceMappingURL=perspective-off-center-frustum.js.map