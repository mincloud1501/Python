import { Vector3, Vector4, assert } from 'math.gl';
import { Intersect } from '../constants';
import Plane from './plane';
const faces = [new Vector3([1, 0, 0]), new Vector3([0, 1, 0]), new Vector3([0, 0, 1])];
const scratchPlaneCenter = new Vector3();
const scratchPlaneNormal = new Vector3();
const scratchPlane = new Plane(new Vector3(1.0, 0.0, 0.0), 0.0);
export default class CullingVolume {
  static get MASK_OUTSIDE() {
    return 0xffffffff;
  }

  static get MASK_INSIDE() {
    return 0x00000000;
  }

  static get MASK_INDETERMINATE() {
    return 0x7fffffff;
  }

  constructor() {
    let planes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    this.planes = planes;
    assert(this.planes.every(plane => plane instanceof Plane));
  }

  fromBoundingSphere(boundingSphere) {
    this.planes.length = 2 * faces.length;
    const center = boundingSphere.center;
    const radius = boundingSphere.radius;
    let planeIndex = 0;

    for (const faceNormal of faces) {
      let plane0 = this.planes[planeIndex];
      let plane1 = this.planes[planeIndex + 1];

      if (!plane0) {
        plane0 = this.planes[planeIndex] = new Vector4();
      }

      if (!plane1) {
        plane1 = this.planes[planeIndex + 1] = new Vector4();
      }

      const plane0Center = scratchPlaneCenter.copy(faceNormal).scale(-radius).add(center);
      const plane0Distance = -faceNormal.dot(plane0Center);
      plane0.x = faceNormal.x;
      plane0.y = faceNormal.y;
      plane0.z = faceNormal.z;
      plane0.w = plane0Distance;
      const plane1Center = scratchPlaneCenter.copy(faceNormal).scale(radius).add(center);
      const negatedFaceNormal = scratchPlaneNormal.copy(faceNormal).negate();
      const plane1Distance = -negatedFaceNormal.dot(plane1Center);
      plane1.x = negatedFaceNormal.x;
      plane1.y = negatedFaceNormal.y;
      plane1.z = negatedFaceNormal.z;
      plane1.w = plane1Distance;
      planeIndex += 2;
    }

    return this;
  }

  computeVisibility(boundingVolume) {
    assert(boundingVolume);
    let intersect = Intersect.INSIDE;

    for (const planeCoefficients of this.planes) {
      const plane = scratchPlane.fromCoefficients(...planeCoefficients);
      const result = boundingVolume.intersectPlane(plane);

      switch (result) {
        case Intersect.OUTSIDE:
          return Intersect.OUTSIDE;

        case Intersect.INTERSECTING:
          intersect = Intersect.INTERSECTING;
          break;

        default:
      }
    }

    return intersect;
  }

  computeVisibilityWithPlaneMask(boundingVolume, parentPlaneMask) {
    assert(boundingVolume, 'boundingVolume is required.');
    assert(Number.isFinite(parentPlaneMask), 'parentPlaneMask is required.');

    if (parentPlaneMask === CullingVolume.MASK_OUTSIDE || parentPlaneMask === CullingVolume.MASK_INSIDE) {
      return parentPlaneMask;
    }

    let mask = CullingVolume.MASK_INSIDE;
    const planes = this.planes;

    for (let k = 0; k < this.planes.length; ++k) {
      const flag = k < 31 ? 1 << k : 0;

      if (k < 31 && (parentPlaneMask & flag) === 0) {
        continue;
      }

      const plane = scratchPlane.fromCoefficients(...planes[k]);
      const result = boundingVolume.intersectPlane(plane);

      if (result === Intersect.OUTSIDE) {
        return CullingVolume.MASK_OUTSIDE;
      } else if (result === Intersect.INTERSECTING) {
        mask |= flag;
      }
    }

    return mask;
  }

}
//# sourceMappingURL=culling-volume.js.map