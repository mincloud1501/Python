import { Vector3 } from 'math.gl';
import { Intersect } from '../constants';
const scratchVector = new Vector3();
const scratchNormal = new Vector3();
export default class AxisAlignedBoundingBox {
  constructor() {
    let minimum = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];
    let maximum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
    let center = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    center = center || scratchVector.copy(minimum).add(maximum).scale(0.5);
    this.minimum = new Vector3(minimum);
    this.maximum = new Vector3(maximum);
    this.center = new Vector3(center);
  }

  fromPoints(positions) {
    if (!positions || positions.length === 0) {
      this.minimum.set(0, 0, 0);
      this.maximum.set(0, 0, 0);
      this.center.set(0, 0, 0);
      return this;
    }

    let minimumX = positions[0][0];
    let minimumY = positions[0][1];
    let minimumZ = positions[0][2];
    let maximumX = positions[0][0];
    let maximumY = positions[0][1];
    let maximumZ = positions[0][2];

    for (const p of positions) {
      const x = p[0];
      const y = p[1];
      const z = p[2];
      minimumX = Math.min(x, minimumX);
      maximumX = Math.max(x, maximumX);
      minimumY = Math.min(y, minimumY);
      maximumY = Math.max(y, maximumY);
      minimumZ = Math.min(z, minimumZ);
      maximumZ = Math.max(z, maximumZ);
    }

    this.minimum.set(minimumX, minimumY, minimumZ);
    this.maximum.set(maximumX, maximumY, maximumZ);
    this.center.copy(this.minimum).add(this.maximum).scale(0.5);
    return this;
  }

  clone() {
    return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);
  }

  equals(right) {
    return this === right || Boolean(right) && this.center.equals(right.center) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum);
  }

  intersectPlane(plane) {
    const h = scratchVector.copy(this.maximum).subtract(this.minimum).scale(0.5);
    const normal = scratchNormal.from(plane.normal);
    const e = h.x * Math.abs(normal.x) + h.y * Math.abs(normal.y) + h.z * Math.abs(normal.z);
    const s = this.center.dot(normal) + plane.distance;

    if (s - e > 0) {
      return Intersect.INSIDE;
    }

    if (s + e < 0) {
      return Intersect.OUTSIDE;
    }

    return Intersect.INTERSECTING;
  }

}
//# sourceMappingURL=axis-aligned-bounding-box.js.map