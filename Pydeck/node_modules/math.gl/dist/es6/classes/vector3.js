import Vector from './base/vector';
import { config, isArray } from '../lib/common';
import { checkNumber } from '../lib/validators';
import * as vec3 from 'gl-matrix/vec3';
import { vec3_transformMat2, vec3_transformMat4AsVector } from '../lib/gl-matrix-extras';
const ORIGIN = [0, 0, 0];
export default class Vector3 extends Vector {
  constructor() {
    let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    super(-0, -0, -0);

    if (arguments.length === 1 && isArray(x)) {
      this.copy(x);
    } else {
      if (config.debug) {
        checkNumber(x);
        checkNumber(y);
        checkNumber(z);
      }

      this[0] = x;
      this[1] = y;
      this[2] = z;
    }
  }

  set(x, y, z) {
    this[0] = x;
    this[1] = y;
    this[2] = z;
    return this.check();
  }

  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    return this.check();
  }

  fromObject(object) {
    if (config.debug) {
      checkNumber(object.x);
      checkNumber(object.y);
      checkNumber(object.z);
    }

    this[0] = object.x;
    this[1] = object.y;
    this[2] = object.z;
    return this.check();
  }

  toObject(object) {
    object.x = this[0];
    object.y = this[1];
    object.z = this[2];
    return object;
  }

  get ELEMENTS() {
    return 3;
  }

  get z() {
    return this[2];
  }

  set z(value) {
    return this[2] = checkNumber(value);
  }

  angle(vector) {
    return vec3.angle(this, vector);
  }

  cross(vector) {
    vec3.cross(this, this, vector);
    return this.check();
  }

  rotateX(_ref) {
    let {
      radians,
      origin = ORIGIN
    } = _ref;
    vec3.rotateX(this, this, origin, radians);
    return this.check();
  }

  rotateY(_ref2) {
    let {
      radians,
      origin = ORIGIN
    } = _ref2;
    vec3.rotateY(this, this, origin, radians);
    return this.check();
  }

  rotateZ(_ref3) {
    let {
      radians,
      origin = ORIGIN
    } = _ref3;
    vec3.rotateZ(this, this, origin, radians);
    return this.check();
  }

  transform(matrix4) {
    return this.transformAsPoint(matrix4);
  }

  transformAsPoint(matrix4) {
    vec3.transformMat4(this, this, matrix4);
    return this.check();
  }

  transformAsVector(matrix4) {
    vec3_transformMat4AsVector(this, this, matrix4);
    return this.check();
  }

  transformByMatrix3(matrix3) {
    vec3.transformMat3(this, this, matrix3);
    return this.check();
  }

  transformByMatrix2(matrix2) {
    vec3_transformMat2(this, this, matrix2);
    return this.check();
  }

  transformByQuaternion(quaternion) {
    vec3.transformQuat(this, this, quaternion);
    return this.check();
  }

}
//# sourceMappingURL=vector3.js.map