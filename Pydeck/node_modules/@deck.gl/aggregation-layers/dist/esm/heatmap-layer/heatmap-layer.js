import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _get from "@babel/runtime/helpers/esm/get";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

var _parameters;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { getBounds, boundsContain, packVertices, scaleToAspectRatio, getTextureCoordinates, getTextureParams } from './heatmap-layer-utils';
import { Buffer, Texture2D, Transform, getParameter, FEATURES, hasFeatures, isWebGL2 } from '@luma.gl/core';
import { CompositeLayer, AttributeManager, COORDINATE_SYSTEM, log } from '@deck.gl/core';
import TriangleLayer from './triangle-layer';
import { defaultColorRange, colorRangeToFlatArray } from '../utils/color-utils';
import weights_vs from './weights-vs.glsl';
import weights_fs from './weights-fs.glsl';
import vs_max from './max-vs.glsl';
var RESOLUTION = 2;
var SIZE_2K = 2048;
var ZOOM_DEBOUNCE = 500;
var TEXTURE_OPTIONS = {
  mipmaps: false,
  parameters: (_parameters = {}, _defineProperty(_parameters, 10240, 9729), _defineProperty(_parameters, 10241, 9729), _defineProperty(_parameters, 10242, 33071), _defineProperty(_parameters, 10243, 33071), _parameters),
  dataFormat: 6408
};
var DEFAULT_COLOR_DOMAIN = [0, 0];
var defaultProps = {
  getPosition: {
    type: 'accessor',
    value: function value(x) {
      return x.position;
    }
  },
  getWeight: {
    type: 'accessor',
    value: 1
  },
  intensity: {
    type: 'number',
    min: 0,
    value: 1
  },
  radiusPixels: {
    type: 'number',
    min: 1,
    max: 100,
    value: 30
  },
  colorRange: defaultColorRange,
  threshold: {
    type: 'number',
    min: 0,
    max: 1,
    value: 0.05
  },
  colorDomain: {
    type: 'array',
    value: null,
    optional: true
  }
};
var REQUIRED_FEATURES = [FEATURES.BLEND_EQUATION_MINMAX, FEATURES.TEXTURE_FLOAT];

var HeatmapLayer = function (_CompositeLayer) {
  _inherits(HeatmapLayer, _CompositeLayer);

  function HeatmapLayer() {
    _classCallCheck(this, HeatmapLayer);

    return _possibleConstructorReturn(this, _getPrototypeOf(HeatmapLayer).apply(this, arguments));
  }

  _createClass(HeatmapLayer, [{
    key: "initializeState",
    value: function initializeState() {
      var gl = this.context.gl;

      if (!hasFeatures(gl, REQUIRED_FEATURES)) {
        this.setState({
          supported: false
        });
        log.error("HeatmapLayer: ".concat(this.id, " is not supported on this browser"))();
        return;
      }

      this.setState({
        supported: true
      });

      this._setupTextureParams();

      this._setupAttributes();

      this._setupResources();
    }
  }, {
    key: "shouldUpdateState",
    value: function shouldUpdateState(_ref) {
      var changeFlags = _ref.changeFlags;
      return changeFlags.somethingChanged;
    }
  }, {
    key: "updateState",
    value: function updateState(opts) {
      if (!this.state.supported) {
        return;
      }

      _get(_getPrototypeOf(HeatmapLayer.prototype), "updateState", this).call(this, opts);

      var props = opts.props,
          oldProps = opts.oldProps;

      var changeFlags = this._getChangeFlags(opts);

      if (changeFlags.viewportChanged) {
        changeFlags.boundsChanged = this._updateBounds();
      }

      if (changeFlags.dataChanged || changeFlags.boundsChanged || changeFlags.uniformsChanged) {
        this._updateWeightmap();
      } else if (changeFlags.viewportZoomChanged) {
        this._debouncedUpdateWeightmap();
      }

      if (props.colorRange !== oldProps.colorRange) {
        this._updateColorTexture(opts);
      }

      if (changeFlags.viewportChanged) {
        this._updateTextureRenderingBounds();
      }

      if (oldProps.colorDomain !== props.colorDomain || changeFlags.viewportChanged) {
        var viewport = this.context.viewport;
        var weightsScale = this.state.weightsScale;
        var domainScale = (viewport ? 1024 / viewport.scale : 1) * weightsScale;
        var colorDomain = props.colorDomain ? props.colorDomain.map(function (x) {
          return x * domainScale;
        }) : DEFAULT_COLOR_DOMAIN;

        if (colorDomain[1] > 0 && weightsScale < 1) {
          var max = Math.min(colorDomain[1], 1);
          colorDomain[0] *= max / colorDomain[1];
          colorDomain[1] = max;
        }

        this.setState({
          colorDomain: colorDomain
        });
      }

      this.setState({
        zoom: opts.context.viewport.zoom
      });
    }
  }, {
    key: "renderLayers",
    value: function renderLayers() {
      if (!this.state.supported) {
        return [];
      }

      var _this$state = this.state,
          weightsTexture = _this$state.weightsTexture,
          triPositionBuffer = _this$state.triPositionBuffer,
          triTexCoordBuffer = _this$state.triTexCoordBuffer,
          maxWeightsTexture = _this$state.maxWeightsTexture,
          colorTexture = _this$state.colorTexture,
          colorDomain = _this$state.colorDomain;
      var _this$props = this.props,
          updateTriggers = _this$props.updateTriggers,
          intensity = _this$props.intensity,
          threshold = _this$props.threshold;
      return new TriangleLayer(this.getSubLayerProps({
        id: 'triangle-layer',
        updateTriggers: updateTriggers
      }), {
        data: {
          attributes: {
            positions: triPositionBuffer,
            texCoords: triTexCoordBuffer
          }
        },
        vertexCount: 4,
        maxTexture: maxWeightsTexture,
        colorTexture: colorTexture,
        texture: weightsTexture,
        intensity: intensity,
        threshold: threshold,
        colorDomain: colorDomain
      });
    }
  }, {
    key: "finalizeState",
    value: function finalizeState() {
      _get(_getPrototypeOf(HeatmapLayer.prototype), "finalizeState", this).call(this);

      var _this$state2 = this.state,
          weightsTransform = _this$state2.weightsTransform,
          weightsTexture = _this$state2.weightsTexture,
          maxWeightTransform = _this$state2.maxWeightTransform,
          maxWeightsTexture = _this$state2.maxWeightsTexture,
          triPositionBuffer = _this$state2.triPositionBuffer,
          triTexCoordBuffer = _this$state2.triTexCoordBuffer,
          colorTexture = _this$state2.colorTexture;
      weightsTransform && weightsTransform["delete"]();
      weightsTexture && weightsTexture["delete"]();
      maxWeightTransform && maxWeightTransform["delete"]();
      maxWeightsTexture && maxWeightsTexture["delete"]();
      triPositionBuffer && triPositionBuffer["delete"]();
      triTexCoordBuffer && triTexCoordBuffer["delete"]();
      colorTexture && colorTexture["delete"]();
    }
  }, {
    key: "_getAttributeManager",
    value: function _getAttributeManager() {
      return new AttributeManager(this.context.gl, {
        id: this.props.id,
        stats: this.context.stats
      });
    }
  }, {
    key: "_getChangeFlags",
    value: function _getChangeFlags(opts) {
      var oldProps = opts.oldProps,
          props = opts.props;
      var changeFlags = {};

      if (this._isDataChanged(opts)) {
        changeFlags.dataChanged = true;
      }

      if (oldProps.radiusPixels !== props.radiusPixels) {
        changeFlags.uniformsChanged = true;
      }

      changeFlags.viewportChanged = opts.changeFlags.viewportChanged;
      var zoom = this.state.zoom;

      if (!opts.context.viewport || opts.context.viewport.zoom !== zoom) {
        changeFlags.viewportZoomChanged = true;
      }

      return changeFlags;
    }
  }, {
    key: "_getTextures",
    value: function _getTextures() {
      var gl = this.context.gl;
      var _this$state3 = this.state,
          textureSize = _this$state3.textureSize,
          format = _this$state3.format,
          type = _this$state3.type;
      return {
        weightsTexture: new Texture2D(gl, _objectSpread({
          width: textureSize,
          height: textureSize,
          format: format,
          type: type
        }, TEXTURE_OPTIONS)),
        maxWeightsTexture: new Texture2D(gl, _objectSpread({
          format: format,
          type: type
        }, TEXTURE_OPTIONS))
      };
    }
  }, {
    key: "_isDataChanged",
    value: function _isDataChanged(_ref2) {
      var changeFlags = _ref2.changeFlags;

      if (changeFlags.dataChanged) {
        return true;
      }

      if (changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPosition || changeFlags.updateTriggersChanged.getWeight)) {
        return true;
      }

      return false;
    }
  }, {
    key: "_setupAttributes",
    value: function _setupAttributes() {
      var attributeManager = this.getAttributeManager();
      attributeManager.add({
        positions: {
          size: 3,
          accessor: 'getPosition'
        },
        weights: {
          size: 1,
          accessor: 'getWeight'
        }
      });
    }
  }, {
    key: "_setupTextureParams",
    value: function _setupTextureParams() {
      var gl = this.context.gl;
      var textureSize = Math.min(SIZE_2K, getParameter(gl, 3379));
      var floatTargetSupport = hasFeatures(gl, FEATURES.COLOR_ATTACHMENT_RGBA32F);

      var _getTextureParams = getTextureParams({
        gl: gl,
        floatTargetSupport: floatTargetSupport
      }),
          format = _getTextureParams.format,
          type = _getTextureParams.type;

      var weightsScale = floatTargetSupport ? 1 : 1 / 255;
      this.setState({
        textureSize: textureSize,
        format: format,
        type: type,
        weightsScale: weightsScale
      });

      if (!floatTargetSupport) {
        log.warn("HeatmapLayer: ".concat(this.id, " rendering to float texture not supported, fallingback to low precession format"))();
      }
    }
  }, {
    key: "_setupResources",
    value: function _setupResources() {
      var gl = this.context.gl;
      var textureSize = this.state.textureSize;

      var _this$_getTextures = this._getTextures(),
          weightsTexture = _this$_getTextures.weightsTexture,
          maxWeightsTexture = _this$_getTextures.maxWeightsTexture;

      var weightsTransform = new Transform(gl, {
        id: "".concat(this.id, "-weights-transform"),
        vs: weights_vs,
        _fs: weights_fs,
        modules: ['project32'],
        elementCount: 1,
        _targetTexture: weightsTexture,
        _targetTextureVarying: 'weightsTexture'
      });
      var maxWeightTransform = new Transform(gl, {
        id: "".concat(this.id, "-max-weights-transform"),
        _sourceTextures: {
          inTexture: weightsTexture
        },
        _targetTexture: maxWeightsTexture,
        _targetTextureVarying: 'outTexture',
        vs: vs_max,
        elementCount: textureSize * textureSize
      });
      this.setState({
        weightsTexture: weightsTexture,
        maxWeightsTexture: maxWeightsTexture,
        weightsTransform: weightsTransform,
        model: weightsTransform.model,
        maxWeightTransform: maxWeightTransform,
        zoom: null,
        triPositionBuffer: new Buffer(gl, {
          byteLength: 48,
          accessor: {
            size: 3
          }
        }),
        triTexCoordBuffer: new Buffer(gl, {
          byteLength: 48,
          accessor: {
            size: 2
          }
        })
      });
    }
  }, {
    key: "_updateMaxWeightValue",
    value: function _updateMaxWeightValue() {
      var maxWeightTransform = this.state.maxWeightTransform;
      maxWeightTransform.run({
        parameters: {
          blend: true,
          depthTest: false,
          blendFunc: [1, 1],
          blendEquation: 32776
        }
      });
    }
  }, {
    key: "_updateBounds",
    value: function _updateBounds() {
      var forceUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var textureSize = this.state.textureSize;
      var viewport = this.context.viewport;
      var viewportCorners = [viewport.unproject([0, 0]), viewport.unproject([viewport.width, 0]), viewport.unproject([viewport.width, viewport.height]), viewport.unproject([0, viewport.height])];
      var visibleWorldBounds = getBounds(viewportCorners);

      var visibleCommonBounds = this._worldToCommonBounds(visibleWorldBounds);

      var newState = {
        visibleWorldBounds: visibleWorldBounds,
        viewportCorners: viewportCorners
      };
      var boundsChanged = false;

      if (forceUpdate || !this.state.worldBounds || !boundsContain(this.state.worldBounds, visibleWorldBounds)) {
        var scaledCommonBounds = scaleToAspectRatio(visibleCommonBounds, textureSize * RESOLUTION, textureSize * RESOLUTION);

        var worldBounds = this._commonToWorldBounds(scaledCommonBounds);

        if (this.props.coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
          worldBounds[1] = Math.max(worldBounds[1], -85.051129);
          worldBounds[3] = Math.min(worldBounds[3], 85.051129);
          worldBounds[0] = Math.max(worldBounds[0], -360);
          worldBounds[2] = Math.min(worldBounds[2], 360);
        }

        var normalizedCommonBounds = this._worldToCommonBounds(worldBounds, {
          scaleToAspect: true,
          normalize: true,
          width: textureSize * RESOLUTION,
          height: textureSize * RESOLUTION
        });

        newState.worldBounds = worldBounds;
        newState.normalizedCommonBounds = normalizedCommonBounds;
        boundsChanged = true;
      }

      this.setState(newState);
      return boundsChanged;
    }
  }, {
    key: "_updateTextureRenderingBounds",
    value: function _updateTextureRenderingBounds() {
      var _this$state4 = this.state,
          triPositionBuffer = _this$state4.triPositionBuffer,
          triTexCoordBuffer = _this$state4.triTexCoordBuffer,
          normalizedCommonBounds = _this$state4.normalizedCommonBounds,
          viewportCorners = _this$state4.viewportCorners;
      var viewport = this.context.viewport;
      var commonBounds = normalizedCommonBounds.map(function (x) {
        return x * viewport.scale;
      });
      triPositionBuffer.subData(packVertices(viewportCorners, 3));
      var textureBounds = viewportCorners.map(function (p) {
        return getTextureCoordinates(viewport.projectPosition(p), commonBounds);
      });
      triTexCoordBuffer.subData(packVertices(textureBounds, 2));
    }
  }, {
    key: "_updateColorTexture",
    value: function _updateColorTexture(opts) {
      var colorRange = opts.props.colorRange;
      var colorTexture = this.state.colorTexture;
      var colors = colorRangeToFlatArray(colorRange, true);

      if (colorTexture) {
        colorTexture.setImageData({
          data: colors,
          width: colorRange.length
        });
      } else {
        colorTexture = new Texture2D(this.context.gl, _objectSpread({
          data: colors,
          width: colorRange.length,
          height: 1,
          format: isWebGL2(this.context.gl) ? 34836 : 6408,
          type: 5126
        }, TEXTURE_OPTIONS));
      }

      this.setState({
        colorTexture: colorTexture
      });
    }
  }, {
    key: "_updateWeightmap",
    value: function _updateWeightmap() {
      var _weightsTexture$setPa;

      var radiusPixels = this.props.radiusPixels;
      var _this$state5 = this.state,
          weightsTransform = _this$state5.weightsTransform,
          worldBounds = _this$state5.worldBounds,
          textureSize = _this$state5.textureSize,
          weightsTexture = _this$state5.weightsTexture,
          weightsScale = _this$state5.weightsScale;

      this._updateAttributes(this.props);

      var moduleParameters = Object.assign(Object.create(this.props), {
        viewport: this.context.viewport,
        pickingActive: 0
      });

      var commonBounds = this._worldToCommonBounds(worldBounds, {
        useLayerCoordinateSystem: true,
        scaleToAspect: true,
        width: textureSize * RESOLUTION,
        height: textureSize * RESOLUTION
      });

      var uniforms = Object.assign({}, weightsTransform.model.getModuleUniforms(moduleParameters), {
        radiusPixels: radiusPixels,
        commonBounds: commonBounds,
        textureWidth: textureSize,
        weightsScale: weightsScale
      });
      weightsTransform.update({
        elementCount: this.getNumInstances()
      });
      weightsTransform.run({
        uniforms: uniforms,
        parameters: {
          blend: true,
          depthTest: false,
          blendFunc: [1, 1],
          blendEquation: 32774
        },
        clearRenderTarget: true
      });

      this._updateMaxWeightValue();

      weightsTexture.setParameters((_weightsTexture$setPa = {}, _defineProperty(_weightsTexture$setPa, 10240, 9729), _defineProperty(_weightsTexture$setPa, 10241, 9729), _weightsTexture$setPa));
      this.setState({
        lastUpdate: Date.now()
      });
    }
  }, {
    key: "_debouncedUpdateWeightmap",
    value: function _debouncedUpdateWeightmap() {
      var fromTimer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var updateTimer = this.state.updateTimer;
      var timeSinceLastUpdate = Date.now() - this.state.lastUpdate;

      if (fromTimer) {
        updateTimer = null;
      }

      if (timeSinceLastUpdate >= ZOOM_DEBOUNCE) {
        this._updateBounds(true);

        this._updateWeightmap();

        this._updateTextureRenderingBounds();
      } else if (!updateTimer) {
        updateTimer = setTimeout(this._debouncedUpdateWeightmap.bind(this, true), ZOOM_DEBOUNCE - timeSinceLastUpdate);
      }

      this.setState({
        updateTimer: updateTimer
      });
    }
  }, {
    key: "_worldToCommonBounds",
    value: function _worldToCommonBounds(worldBounds) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var _opts$useLayerCoordin = opts.useLayerCoordinateSystem,
          useLayerCoordinateSystem = _opts$useLayerCoordin === void 0 ? false : _opts$useLayerCoordin,
          _opts$scaleToAspect = opts.scaleToAspect,
          scaleToAspect = _opts$scaleToAspect === void 0 ? false : _opts$scaleToAspect,
          width = opts.width,
          height = opts.height;

      var _worldBounds = _slicedToArray(worldBounds, 4),
          minLong = _worldBounds[0],
          minLat = _worldBounds[1],
          maxLong = _worldBounds[2],
          maxLat = _worldBounds[3];

      var viewport = this.context.viewport;
      var topLeftCommon;
      var bottomRightCommon;

      if (useLayerCoordinateSystem) {
        topLeftCommon = this.projectPosition([minLong, maxLat, 0]);
        bottomRightCommon = this.projectPosition([maxLong, minLat, 0]);
      } else {
        topLeftCommon = viewport.projectPosition([minLong, maxLat, 0]);
        bottomRightCommon = viewport.projectPosition([maxLong, minLat, 0]);
      }

      var commonBounds = topLeftCommon.slice(0, 2).concat(bottomRightCommon.slice(0, 2));

      if (scaleToAspect) {
        commonBounds = scaleToAspectRatio(commonBounds, width, height);
      }

      if (opts.normalize) {
        commonBounds = commonBounds.map(function (x) {
          return x / viewport.scale;
        });
      }

      return commonBounds;
    }
  }, {
    key: "_commonToWorldBounds",
    value: function _commonToWorldBounds(commonBounds) {
      var _commonBounds = _slicedToArray(commonBounds, 4),
          xMin = _commonBounds[0],
          yMin = _commonBounds[1],
          xMax = _commonBounds[2],
          yMax = _commonBounds[3];

      var viewport = this.context.viewport;
      var topLeftWorld = viewport.unprojectPosition([xMin, yMax]);
      var bottomRightWorld = viewport.unprojectPosition([xMax, yMin]);
      return topLeftWorld.slice(0, 2).concat(bottomRightWorld.slice(0, 2));
    }
  }]);

  return HeatmapLayer;
}(CompositeLayer);

export { HeatmapLayer as default };
HeatmapLayer.layerName = 'HeatmapLayer';
HeatmapLayer.defaultProps = defaultProps;
//# sourceMappingURL=heatmap-layer.js.map