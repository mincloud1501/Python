{"version":3,"sources":["../../../../src/utils/gpu-grid-aggregation/gpu-grid-aggregator.js"],"names":["Buffer","Model","Transform","FEATURES","hasFeatures","isWebGL2","readPixelsToBuffer","fp64","fp64ShaderModule","withParameters","log","project64","worldToPixels","fp64ifyMatrix4","DEFAULT_CHANGE_FLAGS","DEFAULT_RUN_PARAMS","MAX_32_BIT_FLOAT","MIN_BLEND_EQUATION","MAX_BLEND_EQUATION","MAX_MIN_BLEND_EQUATION","EQUATION_MAP","ELEMENTCOUNT","DEFAULT_WEIGHT_PARAMS","IDENTITY_MATRIX","PIXEL_SIZE","WEIGHT_SIZE","AGGREGATION_OPERATION","AGGREGATE_TO_GRID_VS","AGGREGATE_TO_GRID_VS_FP64","AGGREGATE_TO_GRID_FS","AGGREGATE_ALL_VS_FP64","AGGREGATE_ALL_FS","TRANSFORM_MEAN_VS","getFloatTexture","getFramebuffer","getFloatArray","BUFFER_NAMES","ARRAY_BUFFER_MAP","maxData","minData","maxMinData","REQUIRED_FEATURES","WEBGL2","COLOR_ATTACHMENT_RGBA32F","BLEND_EQUATION_MINMAX","FLOAT_BLEND","TEXTURE_FLOAT","GPUGridAggregator","getAggregationData","aggregationData","pixelIndex","index","results","cellCount","cellWeight","maxCellWieght","minCellWeight","totalCount","getCellData","countsData","size","numCells","length","cellWeights","Float32Array","cellCounts","Uint32Array","i","sizeIndex","isSupported","gl","constructor","opts","id","state","weights","gridPositions","positionsBuffer","positions64xyLowBuffer","vertexCount","useGPU","numCol","numRow","windowSize","cellSize","weightAttributes","textures","meanTextures","buffers","framebuffers","maxMinFramebuffers","minFramebuffers","maxFramebuffers","equations","resources","_hasGPUSupport","delete","gridAggregationModel","allAggregationModel","meanTransform","deleteResources","run","setState","aggregationParams","getAggregationParams","updateGridSize","runAggregationOnGPU","warn","runAggregationOnCPU","getData","weightId","data","aggregationBuffer","arrayName","bufferName","Array","isArray","forEach","obj","name","Object","assign","gridTransformMatrix","viewport","projectPoints","changeFlags","cellSizeChanged","validateProps","viewportMatrix","normalizeWeightParams","result","updateObject","shouldTransformToGrid","dataChanged","viewportChanged","width","height","Math","ceil","assert","positions","projectPositions","calculateAggregationData","cellIndex","posIndex","values","operation","cellElementIndex","weightComponent","SUM","MEAN","MIN","min","MAX","max","calculateMeanMaxMinData","validCellIndices","needMin","needMax","calculateMinMax","calculateMean","combineMaxMin","count","weight","initCPUResults","aggregationSize","fill","Infinity","gridTransformRequired","pos","posCount","Float64Array","Set","x","y","project","colId","floor","rowId","add","updateAggregationBuffers","_uploadResultsToGPU","textureName","resourceName","setData","texture","_getMinMaxTexture","setImageData","createBufferObjects","getAggregateData","aggregationTexture","target","sourceType","maxMinBuffer","maxMinTexture","minBuffer","minTexture","maxBuffer","maxTexture","trackGPUResultBuffers","getAggregationModel","vs","fs","modules","drawMode","getAllAggregationModel","isInstanced","instanceCount","attributes","position","getMeanTransform","update","_targetTextureVarying","renderAggregateData","uProjectionMatrixFP64","gridSize","parameters","blend","depthTest","blendFunc","moduleSettings","uniforms","uProjectionMatrix","renderToWeightsTexture","renderToMaxMinTexture","blendEquation","minOrMaxFb","clearParams","clearColor","bind","clear","draw","uSampler","unbind","transformOptions","_sourceTextures","aggregationValues","_targetTexture","elementCount","attach","updateModels","setupFramebuffers","framebufferSize","resize","setupModels","setupWeightAttributes","typedArray","positions64xyLow","aggregationModelAttributes","modelDirty","accessor","setVertexCount","setAttributes","setInstanceCount"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {\n  Buffer,\n  Model,\n  Transform,\n  FEATURES,\n  hasFeatures,\n  isWebGL2,\n  readPixelsToBuffer,\n  fp64 as fp64ShaderModule,\n  withParameters\n} from '@luma.gl/core';\nimport {log, project64} from '@deck.gl/core';\nimport {worldToPixels} from 'viewport-mercator-project';\nconst {fp64ifyMatrix4} = fp64ShaderModule;\n\nimport {\n  DEFAULT_CHANGE_FLAGS,\n  DEFAULT_RUN_PARAMS,\n  MAX_32_BIT_FLOAT,\n  MIN_BLEND_EQUATION,\n  MAX_BLEND_EQUATION,\n  MAX_MIN_BLEND_EQUATION,\n  EQUATION_MAP,\n  ELEMENTCOUNT,\n  DEFAULT_WEIGHT_PARAMS,\n  IDENTITY_MATRIX,\n  PIXEL_SIZE,\n  WEIGHT_SIZE\n} from './gpu-grid-aggregator-constants';\nimport {AGGREGATION_OPERATION} from '../aggregation-operation-utils';\n\nimport AGGREGATE_TO_GRID_VS from './aggregate-to-grid-vs.glsl';\nimport AGGREGATE_TO_GRID_VS_FP64 from './aggregate-to-grid-vs-64.glsl';\nimport AGGREGATE_TO_GRID_FS from './aggregate-to-grid-fs.glsl';\nimport AGGREGATE_ALL_VS_FP64 from './aggregate-all-vs-64.glsl';\nimport AGGREGATE_ALL_FS from './aggregate-all-fs.glsl';\nimport TRANSFORM_MEAN_VS from './transform-mean-vs.glsl';\nimport {getFloatTexture, getFramebuffer, getFloatArray} from './../resource-utils.js';\n\nconst BUFFER_NAMES = ['aggregationBuffer', 'maxMinBuffer', 'minBuffer', 'maxBuffer'];\nconst ARRAY_BUFFER_MAP = {\n  maxData: 'maxBuffer',\n  minData: 'minBuffer',\n  maxMinData: 'maxMinBuffer'\n};\n\nconst REQUIRED_FEATURES = [\n  FEATURES.WEBGL2, // TODO: Remove after trannsform refactor\n  FEATURES.COLOR_ATTACHMENT_RGBA32F,\n  FEATURES.BLEND_EQUATION_MINMAX,\n  FEATURES.FLOAT_BLEND,\n  FEATURES.TEXTURE_FLOAT\n];\n\nexport default class GPUGridAggregator {\n  // Decode and return aggregation data of given pixel.\n  static getAggregationData({aggregationData, maxData, minData, maxMinData, pixelIndex}) {\n    const index = pixelIndex * PIXEL_SIZE;\n    const results = {};\n    if (aggregationData) {\n      results.cellCount = aggregationData[index + 3];\n      results.cellWeight = aggregationData[index];\n    }\n    if (maxMinData) {\n      results.maxCellWieght = maxMinData[0];\n      results.minCellWeight = maxMinData[3];\n    } else {\n      if (maxData) {\n        results.maxCellWieght = maxData[0];\n        results.totalCount = maxData[3];\n      }\n      if (minData) {\n        results.minCellWeight = minData[0];\n        results.totalCount = maxData[3];\n      }\n    }\n    return results;\n  }\n\n  // Decodes and retuns counts and weights of all cells\n  static getCellData({countsData, size = 1}) {\n    const numCells = countsData.length / 4;\n    const cellWeights = new Float32Array(numCells * size);\n    const cellCounts = new Uint32Array(numCells);\n    for (let i = 0; i < numCells; i++) {\n      // weights in RGB channels\n      for (let sizeIndex = 0; sizeIndex < size; sizeIndex++) {\n        cellWeights[i * size + sizeIndex] = countsData[i * 4 + sizeIndex];\n      }\n      // count in Alpha channel\n      cellCounts[i] = countsData[i * 4 + 3];\n    }\n    return {cellCounts, cellWeights};\n  }\n\n  static isSupported(gl) {\n    return hasFeatures(gl, REQUIRED_FEATURES);\n  }\n\n  // DEBUG ONLY\n  // static logData({aggregationBuffer, minBuffer, maxBuffer, maxMinBuffer, limit = 10}) {\n  //   if (aggregationBuffer) {\n  //     console.log('Aggregation Data:');\n  //     const agrData = aggregationBuffer.getData();\n  //     for (let index = 0; index < agrData.length && limit > 0; index += 4) {\n  //       if (agrData[index + 3] > 0) {\n  //         console.log(\n  //           `index: ${index} weights: ${agrData[index]} ${agrData[index + 1]} ${\n  //             agrData[index + 2]\n  //           } count: ${agrData[index + 3]}`\n  //         );\n  //         limit--;\n  //       }\n  //     }\n  //   }\n  //   const obj = {minBuffer, maxBuffer, maxMinBuffer};\n  //   for (const key in obj) {\n  //     if (obj[key]) {\n  //       const data = obj[key].getData();\n  //       console.log(`${key} data : R: ${data[0]} G: ${data[1]} B: ${data[2]} A: ${data[3]}`);\n  //     }\n  //   }\n  // }\n\n  constructor(gl, opts = {}) {\n    this.id = opts.id || 'gpu-grid-aggregator';\n    this.gl = gl;\n    this.state = {\n      // cache weights and position data to process when data is not changed\n      weights: null,\n      gridPositions: null,\n      positionsBuffer: null,\n      positions64xyLowBuffer: null,\n      vertexCount: 0,\n\n      // flags/variables that affect the aggregation\n      fp64: null,\n      useGPU: null,\n      numCol: 0,\n      numRow: 0,\n      windowSize: null,\n      cellSize: null,\n\n      // per weight GPU resources\n      weightAttributes: {},\n      textures: {},\n      meanTextures: {},\n      buffers: {},\n      framebuffers: {},\n      maxMinFramebuffers: {},\n      minFramebuffers: {},\n      maxFramebuffers: {},\n      equations: {},\n\n      // common resources to be deleted\n      resources: {},\n\n      // results\n      results: {}\n    };\n    this._hasGPUSupport =\n      isWebGL2(gl) && // gl_InstanceID usage in min/max calculation shaders\n      hasFeatures(\n        this.gl,\n        FEATURES.BLEND_EQUATION_MINMAX, // set min/max blend modes\n        FEATURES.COLOR_ATTACHMENT_RGBA32F, // render to float texture\n        FEATURES.TEXTURE_FLOAT // sample from a float texture\n      );\n  }\n\n  // Delete owned resources.\n  /* eslint no-unused-expressions: [\"error\", { \"allowShortCircuit\": true }] */\n  delete() {\n    const {gridAggregationModel, allAggregationModel, meanTransform} = this;\n    const {\n      positionsBuffer,\n      positions64xyLowBuffer,\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      resources\n    } = this.state;\n\n    gridAggregationModel && gridAggregationModel.delete();\n    allAggregationModel && allAggregationModel.delete();\n    meanTransform && meanTransform.delete();\n\n    positionsBuffer && positionsBuffer.delete();\n    positions64xyLowBuffer && positions64xyLowBuffer.delete();\n    this.deleteResources([\n      framebuffers,\n      textures,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      resources\n    ]);\n  }\n\n  // Perform aggregation and retun the results\n  run(opts = {}) {\n    // reset results\n    this.setState({results: {}});\n    const aggregationParams = this.getAggregationParams(opts);\n    this.updateGridSize(aggregationParams);\n    const {useGPU} = aggregationParams;\n    if (this._hasGPUSupport && useGPU) {\n      return this.runAggregationOnGPU(aggregationParams);\n    }\n    if (useGPU) {\n      log.warn('GPUGridAggregator: GPU Aggregation not supported, falling back to CPU')();\n    }\n    return this.runAggregationOnCPU(aggregationParams);\n  }\n\n  // Reads aggregation data into JS Array object\n  // For WebGL1, data is available in JS Array objects already.\n  // For WebGL2, data is read from Buffer objects and cached for subsequent queries.\n  getData(weightId) {\n    const data = {};\n    const results = this.state.results;\n    if (!results[weightId].aggregationData) {\n      // cache the results if reading from the buffer (WebGL2 path)\n      results[weightId].aggregationData = results[weightId].aggregationBuffer.getData();\n    }\n    data.aggregationData = results[weightId].aggregationData;\n\n    // Check for optional results\n    for (const arrayName in ARRAY_BUFFER_MAP) {\n      const bufferName = ARRAY_BUFFER_MAP[arrayName];\n\n      if (results[weightId][arrayName] || results[weightId][bufferName]) {\n        // cache the result\n        results[weightId][arrayName] =\n          results[weightId][arrayName] || results[weightId][bufferName].getData();\n        data[arrayName] = results[weightId][arrayName];\n      }\n    }\n    return data;\n  }\n\n  // PRIVATE\n\n  deleteResources(resources) {\n    resources = Array.isArray(resources) ? resources : [resources];\n    resources.forEach(obj => {\n      for (const name in obj) {\n        obj[name].delete();\n      }\n    });\n  }\n\n  getAggregationParams(opts) {\n    const aggregationParams = Object.assign({}, DEFAULT_RUN_PARAMS, opts);\n    const {\n      useGPU,\n      gridTransformMatrix,\n      viewport,\n      weights,\n      projectPoints,\n      cellSize\n    } = aggregationParams;\n    if (this.state.useGPU !== useGPU) {\n      // CPU/GPU resources need to reinitialized, force set the change flags.\n      aggregationParams.changeFlags = Object.assign(\n        {},\n        aggregationParams.changeFlags,\n        DEFAULT_CHANGE_FLAGS\n      );\n    }\n    if (\n      cellSize &&\n      (!this.state.cellSize ||\n        this.state.cellSize[0] !== cellSize[0] ||\n        this.state.cellSize[1] !== cellSize[1])\n    ) {\n      aggregationParams.changeFlags.cellSizeChanged = true;\n      // For GridLayer aggregation, cellSize is calculated by parsing all input data as it depends\n      // on bounding box, cache cellSize\n      this.setState({cellSize});\n    }\n\n    this.validateProps(aggregationParams, opts);\n\n    this.setState({useGPU});\n    aggregationParams.gridTransformMatrix =\n      (projectPoints ? viewport.viewportMatrix : gridTransformMatrix) || IDENTITY_MATRIX;\n\n    if (weights) {\n      aggregationParams.weights = this.normalizeWeightParams(weights);\n\n      // cache weights to process when only cellSize or viewport is changed.\n      // position data is cached in Buffers for GPU case and in 'gridPositions' for CPU case.\n      this.setState({weights: aggregationParams.weights});\n    }\n    return aggregationParams;\n  }\n\n  normalizeWeightParams(weights) {\n    const result = {};\n    for (const id in weights) {\n      result[id] = Object.assign({}, DEFAULT_WEIGHT_PARAMS, weights[id]);\n    }\n    return result;\n  }\n\n  // Update priveate state\n  setState(updateObject) {\n    Object.assign(this.state, updateObject);\n  }\n\n  shouldTransformToGrid(opts) {\n    const {projectPoints, changeFlags} = opts;\n    if (\n      !this.state.gridPositions ||\n      changeFlags.dataChanged ||\n      (projectPoints && changeFlags.viewportChanged) // world space aggregation (GridLayer) doesn't change when viewport is changed.\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  updateGridSize(opts) {\n    const {viewport, cellSize} = opts;\n    const width = opts.width || viewport.width;\n    const height = opts.height || viewport.height;\n    const numCol = Math.ceil(width / cellSize[0]);\n    const numRow = Math.ceil(height / cellSize[1]);\n    this.setState({numCol, numRow, windowSize: [width, height]});\n  }\n\n  /* eslint-disable complexity */\n  // validate and log.assert\n  validateProps(aggregationParams, opts) {\n    const {changeFlags, projectPoints, gridTransformMatrix} = aggregationParams;\n    log.assert(\n      changeFlags.dataChanged || changeFlags.viewportChanged || changeFlags.cellSizeChanged\n    );\n\n    // log.assert for required options\n    log.assert(\n      !changeFlags.dataChanged ||\n        (opts.positions &&\n          opts.weights &&\n          (!opts.projectPositions || opts.viewport) &&\n          opts.cellSize)\n    );\n    log.assert(!changeFlags.cellSizeChanged || opts.cellSize);\n\n    // viewport is needed only when performing screen space aggregation (projectPoints is true)\n    log.assert(!(changeFlags.viewportChanged && projectPoints) || opts.viewport);\n\n    if (projectPoints && gridTransformMatrix) {\n      log.warn('projectPoints is true, gridTransformMatrix is ignored')();\n    }\n  }\n  /* eslint-enable complexity */\n\n  // CPU Aggregation methods\n\n  // aggregated weight value to a cell\n  /* eslint-disable max-depth */\n  calculateAggregationData(opts) {\n    const {weights, results, cellIndex, posIndex} = opts;\n    for (const id in weights) {\n      const {values, size, operation} = weights[id];\n      const {aggregationData} = results[id];\n\n      // Fill RGB with weights\n      for (let sizeIndex = 0; sizeIndex < size; sizeIndex++) {\n        const cellElementIndex = cellIndex + sizeIndex;\n        const weightComponent = values[posIndex * WEIGHT_SIZE + sizeIndex];\n\n        if (aggregationData[cellIndex + 3] === 0) {\n          // if the cell is getting update the first time, set the value directly.\n          aggregationData[cellElementIndex] = weightComponent;\n        } else {\n          switch (operation) {\n            case AGGREGATION_OPERATION.SUM:\n            case AGGREGATION_OPERATION.MEAN:\n              aggregationData[cellElementIndex] += weightComponent;\n              // MEAN value is calculated during 'calculateMeanMaxMinData'\n              break;\n            case AGGREGATION_OPERATION.MIN:\n              aggregationData[cellElementIndex] = Math.min(\n                aggregationData[cellElementIndex],\n                weightComponent\n              );\n              break;\n            case AGGREGATION_OPERATION.MAX:\n              aggregationData[cellElementIndex] = Math.max(\n                aggregationData[cellElementIndex],\n                weightComponent\n              );\n              break;\n            default:\n              // Not a valid operation enum.\n              log.assert(false);\n              break;\n          }\n        }\n      }\n\n      // Track the count per grid-cell\n      aggregationData[cellIndex + 3]++;\n    }\n  }\n\n  /* eslint-disable max-depth, complexity */\n  calculateMeanMaxMinData(opts) {\n    const {validCellIndices, results, weights} = opts;\n\n    // collect max/min values\n    validCellIndices.forEach(cellIndex => {\n      for (const id in results) {\n        const {size, needMin, needMax, operation} = weights[id];\n        const {aggregationData, minData, maxData, maxMinData} = results[id];\n        const calculateMinMax = needMin || needMax;\n        const calculateMean = operation === AGGREGATION_OPERATION.MEAN;\n        const combineMaxMin = needMin && needMax && weights[id].combineMaxMin;\n        const count = aggregationData[cellIndex + ELEMENTCOUNT - 1];\n        for (\n          let sizeIndex = 0;\n          sizeIndex < size && (calculateMinMax || calculateMean);\n          sizeIndex++\n        ) {\n          const cellElementIndex = cellIndex + sizeIndex;\n          let weight = aggregationData[cellElementIndex];\n          if (calculateMean) {\n            aggregationData[cellElementIndex] /= count;\n            weight = aggregationData[cellElementIndex];\n          }\n          if (combineMaxMin) {\n            // use RGB for max values for 3 weights.\n            maxMinData[sizeIndex] = Math.max(maxMinData[sizeIndex], weight);\n          } else {\n            if (needMin) {\n              minData[sizeIndex] = Math.min(minData[sizeIndex], weight);\n            }\n            if (needMax) {\n              maxData[sizeIndex] = Math.max(maxData[sizeIndex], weight);\n            }\n          }\n        }\n        // update total aggregation values.\n        if (combineMaxMin) {\n          // Use Alpha channel to store total min value for weight#0\n          maxMinData[ELEMENTCOUNT - 1] = Math.min(\n            maxMinData[ELEMENTCOUNT - 1],\n            aggregationData[cellIndex + 0]\n          );\n        } else {\n          // Use Alpha channel to store total counts.\n          if (needMin) {\n            minData[ELEMENTCOUNT - 1] += count;\n          }\n          if (needMax) {\n            maxData[ELEMENTCOUNT - 1] += count;\n          }\n        }\n      }\n    });\n  }\n  /* eslint-enable max-depth */\n\n  initCPUResults(opts) {\n    const weights = opts.weights || this.state.weights;\n    const {numCol, numRow} = this.state;\n    const results = {};\n    // setup results object\n    for (const id in weights) {\n      let {aggregationData, minData, maxData, maxMinData} = weights[id];\n      const {needMin, needMax} = weights[id];\n      const combineMaxMin = needMin && needMax && weights[id].combineMaxMin;\n\n      const aggregationSize = numCol * numRow * ELEMENTCOUNT;\n      aggregationData = getFloatArray(aggregationData, aggregationSize);\n      if (combineMaxMin) {\n        maxMinData = getFloatArray(maxMinData, ELEMENTCOUNT);\n        // RGB for max value\n        maxMinData.fill(-Infinity, 0, ELEMENTCOUNT - 1);\n        // Alpha for min value\n        maxMinData[ELEMENTCOUNT - 1] = Infinity;\n      } else {\n        // RGB for min/max values\n        // Alpha for total count\n        if (needMin) {\n          minData = getFloatArray(minData, ELEMENTCOUNT, Infinity);\n          minData[ELEMENTCOUNT - 1] = 0;\n        }\n        if (needMax) {\n          maxData = getFloatArray(maxData, ELEMENTCOUNT, -Infinity);\n          maxData[ELEMENTCOUNT - 1] = 0;\n        }\n      }\n      results[id] = Object.assign({}, weights[id], {\n        aggregationData,\n        minData,\n        maxData,\n        maxMinData\n      });\n    }\n    return results;\n  }\n\n  /* eslint-disable max-statements */\n  runAggregationOnCPU(opts) {\n    const {positions, cellSize, gridTransformMatrix, viewport, projectPoints} = opts;\n    let {weights} = opts;\n    const {numCol, numRow} = this.state;\n    const results = this.initCPUResults(opts);\n    // screen space or world space projection required\n    const gridTransformRequired = this.shouldTransformToGrid(opts);\n    let gridPositions;\n    const pos = [0, 0, 0];\n\n    log.assert(gridTransformRequired || opts.changeFlags.cellSizeChanged);\n\n    let posCount;\n    if (gridTransformRequired) {\n      posCount = positions.length / 2;\n      gridPositions = new Float64Array(positions.length);\n      this.setState({gridPositions});\n    } else {\n      gridPositions = this.state.gridPositions;\n      weights = this.state.weights;\n      posCount = gridPositions.length / 2;\n    }\n\n    const validCellIndices = new Set();\n    for (let posIndex = 0; posIndex < posCount; posIndex++) {\n      let x;\n      let y;\n      if (gridTransformRequired) {\n        pos[0] = positions[posIndex * 2];\n        pos[1] = positions[posIndex * 2 + 1];\n        if (projectPoints) {\n          [x, y] = viewport.project(pos);\n        } else {\n          [x, y] = worldToPixels(pos, gridTransformMatrix);\n        }\n        gridPositions[posIndex * 2] = x;\n        gridPositions[posIndex * 2 + 1] = y;\n      } else {\n        x = gridPositions[posIndex * 2];\n        y = gridPositions[posIndex * 2 + 1];\n      }\n\n      const colId = Math.floor(x / cellSize[0]);\n      const rowId = Math.floor(y / cellSize[1]);\n      if (colId >= 0 && colId < numCol && rowId >= 0 && rowId < numRow) {\n        const cellIndex = (colId + rowId * numCol) * ELEMENTCOUNT;\n        validCellIndices.add(cellIndex);\n        this.calculateAggregationData({weights, results, cellIndex, posIndex});\n      }\n    }\n\n    this.calculateMeanMaxMinData({validCellIndices, results, weights});\n\n    // Update buffer objects.\n    this.updateAggregationBuffers(opts, results);\n\n    this.setState({results});\n    return results;\n  }\n  /* eslint-disable max-statements */\n\n  _uploadResultsToGPU({gl, bufferName, textureName, id, data, result}) {\n    const {resources} = this.state;\n    const resourceName = `cpu-result-${id}-${bufferName}`;\n    result[bufferName] = result[bufferName] || resources[resourceName];\n    if (result[bufferName]) {\n      result[bufferName].setData({data});\n    } else {\n      // save resource for garbage collection\n      resources[resourceName] = new Buffer(gl, data);\n      result[bufferName] = resources[resourceName];\n    }\n\n    // Upload result to a texture\n    if (textureName) {\n      const texture = this._getMinMaxTexture(`${id}-textureName`);\n      texture.setImageData({data});\n      result[textureName] = texture;\n    }\n  }\n\n  updateAggregationBuffers(opts, results) {\n    if (!opts.createBufferObjects) {\n      return;\n    }\n    const weights = opts.weights || this.state.weights;\n    for (const id in results) {\n      const {aggregationData, minData, maxData, maxMinData} = results[id];\n      const {needMin, needMax} = weights[id];\n      const combineMaxMin = needMin && needMax && weights[id].combineMaxMin;\n      this._uploadResultsToGPU({\n        gl: this.gl,\n        bufferName: 'aggregationBuffer',\n        id,\n        data: aggregationData,\n        result: results[id]\n      });\n      if (combineMaxMin) {\n        this._uploadResultsToGPU({\n          gl: this.gl,\n          bufferName: 'maxMinBuffer',\n          textureName: 'maxMinTexture',\n          id,\n          data: maxMinData,\n          result: results[id]\n        });\n      } else {\n        if (needMin) {\n          this._uploadResultsToGPU({\n            gl: this.gl,\n            bufferName: 'minBuffer',\n            textureName: 'minTexture',\n            id,\n            data: minData,\n            result: results[id]\n          });\n        }\n        if (needMax) {\n          this._uploadResultsToGPU({\n            gl: this.gl,\n            bufferName: 'maxBuffer',\n            textureName: 'maxTexture',\n            id,\n            data: maxData,\n            result: results[id]\n          });\n        }\n      }\n    }\n  }\n\n  // GPU Aggregation methods\n\n  getAggregateData(opts) {\n    const results = {};\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      weights,\n      resources\n    } = this.state;\n\n    for (const id in weights) {\n      results[id] = {};\n      const {needMin, needMax, combineMaxMin} = weights[id];\n      results[id].aggregationTexture = textures[id];\n      results[id].aggregationBuffer = readPixelsToBuffer(framebuffers[id], {\n        target: weights[id].aggregationBuffer, // update if a buffer is provided\n        sourceType: GL.FLOAT\n      });\n      if (needMin && needMax && combineMaxMin) {\n        results[id].maxMinBuffer = readPixelsToBuffer(maxMinFramebuffers[id], {\n          target: weights[id].maxMinBuffer, // update if a buffer is provided\n          sourceType: GL.FLOAT\n        });\n        results[id].maxMinTexture = resources[`${id}-maxMinTexture`];\n      } else {\n        if (needMin) {\n          results[id].minBuffer = readPixelsToBuffer(minFramebuffers[id], {\n            target: weights[id].minBuffer, // update if a buffer is provided\n            sourceType: GL.FLOAT\n          });\n          results[id].minTexture = resources[`${id}-minTexture`];\n        }\n        if (needMax) {\n          results[id].maxBuffer = readPixelsToBuffer(maxFramebuffers[id], {\n            target: weights[id].maxBuffer, // update if a buffer is provided\n            sourceType: GL.FLOAT\n          });\n          results[id].maxTexture = resources[`${id}-maxTexture`];\n        }\n      }\n    }\n    this.trackGPUResultBuffers(results, weights);\n    return results;\n  }\n\n  getAggregationModel(fp64 = false) {\n    const {gl} = this;\n    return new Model(gl, {\n      id: 'Gird-Aggregation-Model',\n      vs: fp64 ? AGGREGATE_TO_GRID_VS_FP64 : AGGREGATE_TO_GRID_VS,\n      fs: AGGREGATE_TO_GRID_FS,\n      modules: fp64 ? [project64] : ['project32'],\n      vertexCount: 0,\n      drawMode: GL.POINTS\n    });\n  }\n\n  getAllAggregationModel() {\n    const {gl} = this;\n    const {numCol, numRow} = this.state;\n    return new Model(gl, {\n      id: 'All-Aggregation-Model',\n      vs: AGGREGATE_ALL_VS_FP64,\n      fs: AGGREGATE_ALL_FS,\n      modules: [fp64ShaderModule],\n      vertexCount: 1,\n      drawMode: GL.POINTS,\n      isInstanced: true,\n      instanceCount: numCol * numRow,\n      attributes: {\n        position: [0, 0]\n      }\n    });\n  }\n\n  getMeanTransform(opts) {\n    if (this.meanTransform) {\n      this.meanTransform.update(opts);\n    } else {\n      this.meanTransform = new Transform(\n        this.gl,\n        Object.assign(\n          {},\n          {\n            vs: TRANSFORM_MEAN_VS,\n            _targetTextureVarying: 'meanValues'\n          },\n          opts\n        )\n      );\n    }\n    return this.meanTransform;\n  }\n\n  renderAggregateData(opts) {\n    const {cellSize, viewport, gridTransformMatrix, projectPoints} = opts;\n    const {\n      numCol,\n      numRow,\n      windowSize,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      weights\n    } = this.state;\n\n    const uProjectionMatrixFP64 = fp64ifyMatrix4(gridTransformMatrix);\n    const gridSize = [numCol, numRow];\n    const parameters = {\n      blend: true,\n      depthTest: false,\n      blendFunc: [GL.ONE, GL.ONE]\n    };\n    const moduleSettings = {viewport};\n    const uniforms = {\n      windowSize,\n      cellSize,\n      gridSize,\n      uProjectionMatrix: gridTransformMatrix,\n      uProjectionMatrixFP64,\n      projectPoints\n    };\n\n    for (const id in weights) {\n      const {needMin, needMax} = weights[id];\n      const combineMaxMin = needMin && needMax && weights[id].combineMaxMin;\n      this.renderToWeightsTexture({id, parameters, moduleSettings, uniforms, gridSize});\n      if (combineMaxMin) {\n        this.renderToMaxMinTexture({\n          id,\n          parameters: Object.assign({}, parameters, {blendEquation: MAX_MIN_BLEND_EQUATION}),\n          gridSize,\n          minOrMaxFb: maxMinFramebuffers[id],\n          clearParams: {clearColor: [0, 0, 0, MAX_32_BIT_FLOAT]},\n          combineMaxMin\n        });\n      } else {\n        if (needMin) {\n          this.renderToMaxMinTexture({\n            id,\n            parameters: Object.assign({}, parameters, {blendEquation: MIN_BLEND_EQUATION}),\n            gridSize,\n            minOrMaxFb: minFramebuffers[id],\n            clearParams: {clearColor: [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]},\n            combineMaxMin\n          });\n        }\n        if (needMax) {\n          this.renderToMaxMinTexture({\n            id,\n            parameters: Object.assign({}, parameters, {blendEquation: MAX_BLEND_EQUATION}),\n            gridSize,\n            minOrMaxFb: maxFramebuffers[id],\n            combineMaxMin\n          });\n        }\n      }\n    }\n  }\n\n  // render all aggregated grid-cells to generate Min, Max or MaxMin data texture\n  renderToMaxMinTexture(opts) {\n    const {id, parameters, gridSize, minOrMaxFb, combineMaxMin, clearParams = {}} = opts;\n    const {framebuffers} = this.state;\n    const {gl, allAggregationModel} = this;\n\n    minOrMaxFb.bind();\n    gl.viewport(0, 0, gridSize[0], gridSize[1]);\n    withParameters(gl, clearParams, () => {\n      gl.clear(gl.COLOR_BUFFER_BIT);\n    });\n    allAggregationModel.draw({\n      parameters,\n      uniforms: {\n        uSampler: framebuffers[id].texture,\n        gridSize,\n        combineMaxMin\n      }\n    });\n    minOrMaxFb.unbind();\n  }\n\n  // render all data points to aggregate weights\n  renderToWeightsTexture(opts) {\n    const {id, parameters, moduleSettings, uniforms, gridSize} = opts;\n    const {framebuffers, equations, weightAttributes, weights} = this.state;\n    const {gl, gridAggregationModel} = this;\n    const {operation} = weights[id];\n\n    framebuffers[id].bind();\n    gl.viewport(0, 0, gridSize[0], gridSize[1]);\n    const clearColor =\n      operation === AGGREGATION_OPERATION.MIN\n        ? [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]\n        : [0, 0, 0, 0];\n    withParameters(gl, {clearColor}, () => {\n      gl.clear(gl.COLOR_BUFFER_BIT);\n    });\n\n    const attributes = {weights: weightAttributes[id]};\n    gridAggregationModel.draw({\n      parameters: Object.assign({}, parameters, {blendEquation: equations[id]}),\n      moduleSettings,\n      uniforms,\n      attributes\n    });\n    framebuffers[id].unbind();\n\n    if (operation === AGGREGATION_OPERATION.MEAN) {\n      const {meanTextures, textures} = this.state;\n      const transformOptions = {\n        _sourceTextures: {aggregationValues: meanTextures[id]}, // contains aggregated data\n        _targetTexture: textures[id], // store mean values,\n        elementCount: textures[id].width * textures[id].height\n      };\n      const meanTransform = this.getMeanTransform(transformOptions);\n      meanTransform.run({\n        parameters: {\n          blend: false,\n          depthTest: false\n        }\n      });\n\n      // update framebuffer with mean results so readPixelsToBuffer returns mean values\n      framebuffers[id].attach({[GL.COLOR_ATTACHMENT0]: textures[id]});\n    }\n  }\n\n  runAggregationOnGPU(opts) {\n    this.updateModels(opts);\n    this.setupFramebuffers(opts);\n    this.renderAggregateData(opts);\n    const results = this.getAggregateData(opts);\n    this.setState({results});\n    return results;\n  }\n\n  // set up framebuffer for each weight\n  /* eslint-disable complexity, max-depth */\n  setupFramebuffers(opts) {\n    const {\n      numCol,\n      numRow,\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      equations,\n      weights\n    } = this.state;\n    const framebufferSize = {width: numCol, height: numRow};\n    for (const id in weights) {\n      const {needMin, needMax, combineMaxMin, operation} = weights[id];\n      textures[id] =\n        weights[id].aggregationTexture ||\n        textures[id] ||\n        getFloatTexture(this.gl, {id: `${id}-texture`, width: numCol, height: numRow});\n      textures[id].resize(framebufferSize);\n      let texture = textures[id];\n      if (operation === AGGREGATION_OPERATION.MEAN) {\n        // For MEAN, we first aggregatet into a temp texture\n        meanTextures[id] =\n          meanTextures[id] ||\n          getFloatTexture(this.gl, {id: `${id}-mean-texture`, width: numCol, height: numRow});\n        meanTextures[id].resize(framebufferSize);\n        texture = meanTextures[id];\n      }\n      if (framebuffers[id]) {\n        framebuffers[id].attach({[GL.COLOR_ATTACHMENT0]: texture});\n      } else {\n        framebuffers[id] = getFramebuffer(this.gl, {\n          id: `${id}-fb`,\n          width: numCol,\n          height: numRow,\n          texture\n        });\n      }\n      framebuffers[id].resize(framebufferSize);\n      equations[id] = EQUATION_MAP[operation];\n      // For min/max framebuffers will use default size 1X1\n      if (needMin || needMax) {\n        if (needMin && needMax && combineMaxMin) {\n          if (!maxMinFramebuffers[id]) {\n            texture = this._getMinMaxTexture(`${id}-maxMinTexture`);\n            maxMinFramebuffers[id] = getFramebuffer(this.gl, {id: `${id}-maxMinFb`, texture});\n          }\n        } else {\n          if (needMin) {\n            if (!minFramebuffers[id]) {\n              texture = this._getMinMaxTexture(`${id}-minTexture`);\n              minFramebuffers[id] = getFramebuffer(this.gl, {\n                id: `${id}-minFb`,\n                texture\n              });\n            }\n          }\n          if (needMax) {\n            if (!maxFramebuffers[id]) {\n              texture = this._getMinMaxTexture(`${id}-maxTexture`);\n              maxFramebuffers[id] = getFramebuffer(this.gl, {\n                id: `${id}-maxFb`,\n                texture\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n  /* eslint-enable complexity, max-depth */\n\n  _getMinMaxTexture(name) {\n    const {resources} = this.state;\n    if (!resources[name]) {\n      resources[name] = getFloatTexture(this.gl, {id: `resourceName`});\n    }\n    return resources[name];\n  }\n\n  setupModels(fp64 = false) {\n    if (this.gridAggregationModel) {\n      this.gridAggregationModel.delete();\n    }\n    this.gridAggregationModel = this.getAggregationModel(fp64);\n    if (!this.allAggregationModel) {\n      // Model doesn't have to change when fp64 flag changes\n      this.allAggregationModel = this.getAllAggregationModel();\n    }\n  }\n\n  // set up buffers for all weights\n  setupWeightAttributes(opts) {\n    const {weightAttributes, vertexCount, weights, resources} = this.state;\n    for (const id in weights) {\n      const {values} = weights[id];\n      // values can be Array, Float32Array or Buffer\n      if (Array.isArray(values) || values.constructor === Float32Array) {\n        log.assert(values.length / 3 === vertexCount);\n        const typedArray = Array.isArray(values) ? new Float32Array(values) : values;\n        if (weightAttributes[id] instanceof Buffer) {\n          weightAttributes[id].setData(typedArray);\n        } else {\n          resources[`${id}-buffer`] = new Buffer(this.gl, typedArray);\n          weightAttributes[id] = resources[`${id}-buffer`];\n        }\n      } else {\n        // log.assert((values instanceof Attribute) || (values instanceof Buffer));\n        log.assert(values instanceof Buffer);\n        weightAttributes[id] = values;\n      }\n    }\n  }\n\n  // GPU Aggregation results are provided in Buffers, if new Buffer objects are created track them for later deletion.\n  /* eslint-disable max-depth */\n  trackGPUResultBuffers(results, weights) {\n    const {resources} = this.state;\n    for (const id in results) {\n      if (results[id]) {\n        for (const bufferName of BUFFER_NAMES) {\n          if (results[id][bufferName] && weights[id][bufferName] !== results[id][bufferName]) {\n            // No result buffer is provided in weights object, `readPixelsToBuffer` has created a new Buffer object\n            // collect the new buffer for garabge collection\n            const name = `gpu-result-${id}-${bufferName}`;\n            if (resources[name]) {\n              resources[name].delete();\n            }\n            resources[name] = results[id][bufferName];\n          }\n        }\n      }\n    }\n  }\n  /* eslint-enable max-depth */\n\n  /* eslint-disable max-statements */\n  updateModels(opts) {\n    const {gl} = this;\n    const {positions, positions64xyLow, changeFlags} = opts;\n    const {numCol, numRow} = this.state;\n    const aggregationModelAttributes = {};\n    let modelDirty = false;\n\n    if (opts.fp64 !== this.state.fp64) {\n      this.setupModels(opts.fp64);\n      this.setState({fp64: opts.fp64});\n      modelDirty = true;\n    }\n\n    if (changeFlags.dataChanged || !this.state.positionsBuffer) {\n      let {positionsBuffer, positions64xyLowBuffer} = this.state;\n      if (positionsBuffer) {\n        positionsBuffer.delete();\n      }\n      if (positions64xyLowBuffer) {\n        positions64xyLowBuffer.delete();\n      }\n      const vertexCount = positions.length / 2;\n      positionsBuffer = new Buffer(gl, new Float32Array(positions));\n      positions64xyLowBuffer = new Buffer(gl, {\n        data: new Float32Array(positions64xyLow),\n        accessor: {size: 2}\n      });\n      this.setState({positionsBuffer, positions64xyLowBuffer, vertexCount});\n\n      this.setupWeightAttributes(opts);\n      modelDirty = true;\n    }\n\n    if (modelDirty) {\n      const {vertexCount, positionsBuffer, positions64xyLowBuffer} = this.state;\n      aggregationModelAttributes.positions = positionsBuffer;\n      if (opts.fp64) {\n        aggregationModelAttributes.positions64xyLow = positions64xyLowBuffer;\n      }\n      this.gridAggregationModel.setVertexCount(vertexCount);\n      this.gridAggregationModel.setAttributes(aggregationModelAttributes);\n    }\n\n    if (changeFlags.cellSizeChanged || changeFlags.viewportChanged) {\n      this.allAggregationModel.setInstanceCount(numCol * numRow);\n    }\n  }\n  /* eslint-enable max-statements */\n}\n"],"file":"gpu-grid-aggregator.js"}