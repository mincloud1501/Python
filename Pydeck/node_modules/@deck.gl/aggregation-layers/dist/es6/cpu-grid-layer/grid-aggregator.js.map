{"version":3,"sources":["../../../src/cpu-grid-layer/grid-aggregator.js"],"names":["createIterable","R_EARTH","pointToDensityGridDataCPU","data","cellSize","getPosition","gridHash","gridOffset","_pointsToGridHashing","result","_getGridLayerDataFromGridHash","points","latMin","Infinity","latMax","pLat","iterable","objectInfo","pt","index","Number","isFinite","centerLat","_calculateGridLatLonOffset","xOffset","yOffset","lng","lat","latIdx","Math","floor","lonIdx","key","count","push","Object","keys","reduce","accu","i","idxs","split","parseInt","assign","position","latitude","_calculateLatOffset","_calculateLonOffset","dy","PI","dx","cos"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {createIterable} from '@deck.gl/core';\n\nconst R_EARTH = 6378000;\n\n/**\n * Calculate density grid from an array of points\n * @param {Iterable} data\n * @param {number} cellSize - cell size in meters\n * @param {function} getPosition - position accessor\n * @returns {object} - grid data, cell dimension\n */\nexport function pointToDensityGridDataCPU({data, cellSize, getPosition}) {\n  const {gridHash, gridOffset} = _pointsToGridHashing(data, cellSize, getPosition);\n  const result = _getGridLayerDataFromGridHash(gridHash, gridOffset);\n\n  return {\n    gridHash,\n    gridOffset,\n    data: result\n  };\n}\n\n/**\n * Project points into each cell, return a hash table of cells\n * @param {Iterable} points\n * @param {number} cellSize - unit size in meters\n * @param {function} getPosition - position accessor\n * @returns {object} - grid hash and cell dimension\n */\n/* eslint-disable max-statements */\nfunction _pointsToGridHashing(points = [], cellSize, getPosition) {\n  // find the geometric center of sample points\n  let latMin = Infinity;\n  let latMax = -Infinity;\n  let pLat;\n\n  const {iterable, objectInfo} = createIterable(points);\n  for (const pt of iterable) {\n    objectInfo.index++;\n    pLat = getPosition(pt, objectInfo)[1];\n    if (Number.isFinite(pLat)) {\n      latMin = pLat < latMin ? pLat : latMin;\n      latMax = pLat > latMax ? pLat : latMax;\n    }\n  }\n\n  const centerLat = (latMin + latMax) / 2;\n\n  const gridOffset = _calculateGridLatLonOffset(cellSize, centerLat);\n\n  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {\n    return {gridHash: {}, gridOffset};\n  }\n\n  // calculate count per cell\n  const gridHash = {};\n\n  // Iterating over again, reset index\n  objectInfo.index = -1;\n  for (const pt of iterable) {\n    objectInfo.index++;\n    const [lng, lat] = getPosition(pt, objectInfo);\n\n    if (Number.isFinite(lat) && Number.isFinite(lng)) {\n      const latIdx = Math.floor((lat + 90) / gridOffset.yOffset);\n      const lonIdx = Math.floor((lng + 180) / gridOffset.xOffset);\n      const key = `${latIdx}-${lonIdx}`;\n\n      gridHash[key] = gridHash[key] || {count: 0, points: []};\n      gridHash[key].count += 1;\n      gridHash[key].points.push(pt);\n    }\n  }\n\n  return {gridHash, gridOffset};\n}\n/* eslint-enable max-statements */\n\nfunction _getGridLayerDataFromGridHash(gridHash, gridOffset) {\n  return Object.keys(gridHash).reduce((accu, key, i) => {\n    const idxs = key.split('-');\n    const latIdx = parseInt(idxs[0], 10);\n    const lonIdx = parseInt(idxs[1], 10);\n\n    accu.push(\n      Object.assign(\n        {\n          index: i,\n          position: [-180 + gridOffset.xOffset * lonIdx, -90 + gridOffset.yOffset * latIdx]\n        },\n        gridHash[key]\n      )\n    );\n\n    return accu;\n  }, []);\n}\n\n/**\n * calculate grid layer cell size in lat lon based on world unit size\n * and current latitude\n * @param {number} cellSize\n * @param {number} latitude\n * @returns {object} - lat delta and lon delta\n */\nfunction _calculateGridLatLonOffset(cellSize, latitude) {\n  const yOffset = _calculateLatOffset(cellSize);\n  const xOffset = _calculateLonOffset(latitude, cellSize);\n  return {yOffset, xOffset};\n}\n\n/**\n * with a given x-km change, calculate the increment of latitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} dy - change in km\n * @return {number} - increment in latitude\n */\nfunction _calculateLatOffset(dy) {\n  return (dy / R_EARTH) * (180 / Math.PI);\n}\n\n/**\n * with a given x-km change, and current latitude\n * calculate the increment of longitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} lat - latitude of current location (based on city)\n * @param {number} dx - change in km\n * @return {number} - increment in longitude\n */\nfunction _calculateLonOffset(lat, dx) {\n  return ((dx / R_EARTH) * (180 / Math.PI)) / Math.cos((lat * Math.PI) / 180);\n}\n"],"file":"grid-aggregator.js"}