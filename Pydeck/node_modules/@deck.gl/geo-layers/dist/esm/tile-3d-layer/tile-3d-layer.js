import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/esm/inherits";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { COORDINATE_SYSTEM, CompositeLayer } from '@deck.gl/core';
import { PointCloudLayer } from '@deck.gl/layers';
import { ScenegraphLayer } from '@deck.gl/mesh-layers';
import { Tileset3D, _getIonTilesetMetadata } from '@loaders.gl/3d-tiles';
import { getFrameState } from './get-frame-state';
var defaultProps = {
  getPointColor: [0, 0, 0],
  pointSize: 1.0,
  opacity: 1.0,
  data: null,
  _ionAssetId: null,
  _ionAccessToken: null,
  loadOptions: {
    throttleRequests: true
  },
  onTilesetLoad: function onTilesetLoad(tileset3d) {},
  onTileLoad: function onTileLoad(tileHeader) {},
  onTileUnload: function onTileUnload(tileHeader) {},
  onTileLoadFail: function onTileLoadFail(tile, message, url) {}
};

var Tile3DLayer = function (_CompositeLayer) {
  _inherits(Tile3DLayer, _CompositeLayer);

  function Tile3DLayer() {
    _classCallCheck(this, Tile3DLayer);

    return _possibleConstructorReturn(this, _getPrototypeOf(Tile3DLayer).apply(this, arguments));
  }

  _createClass(Tile3DLayer, [{
    key: "initializeState",
    value: function initializeState() {
      this.state = {
        layerMap: {},
        tileset3d: null
      };
    }
  }, {
    key: "shouldUpdateState",
    value: function shouldUpdateState(_ref) {
      var changeFlags = _ref.changeFlags;
      return changeFlags.somethingChanged;
    }
  }, {
    key: "updateState",
    value: function () {
      var _updateState = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(_ref2) {
        var props, oldProps, tileset3d;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                props = _ref2.props, oldProps = _ref2.oldProps;

                if (!(props.data && props.data !== oldProps.data)) {
                  _context.next = 6;
                  break;
                }

                _context.next = 4;
                return this._loadTileset(props.data);

              case 4:
                _context.next = 9;
                break;

              case 6:
                if (!((props._ionAccessToken || props._ionAssetId) && (props._ionAccessToken !== oldProps._ionAccessToken || props._ionAssetId !== oldProps._ionAssetId))) {
                  _context.next = 9;
                  break;
                }

                _context.next = 9;
                return this._loadTilesetFromIon(props._ionAccessToken, props._ionAssetId);

              case 9:
                tileset3d = this.state.tileset3d;
                _context.next = 12;
                return this._updateTileset(tileset3d);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function updateState(_x) {
        return _updateState.apply(this, arguments);
      }

      return updateState;
    }()
  }, {
    key: "_loadTileset",
    value: function () {
      var _loadTileset2 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(tilesetUrl, fetchOptions, ionMetadata) {
        var _this = this;

        var response, tilesetJson, loadOptions, tileset3d;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return fetch(tilesetUrl, fetchOptions);

              case 2:
                response = _context2.sent;
                _context2.next = 5;
                return response.json();

              case 5:
                tilesetJson = _context2.sent;
                loadOptions = this.getLoadOptions();
                tileset3d = new Tileset3D(tilesetJson, tilesetUrl, _objectSpread({
                  onTileLoad: function onTileLoad(tileHeader) {
                    _this.props.onTileLoad(tileHeader);

                    _this._updateTileset(tileset3d);

                    _this.setNeedsUpdate();
                  },
                  onTileUnload: this.props.onTileUnload,
                  onTileLoadFail: this.props.onTileLoadFail,
                  fetchOptions: fetchOptions
                }, ionMetadata, {}, loadOptions));
                this.setState({
                  tileset3d: tileset3d,
                  layerMap: {}
                });

                if (tileset3d) {
                  this.props.onTilesetLoad(tileset3d);
                }

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _loadTileset(_x2, _x3, _x4) {
        return _loadTileset2.apply(this, arguments);
      }

      return _loadTileset;
    }()
  }, {
    key: "_loadTilesetFromIon",
    value: function () {
      var _loadTilesetFromIon2 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3(ionAccessToken, ionAssetId) {
        var ionMetadata, url, headers;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return _getIonTilesetMetadata(ionAccessToken, ionAssetId);

              case 2:
                ionMetadata = _context3.sent;
                url = ionMetadata.url, headers = ionMetadata.headers;
                _context3.next = 6;
                return this._loadTileset(url, {
                  headers: headers
                }, ionMetadata);

              case 6:
                return _context3.abrupt("return", _context3.sent);

              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _loadTilesetFromIon(_x5, _x6) {
        return _loadTilesetFromIon2.apply(this, arguments);
      }

      return _loadTilesetFromIon;
    }()
  }, {
    key: "_updateTileset",
    value: function _updateTileset(tileset3d) {
      var _this$context = this.context,
          timeline = _this$context.timeline,
          viewport = _this$context.viewport;

      if (!timeline || !viewport || !tileset3d) {
        return;
      }

      var frameState = getFrameState(viewport, Date.now());
      tileset3d.update(frameState);

      this._updateLayerMap(frameState.frameNumber);
    }
  }, {
    key: "_updateLayerMap",
    value: function _updateLayerMap(frameNumber) {
      var _this$state = this.state,
          tileset3d = _this$state.tileset3d,
          layerMap = _this$state.layerMap;
      var selectedTiles = tileset3d.selectedTiles;
      var tilesWithoutLayer = selectedTiles.filter(function (tile) {
        return !layerMap[tile.fullUri];
      });
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = tilesWithoutLayer[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var tile = _step.value;
          tileset3d.addTileToCache(tile);
          layerMap[tile.fullUri] = {
            layer: this._create3DTileLayer(tile),
            tile: tile
          };
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this._selectLayers(frameNumber);
    }
  }, {
    key: "_selectLayers",
    value: function _selectLayers(frameNumber) {
      var layerMap = this.state.layerMap;
      var layerMapValues = Object.values(layerMap);

      for (var _i = 0, _layerMapValues = layerMapValues; _i < _layerMapValues.length; _i++) {
        var value = _layerMapValues[_i];
        var tile = value.tile;
        var layer = value.layer;

        if (tile.selectedFrame === frameNumber) {
          if (layer && layer.props && !layer.props.visible) {
            layer = layer.clone({
              visible: true
            });
            layerMap[tile.fullUri].layer = layer;
          }
        } else if (tile.contentUnloaded) {
          delete layerMap[tile.fullUri];
        } else if (layer && layer.props && layer.props.visible) {
          layer = layer.clone({
            visible: false
          });
          layerMap[tile.fullUri].layer = layer;
        }
      }

      this.setState({
        layers: Object.values(layerMap).map(function (layer) {
          return layer.layer;
        })
      });
    }
  }, {
    key: "_create3DTileLayer",
    value: function _create3DTileLayer(tileHeader) {
      if (!tileHeader.content) {
        return null;
      }

      switch (tileHeader.content.type) {
        case 'pnts':
          return this._createPointCloudTileLayer(tileHeader);

        case 'i3dm':
        case 'b3dm':
          return this._create3DModelTileLayer(tileHeader);

        default:
          throw new Error("Tile3DLayer: Failed to render layer of type ".concat(tileHeader.content.type));
      }
    }
  }, {
    key: "_create3DModelTileLayer",
    value: function _create3DModelTileLayer(tileHeader) {
      var _tileHeader$content = tileHeader.content,
          gltf = _tileHeader$content.gltf,
          instances = _tileHeader$content.instances,
          cartographicOrigin = _tileHeader$content.cartographicOrigin,
          modelMatrix = _tileHeader$content.modelMatrix;
      var SubLayerClass = this.getSubLayerClass('scenegraph', ScenegraphLayer);
      return new SubLayerClass({
        _lighting: 'pbr'
      }, this.getSubLayerProps({
        id: 'scenegraph'
      }), {
        id: "".concat(this.id, "-scenegraph-").concat(tileHeader.fullUri),
        data: instances || [{}],
        scenegraph: gltf,
        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,
        coordinateOrigin: cartographicOrigin,
        modelMatrix: modelMatrix,
        _composeModelMatrix: true,
        getTransformMatrix: function getTransformMatrix(instance) {
          return instance.modelMatrix;
        },
        getPosition: function getPosition(instance) {
          return [0, 0, 0];
        }
      });
    }
  }, {
    key: "_createPointCloudTileLayer",
    value: function _createPointCloudTileLayer(tileHeader) {
      var _tileHeader$content2 = tileHeader.content,
          attributes = _tileHeader$content2.attributes,
          pointCount = _tileHeader$content2.pointCount,
          constantRGBA = _tileHeader$content2.constantRGBA,
          cartographicOrigin = _tileHeader$content2.cartographicOrigin,
          modelMatrix = _tileHeader$content2.modelMatrix;
      var positions = attributes.positions,
          normals = attributes.normals,
          colors = attributes.colors;

      if (!positions) {
        return null;
      }

      var _this$props = this.props,
          pointSize = _this$props.pointSize,
          getPointColor = _this$props.getPointColor;
      var SubLayerClass = this.getSubLayerClass('pointcloud', PointCloudLayer);
      return new SubLayerClass({
        pointSize: pointSize
      }, this.getSubLayerProps({
        id: 'pointcloud'
      }), {
        id: "".concat(this.id, "-pointcloud-").concat(tileHeader.fullUri),
        data: {
          header: {
            vertexCount: pointCount
          },
          attributes: {
            POSITION: positions,
            NORMAL: normals,
            COLOR_0: colors
          }
        },
        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,
        coordinateOrigin: cartographicOrigin,
        modelMatrix: modelMatrix,
        getColor: constantRGBA || getPointColor
      });
    }
  }, {
    key: "renderLayers",
    value: function renderLayers() {
      return this.state.layers;
    }
  }]);

  return Tile3DLayer;
}(CompositeLayer);

export { Tile3DLayer as default };
Tile3DLayer.layerName = 'Tile3DLayer';
Tile3DLayer.defaultProps = defaultProps;
//# sourceMappingURL=tile-3d-layer.js.map