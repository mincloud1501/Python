import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { COORDINATE_SYSTEM, CompositeLayer } from '@deck.gl/core';
import { PointCloudLayer } from '@deck.gl/layers';
import { ScenegraphLayer } from '@deck.gl/mesh-layers';
import { Tileset3D, _getIonTilesetMetadata } from '@loaders.gl/3d-tiles';
import { getFrameState } from './get-frame-state';
const defaultProps = {
  getPointColor: [0, 0, 0],
  pointSize: 1.0,
  opacity: 1.0,
  data: null,
  _ionAssetId: null,
  _ionAccessToken: null,
  loadOptions: {
    throttleRequests: true
  },
  onTilesetLoad: tileset3d => {},
  onTileLoad: tileHeader => {},
  onTileUnload: tileHeader => {},
  onTileLoadFail: (tile, message, url) => {}
};
export default class Tile3DLayer extends CompositeLayer {
  initializeState() {
    this.state = {
      layerMap: {},
      tileset3d: null
    };
  }

  shouldUpdateState({
    changeFlags
  }) {
    return changeFlags.somethingChanged;
  }

  async updateState({
    props,
    oldProps
  }) {
    if (props.data && props.data !== oldProps.data) {
      await this._loadTileset(props.data);
    } else if ((props._ionAccessToken || props._ionAssetId) && (props._ionAccessToken !== oldProps._ionAccessToken || props._ionAssetId !== oldProps._ionAssetId)) {
      await this._loadTilesetFromIon(props._ionAccessToken, props._ionAssetId);
    }

    const {
      tileset3d
    } = this.state;
    await this._updateTileset(tileset3d);
  }

  async _loadTileset(tilesetUrl, fetchOptions, ionMetadata) {
    const response = await fetch(tilesetUrl, fetchOptions);
    const tilesetJson = await response.json();
    const loadOptions = this.getLoadOptions();
    const tileset3d = new Tileset3D(tilesetJson, tilesetUrl, _objectSpread({
      onTileLoad: tileHeader => {
        this.props.onTileLoad(tileHeader);

        this._updateTileset(tileset3d);

        this.setNeedsUpdate();
      },
      onTileUnload: this.props.onTileUnload,
      onTileLoadFail: this.props.onTileLoadFail,
      fetchOptions
    }, ionMetadata, {}, loadOptions));
    this.setState({
      tileset3d,
      layerMap: {}
    });

    if (tileset3d) {
      this.props.onTilesetLoad(tileset3d);
    }
  }

  async _loadTilesetFromIon(ionAccessToken, ionAssetId) {
    const ionMetadata = await _getIonTilesetMetadata(ionAccessToken, ionAssetId);
    const {
      url,
      headers
    } = ionMetadata;
    return await this._loadTileset(url, {
      headers
    }, ionMetadata);
  }

  _updateTileset(tileset3d) {
    const {
      timeline,
      viewport
    } = this.context;

    if (!timeline || !viewport || !tileset3d) {
      return;
    }

    const frameState = getFrameState(viewport, Date.now());
    tileset3d.update(frameState);

    this._updateLayerMap(frameState.frameNumber);
  }

  _updateLayerMap(frameNumber) {
    const {
      tileset3d,
      layerMap
    } = this.state;
    const {
      selectedTiles
    } = tileset3d;
    const tilesWithoutLayer = selectedTiles.filter(tile => !layerMap[tile.fullUri]);

    for (const tile of tilesWithoutLayer) {
      tileset3d.addTileToCache(tile);
      layerMap[tile.fullUri] = {
        layer: this._create3DTileLayer(tile),
        tile
      };
    }

    this._selectLayers(frameNumber);
  }

  _selectLayers(frameNumber) {
    const {
      layerMap
    } = this.state;
    const layerMapValues = Object.values(layerMap);

    for (const value of layerMapValues) {
      const {
        tile
      } = value;
      let {
        layer
      } = value;

      if (tile.selectedFrame === frameNumber) {
        if (layer && layer.props && !layer.props.visible) {
          layer = layer.clone({
            visible: true
          });
          layerMap[tile.fullUri].layer = layer;
        }
      } else if (tile.contentUnloaded) {
        delete layerMap[tile.fullUri];
      } else if (layer && layer.props && layer.props.visible) {
        layer = layer.clone({
          visible: false
        });
        layerMap[tile.fullUri].layer = layer;
      }
    }

    this.setState({
      layers: Object.values(layerMap).map(layer => layer.layer)
    });
  }

  _create3DTileLayer(tileHeader) {
    if (!tileHeader.content) {
      return null;
    }

    switch (tileHeader.content.type) {
      case 'pnts':
        return this._createPointCloudTileLayer(tileHeader);

      case 'i3dm':
      case 'b3dm':
        return this._create3DModelTileLayer(tileHeader);

      default:
        throw new Error("Tile3DLayer: Failed to render layer of type ".concat(tileHeader.content.type));
    }
  }

  _create3DModelTileLayer(tileHeader) {
    const {
      gltf,
      instances,
      cartographicOrigin,
      modelMatrix
    } = tileHeader.content;
    const SubLayerClass = this.getSubLayerClass('scenegraph', ScenegraphLayer);
    return new SubLayerClass({
      _lighting: 'pbr'
    }, this.getSubLayerProps({
      id: 'scenegraph'
    }), {
      id: "".concat(this.id, "-scenegraph-").concat(tileHeader.fullUri),
      data: instances || [{}],
      scenegraph: gltf,
      coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,
      coordinateOrigin: cartographicOrigin,
      modelMatrix,
      _composeModelMatrix: true,
      getTransformMatrix: instance => instance.modelMatrix,
      getPosition: instance => [0, 0, 0]
    });
  }

  _createPointCloudTileLayer(tileHeader) {
    const {
      attributes,
      pointCount,
      constantRGBA,
      cartographicOrigin,
      modelMatrix
    } = tileHeader.content;
    const {
      positions,
      normals,
      colors
    } = attributes;

    if (!positions) {
      return null;
    }

    const {
      pointSize,
      getPointColor
    } = this.props;
    const SubLayerClass = this.getSubLayerClass('pointcloud', PointCloudLayer);
    return new SubLayerClass({
      pointSize
    }, this.getSubLayerProps({
      id: 'pointcloud'
    }), {
      id: "".concat(this.id, "-pointcloud-").concat(tileHeader.fullUri),
      data: {
        header: {
          vertexCount: pointCount
        },
        attributes: {
          POSITION: positions,
          NORMAL: normals,
          COLOR_0: colors
        }
      },
      coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,
      coordinateOrigin: cartographicOrigin,
      modelMatrix,
      getColor: constantRGBA || getPointColor
    });
  }

  renderLayers() {
    return this.state.layers;
  }

}
Tile3DLayer.layerName = 'Tile3DLayer';
Tile3DLayer.defaultProps = defaultProps;
//# sourceMappingURL=tile-3d-layer.js.map