{"version":3,"sources":["../../../../src/tile-layer/utils/tile-cache.js"],"names":["Tile","getTileIndices","TileCache","constructor","getTileData","maxSize","maxZoom","minZoom","onTileLoad","onTileError","_getTileData","_maxSize","_cache","Map","_tiles","Number","isFinite","_maxZoom","Math","floor","_minZoom","ceil","tiles","finalize","clear","update","viewport","_markOldTiles","tileIndices","length","forEach","cachedTile","some","tile","isOverlapped","isVisible","changed","i","tileIndex","x","y","z","_getTile","tileId","_getTileId","set","commonZoomRange","_resizeCache","Array","from","values","sort","t1","t2","size","iterator","Symbol","delete","get"],"mappings":"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","sourcesContent":["import Tile from './tile';\nimport {getTileIndices} from './viewport-util';\n\n/**\n * Manages loading and purging of tiles data. This class caches recently visited tiles\n * and only create new tiles if they are present.\n */\n\nexport default class TileCache {\n  /**\n   * Takes in a function that returns tile data, a cache size, and a max and a min zoom level.\n   * Cache size defaults to 5 * number of tiles in the current viewport\n   */\n  constructor({getTileData, maxSize, maxZoom, minZoom, onTileLoad, onTileError}) {\n    // TODO: Instead of hardcode size, we should calculate how much memory left\n    this._getTileData = getTileData;\n    this._maxSize = maxSize;\n    this.onTileError = onTileError;\n    this.onTileLoad = onTileLoad;\n\n    // Maps tile id in string {z}-{x}-{y} to a Tile object\n    this._cache = new Map();\n    this._tiles = [];\n\n    if (Number.isFinite(maxZoom)) {\n      this._maxZoom = Math.floor(maxZoom);\n    }\n    if (Number.isFinite(minZoom)) {\n      this._minZoom = Math.ceil(minZoom);\n    }\n  }\n\n  get tiles() {\n    return this._tiles;\n  }\n\n  /**\n   * Clear the current cache\n   */\n  finalize() {\n    this._cache.clear();\n  }\n\n  /**\n   * Update the cache with the given viewport and triggers callback onUpdate.\n   * @param {*} viewport\n   * @param {*} onUpdate\n   */\n  update(viewport) {\n    const {_cache, _getTileData, _maxSize, _maxZoom, _minZoom} = this;\n    this._markOldTiles();\n    const tileIndices = getTileIndices(viewport, _maxZoom, _minZoom);\n    if (!tileIndices || tileIndices.length === 0) {\n      return;\n    }\n    _cache.forEach(cachedTile => {\n      if (tileIndices.some(tile => cachedTile.isOverlapped(tile))) {\n        cachedTile.isVisible = true;\n      }\n    });\n\n    let changed = false;\n\n    for (let i = 0; i < tileIndices.length; i++) {\n      const tileIndex = tileIndices[i];\n\n      const {x, y, z} = tileIndex;\n      let tile = this._getTile(x, y, z);\n      if (!tile) {\n        tile = new Tile({\n          getTileData: _getTileData,\n          x,\n          y,\n          z,\n          onTileLoad: this.onTileLoad,\n          onTileError: this.onTileError\n        });\n        tile.isVisible = true;\n        changed = true;\n      }\n      const tileId = this._getTileId(x, y, z);\n      _cache.set(tileId, tile);\n    }\n\n    if (changed) {\n      // cache size is either the user defined maxSize or 5 * number of current tiles in the viewport.\n      const commonZoomRange = 5;\n      this._resizeCache(_maxSize || commonZoomRange * tileIndices.length);\n      this._tiles = Array.from(this._cache.values())\n        // sort by zoom level so parents tiles don't show up when children tiles are rendered\n        .sort((t1, t2) => t1.z - t2.z);\n    }\n  }\n\n  /**\n   * Clear tiles that are not visible when the cache is full\n   */\n  _resizeCache(maxSize) {\n    const {_cache} = this;\n    if (_cache.size > maxSize) {\n      const iterator = _cache[Symbol.iterator]();\n      for (const cachedTile of iterator) {\n        if (_cache.size <= maxSize) {\n          break;\n        }\n        const tileId = cachedTile[0];\n        const tile = cachedTile[1];\n        if (!tile.isVisible) {\n          _cache.delete(tileId);\n        }\n      }\n    }\n  }\n\n  _markOldTiles() {\n    this._cache.forEach(cachedTile => {\n      cachedTile.isVisible = false;\n    });\n  }\n\n  _getTile(x, y, z) {\n    const tileId = this._getTileId(x, y, z);\n    return this._cache.get(tileId);\n  }\n\n  _getTileId(x, y, z) {\n    return `${z}-${x}-${y}`;\n  }\n}\n"],"file":"tile-cache.js"}