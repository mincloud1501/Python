"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _core = require("@luma.gl/core");

var _assert = _interopRequireDefault(require("../utils/assert"));

var _iterableUtils = require("../utils/iterable-utils");

var _flatten = require("../utils/flatten");

var range = _interopRequireWildcard(require("../utils/range"));

var _log = _interopRequireDefault(require("../utils/log"));

var _baseAttribute = _interopRequireDefault(require("./base-attribute"));

var _typedArrayManager = _interopRequireDefault(require("../utils/typed-array-manager"));

var _mathUtils = require("../utils/math-utils");

var _attributeTransitionUtils = require("./attribute-transition-utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var DEFAULT_STATE = {
  isExternalBuffer: false,
  lastExternalBuffer: null,
  allocatedValue: null,
  needsUpdate: true,
  needsRedraw: false,
  updateRanges: range.FULL
};

function addDoublePrecisionAttributes(attribute, shaderAttributeDefs) {
  var doubleShaderAttributeDefs = {};

  for (var shaderAttributeName in shaderAttributeDefs) {
    var def = shaderAttributeDefs[shaderAttributeName];
    var offset = 'offset' in def ? def.offset : attribute.offset;
    var stride = 'stride' in def ? def.stride : attribute.size * 4;
    doubleShaderAttributeDefs["".concat(shaderAttributeName, "32")] = Object.assign({}, def, {
      offset: offset,
      stride: stride
    });
    doubleShaderAttributeDefs["".concat(shaderAttributeName, "64")] = Object.assign({}, def, {
      offset: offset * 2,
      stride: stride * 2
    });
    doubleShaderAttributeDefs["".concat(shaderAttributeName, "64xyLow")] = Object.assign({}, def, {
      offset: offset * 2 + stride,
      stride: stride * 2
    });
  }

  return doubleShaderAttributeDefs;
}

var Attribute = function (_BaseAttribute) {
  (0, _inherits2["default"])(Attribute, _BaseAttribute);

  function Attribute(gl) {
    var _this;

    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, Attribute);
    var logicalType = opts.type;
    var doublePrecision = logicalType === 5130;
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Attribute).call(this, gl, doublePrecision ? _objectSpread({}, opts, {
      type: 5126
    }) : opts));
    var _opts$transition = opts.transition,
        transition = _opts$transition === void 0 ? false : _opts$transition,
        _opts$noAlloc = opts.noAlloc,
        noAlloc = _opts$noAlloc === void 0 ? false : _opts$noAlloc,
        _opts$update = opts.update,
        update = _opts$update === void 0 ? null : _opts$update,
        _opts$accessor = opts.accessor,
        accessor = _opts$accessor === void 0 ? null : _opts$accessor,
        _opts$transform = opts.transform,
        transform = _opts$transform === void 0 ? null : _opts$transform,
        _opts$bufferLayout = opts.bufferLayout,
        bufferLayout = _opts$bufferLayout === void 0 ? null : _opts$bufferLayout;
    var _opts$defaultValue = opts.defaultValue,
        defaultValue = _opts$defaultValue === void 0 ? [0, 0, 0, 0] : _opts$defaultValue;
    defaultValue = Array.isArray(defaultValue) ? defaultValue : [defaultValue];
    _this.defaultType = logicalType || _this.type || 5126;
    _this.shaderAttributes = {};
    _this.hasShaderAttributes = false;
    _this.doublePrecision = doublePrecision;

    if (doublePrecision && opts.fp64 === false) {
      _this.defaultType = 5126;
    }

    var shaderAttributes = opts.shaderAttributes || doublePrecision && (0, _defineProperty2["default"])({}, _this.id, {});

    if (shaderAttributes) {
      var shaderAttributeNames = Object.keys(shaderAttributes);
      shaderAttributes = doublePrecision ? addDoublePrecisionAttributes((0, _assertThisInitialized2["default"])(_this), shaderAttributes) : shaderAttributes;

      for (var shaderAttributeName in shaderAttributes) {
        var shaderAttribute = shaderAttributes[shaderAttributeName];
        _this.shaderAttributes[shaderAttributeName] = new _baseAttribute["default"](_this.gl, Object.assign({
          size: _this.size,
          normalized: _this.normalized,
          integer: _this.integer,
          offset: _this.offset,
          stride: _this.stride,
          divisor: _this.divisor
        }, shaderAttribute, {
          id: shaderAttributeName,
          buffer: _this.getBuffer()
        }));
        _this.hasShaderAttributes = shaderAttributeNames;
      }
    }

    Object.assign(_this.userData, DEFAULT_STATE, opts, {
      transition: transition,
      noAlloc: noAlloc,
      update: update || accessor && _this._standardAccessor,
      accessor: accessor,
      transform: transform,
      defaultValue: defaultValue,
      bufferLayout: bufferLayout
    });
    Object.seal(_this.userData);

    _this._validateAttributeUpdaters();

    return _this;
  }

  (0, _createClass2["default"])(Attribute, [{
    key: "delete",
    value: function _delete() {
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(Attribute.prototype), "delete", this).call(this);

      _typedArrayManager["default"].release(this.userData.allocatedValue);
    }
  }, {
    key: "needsUpdate",
    value: function needsUpdate() {
      return this.userData.needsUpdate;
    }
  }, {
    key: "needsRedraw",
    value: function needsRedraw() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$clearChangedFla = _ref2.clearChangedFlags,
          clearChangedFlags = _ref2$clearChangedFla === void 0 ? false : _ref2$clearChangedFla;

      var needsRedraw = this.userData.needsRedraw;
      this.userData.needsRedraw = this.userData.needsRedraw && !clearChangedFlags;
      return needsRedraw;
    }
  }, {
    key: "getUpdateTriggers",
    value: function getUpdateTriggers() {
      var accessor = this.userData.accessor;
      return [this.id].concat(typeof accessor !== 'function' && accessor || []);
    }
  }, {
    key: "getAccessor",
    value: function getAccessor() {
      return this.userData.accessor;
    }
  }, {
    key: "getShaderAttributes",
    value: function getShaderAttributes() {
      var shaderAttributes = {};

      if (this.doublePrecision) {
        var isBuffer64Bit = this.value instanceof Float64Array;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.hasShaderAttributes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var shaderAttributeName = _step.value;
            shaderAttributes[shaderAttributeName] = this.shaderAttributes[isBuffer64Bit ? "".concat(shaderAttributeName, "64") : "".concat(shaderAttributeName, "32")];
            var shaderAttributeLowPartName = "".concat(shaderAttributeName, "64xyLow");
            shaderAttributes[shaderAttributeLowPartName] = isBuffer64Bit ? this.shaderAttributes[shaderAttributeLowPartName] : new Float32Array(this.size);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      } else if (this.hasShaderAttributes) {
        Object.assign(shaderAttributes, this.shaderAttributes);
      } else {
        shaderAttributes[this.id] = this;
      }

      return shaderAttributes;
    }
  }, {
    key: "supportsTransition",
    value: function supportsTransition() {
      return Boolean(this.userData.transition);
    }
  }, {
    key: "getTransitionSetting",
    value: function getTransitionSetting(opts) {
      var accessor = this.userData.accessor;
      var layerSettings = this.userData.transition;

      if (!this.supportsTransition()) {
        return null;
      }

      var userSettings = Array.isArray(accessor) ? opts[accessor.find(function (a) {
        return opts[a];
      })] : opts[accessor];
      return (0, _attributeTransitionUtils.normalizeTransitionSettings)(userSettings, layerSettings);
    }
  }, {
    key: "setNeedsUpdate",
    value: function setNeedsUpdate() {
      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;
      var dataRange = arguments.length > 1 ? arguments[1] : undefined;
      this.userData.needsUpdate = this.userData.needsUpdate || reason;

      if (dataRange) {
        var _dataRange$startRow = dataRange.startRow,
            startRow = _dataRange$startRow === void 0 ? 0 : _dataRange$startRow,
            _dataRange$endRow = dataRange.endRow,
            endRow = _dataRange$endRow === void 0 ? Infinity : _dataRange$endRow;
        this.userData.updateRanges = range.add(this.userData.updateRanges, [startRow, endRow]);
      } else {
        this.userData.updateRanges = range.FULL;
      }
    }
  }, {
    key: "clearNeedsUpdate",
    value: function clearNeedsUpdate() {
      this.userData.needsUpdate = false;
      this.userData.updateRanges = range.EMPTY;
    }
  }, {
    key: "setNeedsRedraw",
    value: function setNeedsRedraw() {
      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;
      this.userData.needsRedraw = this.userData.needsRedraw || reason;
    }
  }, {
    key: "allocate",
    value: function allocate(numInstances) {
      var state = this.userData;

      if (state.isExternalBuffer || state.noAlloc) {
        return false;
      }

      if (state.update) {
        (0, _assert["default"])(Number.isFinite(numInstances));
        var allocCount = Math.max(numInstances, 1);
        var ArrayType = glArrayFromType(this.defaultType);
        var oldValue = state.allocatedValue;
        var shouldCopy = state.updateRanges !== range.FULL;
        this.constant = false;
        this.value = _typedArrayManager["default"].allocate(oldValue, allocCount, {
          size: this.size,
          type: ArrayType,
          padding: this.elementOffset,
          copy: shouldCopy
        });

        if (this.buffer && this.buffer.byteLength < this.value.byteLength) {
          this.buffer.reallocate(this.value.byteLength);

          if (shouldCopy && oldValue) {
            this.buffer.subData({
              data: oldValue instanceof Float64Array ? (0, _mathUtils.toDoublePrecisionArray)(oldValue, {
                size: this.size
              }) : oldValue
            });
          }
        }

        state.allocatedValue = this.value;
        return true;
      }

      return false;
    }
  }, {
    key: "updateBuffer",
    value: function updateBuffer(_ref3) {
      var numInstances = _ref3.numInstances,
          bufferLayout = _ref3.bufferLayout,
          data = _ref3.data,
          props = _ref3.props,
          context = _ref3.context;

      if (!this.needsUpdate()) {
        return false;
      }

      var state = this.userData;
      var update = state.update,
          updateRanges = state.updateRanges,
          noAlloc = state.noAlloc;
      var updated = true;

      if (update) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = updateRanges[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _step2$value = (0, _slicedToArray2["default"])(_step2.value, 2),
                startRow = _step2$value[0],
                endRow = _step2$value[1];

            update.call(context, this, {
              data: data,
              startRow: startRow,
              endRow: endRow,
              props: props,
              numInstances: numInstances,
              bufferLayout: bufferLayout
            });
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        var doublePrecision = this.doublePrecision && this.value instanceof Float64Array;

        if (this.constant || !this.buffer || this.buffer.byteLength < this.value.byteLength) {
          var attributeValue = this.value;
          this.update({
            value: doublePrecision ? (0, _mathUtils.toDoublePrecisionArray)(attributeValue, this) : attributeValue,
            constant: this.constant
          });
          this.value = attributeValue;
        } else {
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = updateRanges[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _step3$value = (0, _slicedToArray2["default"])(_step3.value, 2),
                  startRow = _step3$value[0],
                  endRow = _step3$value[1];

              var startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;
              var endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;
              this.buffer.subData({
                data: doublePrecision ? (0, _mathUtils.toDoublePrecisionArray)(this.value, {
                  size: this.size,
                  startIndex: startOffset,
                  endIndex: endOffset
                }) : this.value.subarray(startOffset, endOffset),
                offset: startOffset * this.value.BYTES_PER_ELEMENT
              });
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        }

        this._checkAttributeArray();
      } else {
        updated = false;
      }

      this._updateShaderAttributes();

      this.clearNeedsUpdate();
      state.needsRedraw = true;
      return updated;
    }
  }, {
    key: "update",
    value: function update(props) {
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(Attribute.prototype), "update", this).call(this, props);

      this._updateShaderAttributes();
    }
  }, {
    key: "setConstantValue",
    value: function setConstantValue(value) {
      var state = this.userData;

      if (value === undefined || typeof value === 'function') {
        state.isExternalBuffer = false;
        return false;
      }

      value = this._normalizeValue(value);
      var hasChanged = !this.constant || !this._areValuesEqual(value, this.value);

      if (hasChanged) {
        this.update({
          constant: true,
          value: value
        });
      }

      state.needsRedraw = state.needsUpdate || hasChanged;
      this.clearNeedsUpdate();
      state.isExternalBuffer = true;
      return true;
    }
  }, {
    key: "setExternalBuffer",
    value: function setExternalBuffer(buffer) {
      var state = this.userData;

      if (!buffer) {
        state.isExternalBuffer = false;
        state.lastExternalBuffer = null;
        return false;
      }

      this.clearNeedsUpdate();

      if (state.lastExternalBuffer === buffer) {
        return true;
      }

      state.isExternalBuffer = true;
      state.lastExternalBuffer = buffer;
      var opts;

      if (ArrayBuffer.isView(buffer)) {
        opts = {
          constant: false,
          value: buffer
        };
      } else if (buffer instanceof _core.Buffer) {
        opts = {
          constant: false,
          buffer: buffer
        };
      } else {
        opts = Object.assign({
          constant: false
        }, buffer);
      }

      this._checkExternalBuffer(opts);

      if (this.doublePrecision && opts.value instanceof Float64Array) {
        opts.originalValue = opts.value;
        opts.value = (0, _mathUtils.toDoublePrecisionArray)(opts.value, this);
      }

      this.update(opts);
      state.needsRedraw = true;

      if (opts.originalValue) {
        this.value = opts.originalValue;
      }

      return true;
    }
  }, {
    key: "_checkExternalBuffer",
    value: function _checkExternalBuffer(opts) {
      var value = opts.value;

      if (!opts.constant && value) {
        var ArrayType = glArrayFromType(this.defaultType);
        var illegalArrayType = false;

        if (this.doublePrecision) {
          illegalArrayType = value.BYTES_PER_ELEMENT < 4;
        } else if (this.hasShaderAttributes) {
          illegalArrayType = value.BYTES_PER_ELEMENT !== ArrayType.BYTES_PER_ELEMENT && Object.values(this.shaderAttributes).some(function (attribute) {
            return attribute.offset || attribute.stride;
          });
        }

        if (illegalArrayType) {
          throw new Error("Attribute ".concat(this.id, " does not support ").concat(value.constructor.name));
        }

        if (!(value instanceof ArrayType) && this.normalized && !('normalized' in opts)) {
          _log["default"].warn("Attribute ".concat(this.id, " is normalized"))();
        }
      }
    }
  }, {
    key: "getVertexOffset",
    value: function getVertexOffset(row) {
      var bufferLayout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bufferLayout;
      var offset = this.elementOffset;

      if (bufferLayout) {
        var index = 0;
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = bufferLayout[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var geometrySize = _step4.value;

            if (index >= row) {
              break;
            }

            offset += geometrySize * this.size;
            index++;
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
              _iterator4["return"]();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        return offset;
      }

      return offset + row * this.size;
    }
  }, {
    key: "_normalizeValue",
    value: function _normalizeValue(value) {
      var out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var defaultValue = this.userData.defaultValue;

      if (!Array.isArray(value) && !ArrayBuffer.isView(value)) {
        out[start] = Number.isFinite(value) ? value : defaultValue[0];
        return out;
      }

      switch (this.size) {
        case 4:
          out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];

        case 3:
          out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];

        case 2:
          out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];

        case 1:
          out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];
      }

      return out;
    }
  }, {
    key: "_areValuesEqual",
    value: function _areValuesEqual(value1, value2) {
      var size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.size;

      for (var i = 0; i < size; i++) {
        if (value1[i] !== value2[i]) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "_standardAccessor",
    value: function _standardAccessor(attribute, _ref4) {
      var data = _ref4.data,
          startRow = _ref4.startRow,
          endRow = _ref4.endRow,
          props = _ref4.props,
          numInstances = _ref4.numInstances,
          bufferLayout = _ref4.bufferLayout;
      var state = attribute.userData;
      var accessor = state.accessor,
          transform = state.transform;
      var value = attribute.value,
          size = attribute.size;
      var accessorFunc = typeof accessor === 'function' ? accessor : props[accessor];
      (0, _assert["default"])(typeof accessorFunc === 'function', "accessor \"".concat(accessor, "\" is not a function"));
      var i = attribute.getVertexOffset(startRow, bufferLayout);

      var _createIterable = (0, _iterableUtils.createIterable)(data, startRow, endRow),
          iterable = _createIterable.iterable,
          objectInfo = _createIterable.objectInfo;

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = iterable[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var object = _step5.value;
          objectInfo.index++;
          var objectValue = accessorFunc(object, objectInfo);

          if (transform) {
            objectValue = transform.call(this, objectValue);
          }

          if (bufferLayout) {
            attribute._normalizeValue(objectValue, objectInfo.target);

            var numVertices = bufferLayout[objectInfo.index];
            (0, _flatten.fillArray)({
              target: attribute.value,
              source: objectInfo.target,
              start: i,
              count: numVertices
            });
            i += numVertices * size;
          } else {
            attribute._normalizeValue(objectValue, value, i);

            i += size;
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      attribute.constant = false;
      attribute.bufferLayout = bufferLayout;
    }
  }, {
    key: "_validateAttributeUpdaters",
    value: function _validateAttributeUpdaters() {
      var state = this.userData;
      var hasUpdater = state.noAlloc || typeof state.update === 'function';

      if (!hasUpdater) {
        throw new Error("Attribute ".concat(this.id, " missing update or accessor"));
      }
    }
  }, {
    key: "_checkAttributeArray",
    value: function _checkAttributeArray() {
      var value = this.value;

      if (value && value.length >= 4) {
        var valid = Number.isFinite(value[0]) && Number.isFinite(value[1]) && Number.isFinite(value[2]) && Number.isFinite(value[3]);

        if (!valid) {
          throw new Error("Illegal attribute generated for ".concat(this.id));
        }
      }
    }
  }, {
    key: "_updateShaderAttributes",
    value: function _updateShaderAttributes() {
      var shaderAttributes = this.shaderAttributes;

      for (var shaderAttributeName in shaderAttributes) {
        var shaderAttribute = shaderAttributes[shaderAttributeName];
        shaderAttribute.update({
          buffer: this.getBuffer(),
          value: this.value,
          constant: this.constant
        });
      }
    }
  }, {
    key: "bufferLayout",
    get: function get() {
      return this.userData.bufferLayout;
    },
    set: function set(layout) {
      this.userData.bufferLayout = layout;
    }
  }]);
  return Attribute;
}(_baseAttribute["default"]);

exports["default"] = Attribute;

function glArrayFromType(glType) {
  switch (glType) {
    case 5126:
      return Float32Array;

    case 5130:
      return Float64Array;

    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;

    case 5125:
      return Uint32Array;

    case 5121:
      return Uint8ClampedArray;

    case 5120:
      return Int8Array;

    case 5122:
      return Int16Array;

    case 5124:
      return Int32Array;

    default:
      throw new Error('Failed to deduce type from array');
  }
}
//# sourceMappingURL=attribute.js.map