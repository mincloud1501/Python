{"version":3,"sources":["../../../src/lib/deck-picker.js"],"names":["DeckPicker","gl","pickingFBO","pickLayersPass","PickLayersPass","layerFilter","pickingEvent","lastPickedInfo","index","layerId","info","props","setProps","x","y","mode","radius","layers","viewports","activateViewport","depth","event","result","pickClosestObject","onViewportActive","width","height","pickVisibleObjects","lastPickedLayerId","layer","id","find","l","coordinate","unproject","lngLat","Object","assign","color","object","Framebuffer","resize","canvas","updatePickingBuffer","pixelRatio","devicePixelRange","devicePixel","Math","floor","deviceRadius","round","deviceRect","getPickingRect","deviceX","deviceY","deviceWidth","deviceHeight","infos","affectedLayers","i","pickedColors","drawAndSamplePickingBuffer","redrawReason","pickInfo","pickedColor","clearPickingColor","processedPickInfos","callLayerPickingCallbacks","forEach","push","restorePickingColors","emptyInfo","get","leftTop","deviceLeft","deviceTop","rightBottom","deviceRight","deviceBottom","pickInfos","uniqueInfos","Map","pickedObjectIndex","picked","pickedLayer","has","set","Array","from","values","Number","isFinite","pickableLayers","filter","isPickable","length","effectProps","lightSources","render","Uint8Array","sourceX","sourceY","sourceWidth","sourceHeight","target","max","min","unhandledPickInfos","handled","onHover","Error"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Framebuffer, readPixelsToArray, cssToDeviceRatio, cssToDevicePixels} from '@luma.gl/core';\nimport assert from '../utils/assert';\nimport PickLayersPass from '../passes/pick-layers-pass';\nimport {getClosestObject, getUniqueObjects} from './picking/query-object';\nimport {processPickInfo, getLayerPickingInfo} from './picking/pick-info';\n\nexport default class DeckPicker {\n  constructor(gl) {\n    this.gl = gl;\n    this.pickingFBO = null;\n    this.pickLayersPass = new PickLayersPass(gl);\n    this.layerFilter = null;\n    this.pickingEvent = null;\n    this.lastPickedInfo = {\n      // For callback tracking and auto highlight\n      index: -1,\n      layerId: null,\n      info: null\n    };\n  }\n\n  setProps(props) {\n    if ('layerFilter' in props) {\n      this.layerFilter = props.layerFilter;\n    }\n    this.pickLayersPass.setProps({\n      layerFilter: this.layerFilter\n    });\n  }\n\n  // Pick the closest info at given coordinate\n  pickObject({\n    x,\n    y,\n    mode,\n    radius = 0,\n    layers,\n    viewports,\n    activateViewport,\n    depth = 1,\n    event = null\n  }) {\n    // Allow layers to access the event\n    this.pickingEvent = event;\n    const result = this.pickClosestObject({\n      // User params\n      x,\n      y,\n      radius,\n      layers,\n      mode,\n      depth,\n      // Injected params\n      viewports,\n      onViewportActive: activateViewport\n    });\n\n    // Clear the current event\n    this.pickingEvent = null;\n    return result;\n  }\n\n  // Get all unique infos within a bounding box\n  pickObjects({x, y, width, height, layers, viewports, activateViewport}) {\n    return this.pickVisibleObjects({\n      x,\n      y,\n      width,\n      height,\n      layers,\n      mode: 'pickObjects',\n      viewports,\n      onViewportActive: activateViewport\n    });\n  }\n\n  // Returns a new picking info object by assuming the last picked object is still picked\n  getLastPickedObject({x, y, layers, viewports}, lastPickedInfo = this.lastPickedInfo.info) {\n    const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;\n    const layer = lastPickedLayerId ? layers.find(l => l.id === lastPickedLayerId) : null;\n    const coordinate = viewports[0] && viewports[0].unproject([x, y]);\n\n    const info = {\n      x,\n      y,\n      coordinate,\n      // TODO remove the lngLat prop after compatibility check\n      lngLat: coordinate,\n      layer\n    };\n\n    if (layer) {\n      return Object.assign({}, lastPickedInfo, info);\n    }\n    return Object.assign(info, {color: null, object: null, index: -1});\n  }\n\n  // Private\n  updatePickingBuffer() {\n    const {gl} = this;\n    // Create a frame buffer if not already available\n    if (!this.pickingFBO) {\n      this.pickingFBO = new Framebuffer(gl);\n    }\n    // Resize it to current canvas size (this is a noop if size hasn't changed)\n    this.pickingFBO.resize({width: gl.canvas.width, height: gl.canvas.height});\n    return this.pickingFBO;\n  }\n\n  // Pick the closest object at the given (x,y) coordinate\n  // eslint-disable-next-line max-statements\n  pickClosestObject({layers, viewports, x, y, radius, depth = 1, mode, onViewportActive}) {\n    this.updatePickingBuffer();\n    // Convert from canvas top-left to WebGL bottom-left coordinates\n    // Top-left coordinates [x, y] to bottom-left coordinates [deviceX, deviceY]\n    // And compensate for pixelRatio\n    const pixelRatio = cssToDeviceRatio(this.gl);\n    const devicePixelRange = cssToDevicePixels(this.gl, [x, y], true);\n    const devicePixel = [\n      devicePixelRange.x + Math.floor(devicePixelRange.width / 2),\n      devicePixelRange.y + Math.floor(devicePixelRange.height / 2)\n    ];\n\n    const deviceRadius = Math.round(radius * pixelRatio);\n    const {width, height} = this.pickingFBO;\n    const deviceRect = this.getPickingRect({\n      deviceX: devicePixel[0],\n      deviceY: devicePixel[1],\n      deviceRadius,\n      deviceWidth: width,\n      deviceHeight: height\n    });\n\n    let infos;\n    const result = [];\n    const affectedLayers = {};\n\n    for (let i = 0; i < depth; i++) {\n      const pickedColors =\n        deviceRect &&\n        this.drawAndSamplePickingBuffer({\n          layers,\n          viewports,\n          onViewportActive,\n          deviceRect,\n          redrawReason: mode\n        });\n\n      const pickInfo = getClosestObject({\n        pickedColors,\n        layers,\n        deviceX: devicePixel[0],\n        deviceY: devicePixel[1],\n        deviceRadius,\n        deviceRect\n      });\n\n      // Only exclude if we need to run picking again.\n      // We need to run picking again if an object is detected AND\n      // we have not exhausted the requested depth.\n      if (pickInfo.pickedColor && i + 1 < depth) {\n        const layerId = pickInfo.pickedColor[3] - 1;\n        affectedLayers[layerId] = true;\n        layers[layerId].clearPickingColor(pickInfo.pickedColor);\n      }\n\n      // This logic needs to run even if no object is picked.\n      infos = processPickInfo({\n        pickInfo,\n        lastPickedInfo: this.lastPickedInfo,\n        mode,\n        layers,\n        viewports,\n        x,\n        y,\n        deviceX: devicePixel[0],\n        deviceY: devicePixel[1],\n        pixelRatio\n      });\n\n      const processedPickInfos = this.callLayerPickingCallbacks(infos, mode);\n\n      if (processedPickInfos) {\n        processedPickInfos.forEach(info => result.push(info));\n      }\n\n      // If no object is picked stop.\n      if (!pickInfo.pickedColor) {\n        break;\n      }\n    }\n\n    // reset only affected buffers\n    for (const layerId in affectedLayers) {\n      layers[layerId].restorePickingColors();\n    }\n\n    return {result, emptyInfo: infos && infos.get(null)};\n  }\n\n  // Pick all objects within the given bounding box\n  pickVisibleObjects({layers, viewports, x, y, width, height, mode, onViewportActive}) {\n    this.updatePickingBuffer();\n    // Convert from canvas top-left to WebGL bottom-left coordinates\n    // And compensate for pixelRatio\n    const pixelRatio = cssToDeviceRatio(this.gl);\n    const leftTop = cssToDevicePixels(this.gl, [x, y], true);\n\n    // take left and top (y inverted in device pixels) from start location\n    const deviceLeft = leftTop.x;\n    const deviceTop = leftTop.y + leftTop.height;\n\n    // take right and bottom (y inverted in device pixels) from end location\n    const rightBottom = cssToDevicePixels(this.gl, [x + width, y + height], true);\n    const deviceRight = rightBottom.x + rightBottom.width;\n    const deviceBottom = rightBottom.y;\n\n    const deviceRect = {\n      x: deviceLeft,\n      y: deviceBottom,\n      // deviceTop and deviceRight represent the first pixel outside the desired rect\n      width: deviceRight - deviceLeft,\n      height: deviceTop - deviceBottom\n    };\n\n    const pickedColors = this.drawAndSamplePickingBuffer({\n      layers,\n      viewports,\n      onViewportActive,\n      deviceRect,\n      redrawReason: mode\n    });\n\n    const pickInfos = getUniqueObjects({pickedColors, layers});\n\n    // Only return unique infos, identified by info.object\n    const uniqueInfos = new Map();\n\n    pickInfos.forEach(pickInfo => {\n      let info = {\n        color: pickInfo.pickedColor,\n        layer: null,\n        index: pickInfo.pickedObjectIndex,\n        picked: true,\n        x,\n        y,\n        width,\n        height,\n        pixelRatio\n      };\n\n      info = getLayerPickingInfo({layer: pickInfo.pickedLayer, info, mode});\n      if (!uniqueInfos.has(info.object)) {\n        uniqueInfos.set(info.object, info);\n      }\n    });\n\n    return Array.from(uniqueInfos.values());\n  }\n\n  // returns pickedColor or null if no pickable layers found.\n  drawAndSamplePickingBuffer({layers, viewports, onViewportActive, deviceRect, redrawReason}) {\n    assert(deviceRect);\n    assert(Number.isFinite(deviceRect.width) && deviceRect.width > 0, '`width` must be > 0');\n    assert(Number.isFinite(deviceRect.height) && deviceRect.height > 0, '`height` must be > 0');\n\n    const pickableLayers = layers.filter(layer => layer.isPickable());\n    if (pickableLayers.length < 1) {\n      return null;\n    }\n\n    const pickingFBO = this.pickingFBO;\n    // turn off lighting by adding empty light source object\n    // lights shader module relies on the `lightSources` to turn on/off lighting\n    const effectProps = {lightSources: {}};\n\n    this.pickLayersPass.render({\n      layers,\n      viewports,\n      onViewportActive,\n      pickingFBO,\n      deviceRect,\n      redrawReason,\n      effectProps\n    });\n\n    // Read from an already rendered picking buffer\n    // Returns an Uint8ClampedArray of picked pixels\n    const {x, y, width, height} = deviceRect;\n    const pickedColors = new Uint8Array(width * height * 4);\n    readPixelsToArray(pickingFBO, {\n      sourceX: x,\n      sourceY: y,\n      sourceWidth: width,\n      sourceHeight: height,\n      target: pickedColors\n    });\n    return pickedColors;\n  }\n\n  // Calculate a picking rect centered on deviceX and deviceY and clipped to device\n  // Returns null if pixel is outside of device\n  getPickingRect({deviceX, deviceY, deviceRadius, deviceWidth, deviceHeight}) {\n    // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]\n    const x = Math.max(0, deviceX - deviceRadius);\n    const y = Math.max(0, deviceY - deviceRadius);\n    const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;\n    const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;\n\n    // x, y out of bounds.\n    if (width <= 0 || height <= 0) {\n      return null;\n    }\n\n    return {x, y, width, height};\n  }\n\n  // Per-layer event handlers (e.g. onClick, onHover) are provided by the\n  // user and out of deck.gl's control. It's very much possible that\n  // the user calls React lifecycle methods in these function, such as\n  // ReactComponent.setState(). React lifecycle methods sometimes induce\n  // a re-render and re-generation of props of deck.gl and its layers,\n  // which invalidates all layers currently passed to this very function.\n\n  // Therefore, per-layer event handlers must be invoked at the end\n  // of the picking operation. NO operation that relies on the states of current\n  // layers should be called after this code.\n  callLayerPickingCallbacks(infos, mode) {\n    const unhandledPickInfos = [];\n    const pickingEvent = this.pickingEvent;\n\n    infos.forEach(info => {\n      if (!info.layer) {\n        return;\n      }\n\n      let handled = false;\n      switch (mode) {\n        case 'hover':\n          handled = info.layer.onHover(info, pickingEvent);\n          break;\n        case 'query':\n          break;\n        default:\n          throw new Error('unknown pick type');\n      }\n\n      if (!handled) {\n        unhandledPickInfos.push(info);\n      }\n    });\n\n    return unhandledPickInfos;\n  }\n}\n"],"file":"deck-picker.js"}