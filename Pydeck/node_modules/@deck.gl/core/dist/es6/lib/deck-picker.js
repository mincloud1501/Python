import { Framebuffer, readPixelsToArray, cssToDeviceRatio, cssToDevicePixels } from '@luma.gl/core';
import assert from '../utils/assert';
import PickLayersPass from '../passes/pick-layers-pass';
import { getClosestObject, getUniqueObjects } from './picking/query-object';
import { processPickInfo, getLayerPickingInfo } from './picking/pick-info';
export default class DeckPicker {
  constructor(gl) {
    this.gl = gl;
    this.pickingFBO = null;
    this.pickLayersPass = new PickLayersPass(gl);
    this.layerFilter = null;
    this.pickingEvent = null;
    this.lastPickedInfo = {
      index: -1,
      layerId: null,
      info: null
    };
  }

  setProps(props) {
    if ('layerFilter' in props) {
      this.layerFilter = props.layerFilter;
    }

    this.pickLayersPass.setProps({
      layerFilter: this.layerFilter
    });
  }

  pickObject({
    x,
    y,
    mode,
    radius = 0,
    layers,
    viewports,
    activateViewport,
    depth = 1,
    event = null
  }) {
    this.pickingEvent = event;
    const result = this.pickClosestObject({
      x,
      y,
      radius,
      layers,
      mode,
      depth,
      viewports,
      onViewportActive: activateViewport
    });
    this.pickingEvent = null;
    return result;
  }

  pickObjects({
    x,
    y,
    width,
    height,
    layers,
    viewports,
    activateViewport
  }) {
    return this.pickVisibleObjects({
      x,
      y,
      width,
      height,
      layers,
      mode: 'pickObjects',
      viewports,
      onViewportActive: activateViewport
    });
  }

  getLastPickedObject({
    x,
    y,
    layers,
    viewports
  }, lastPickedInfo = this.lastPickedInfo.info) {
    const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;
    const layer = lastPickedLayerId ? layers.find(l => l.id === lastPickedLayerId) : null;
    const coordinate = viewports[0] && viewports[0].unproject([x, y]);
    const info = {
      x,
      y,
      coordinate,
      lngLat: coordinate,
      layer
    };

    if (layer) {
      return Object.assign({}, lastPickedInfo, info);
    }

    return Object.assign(info, {
      color: null,
      object: null,
      index: -1
    });
  }

  updatePickingBuffer() {
    const {
      gl
    } = this;

    if (!this.pickingFBO) {
      this.pickingFBO = new Framebuffer(gl);
    }

    this.pickingFBO.resize({
      width: gl.canvas.width,
      height: gl.canvas.height
    });
    return this.pickingFBO;
  }

  pickClosestObject({
    layers,
    viewports,
    x,
    y,
    radius,
    depth = 1,
    mode,
    onViewportActive
  }) {
    this.updatePickingBuffer();
    const pixelRatio = cssToDeviceRatio(this.gl);
    const devicePixelRange = cssToDevicePixels(this.gl, [x, y], true);
    const devicePixel = [devicePixelRange.x + Math.floor(devicePixelRange.width / 2), devicePixelRange.y + Math.floor(devicePixelRange.height / 2)];
    const deviceRadius = Math.round(radius * pixelRatio);
    const {
      width,
      height
    } = this.pickingFBO;
    const deviceRect = this.getPickingRect({
      deviceX: devicePixel[0],
      deviceY: devicePixel[1],
      deviceRadius,
      deviceWidth: width,
      deviceHeight: height
    });
    let infos;
    const result = [];
    const affectedLayers = {};

    for (let i = 0; i < depth; i++) {
      const pickedColors = deviceRect && this.drawAndSamplePickingBuffer({
        layers,
        viewports,
        onViewportActive,
        deviceRect,
        redrawReason: mode
      });
      const pickInfo = getClosestObject({
        pickedColors,
        layers,
        deviceX: devicePixel[0],
        deviceY: devicePixel[1],
        deviceRadius,
        deviceRect
      });

      if (pickInfo.pickedColor && i + 1 < depth) {
        const layerId = pickInfo.pickedColor[3] - 1;
        affectedLayers[layerId] = true;
        layers[layerId].clearPickingColor(pickInfo.pickedColor);
      }

      infos = processPickInfo({
        pickInfo,
        lastPickedInfo: this.lastPickedInfo,
        mode,
        layers,
        viewports,
        x,
        y,
        deviceX: devicePixel[0],
        deviceY: devicePixel[1],
        pixelRatio
      });
      const processedPickInfos = this.callLayerPickingCallbacks(infos, mode);

      if (processedPickInfos) {
        processedPickInfos.forEach(info => result.push(info));
      }

      if (!pickInfo.pickedColor) {
        break;
      }
    }

    for (const layerId in affectedLayers) {
      layers[layerId].restorePickingColors();
    }

    return {
      result,
      emptyInfo: infos && infos.get(null)
    };
  }

  pickVisibleObjects({
    layers,
    viewports,
    x,
    y,
    width,
    height,
    mode,
    onViewportActive
  }) {
    this.updatePickingBuffer();
    const pixelRatio = cssToDeviceRatio(this.gl);
    const leftTop = cssToDevicePixels(this.gl, [x, y], true);
    const deviceLeft = leftTop.x;
    const deviceTop = leftTop.y + leftTop.height;
    const rightBottom = cssToDevicePixels(this.gl, [x + width, y + height], true);
    const deviceRight = rightBottom.x + rightBottom.width;
    const deviceBottom = rightBottom.y;
    const deviceRect = {
      x: deviceLeft,
      y: deviceBottom,
      width: deviceRight - deviceLeft,
      height: deviceTop - deviceBottom
    };
    const pickedColors = this.drawAndSamplePickingBuffer({
      layers,
      viewports,
      onViewportActive,
      deviceRect,
      redrawReason: mode
    });
    const pickInfos = getUniqueObjects({
      pickedColors,
      layers
    });
    const uniqueInfos = new Map();
    pickInfos.forEach(pickInfo => {
      let info = {
        color: pickInfo.pickedColor,
        layer: null,
        index: pickInfo.pickedObjectIndex,
        picked: true,
        x,
        y,
        width,
        height,
        pixelRatio
      };
      info = getLayerPickingInfo({
        layer: pickInfo.pickedLayer,
        info,
        mode
      });

      if (!uniqueInfos.has(info.object)) {
        uniqueInfos.set(info.object, info);
      }
    });
    return Array.from(uniqueInfos.values());
  }

  drawAndSamplePickingBuffer({
    layers,
    viewports,
    onViewportActive,
    deviceRect,
    redrawReason
  }) {
    assert(deviceRect);
    assert(Number.isFinite(deviceRect.width) && deviceRect.width > 0, '`width` must be > 0');
    assert(Number.isFinite(deviceRect.height) && deviceRect.height > 0, '`height` must be > 0');
    const pickableLayers = layers.filter(layer => layer.isPickable());

    if (pickableLayers.length < 1) {
      return null;
    }

    const pickingFBO = this.pickingFBO;
    const effectProps = {
      lightSources: {}
    };
    this.pickLayersPass.render({
      layers,
      viewports,
      onViewportActive,
      pickingFBO,
      deviceRect,
      redrawReason,
      effectProps
    });
    const {
      x,
      y,
      width,
      height
    } = deviceRect;
    const pickedColors = new Uint8Array(width * height * 4);
    readPixelsToArray(pickingFBO, {
      sourceX: x,
      sourceY: y,
      sourceWidth: width,
      sourceHeight: height,
      target: pickedColors
    });
    return pickedColors;
  }

  getPickingRect({
    deviceX,
    deviceY,
    deviceRadius,
    deviceWidth,
    deviceHeight
  }) {
    const x = Math.max(0, deviceX - deviceRadius);
    const y = Math.max(0, deviceY - deviceRadius);
    const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;
    const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;

    if (width <= 0 || height <= 0) {
      return null;
    }

    return {
      x,
      y,
      width,
      height
    };
  }

  callLayerPickingCallbacks(infos, mode) {
    const unhandledPickInfos = [];
    const pickingEvent = this.pickingEvent;
    infos.forEach(info => {
      if (!info.layer) {
        return;
      }

      let handled = false;

      switch (mode) {
        case 'hover':
          handled = info.layer.onHover(info, pickingEvent);
          break;

        case 'query':
          break;

        default:
          throw new Error('unknown pick type');
      }

      if (!handled) {
        unhandledPickInfos.push(info);
      }
    });
    return unhandledPickInfos;
  }

}
//# sourceMappingURL=deck-picker.js.map