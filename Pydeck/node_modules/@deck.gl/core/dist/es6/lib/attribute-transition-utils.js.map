{"version":3,"sources":["../../../src/lib/attribute-transition-utils.js"],"names":["BaseAttribute","padArray","DEFAULT_TRANSITION_SETTINGS","interpolation","duration","easing","t","spring","stiffness","damping","normalizeTransitionSettings","userSettings","layerSettings","Number","isFinite","type","Object","assign","getSourceBufferAttribute","gl","attribute","size","value","normalized","constant","buffer","getBuffer","divisor","getAttributeTypeFromSize","Error","cycleBuffers","buffers","push","shift","getAttributeBufferLength","numInstances","doublePrecision","userData","multiplier","noAlloc","length","padBuffer","fromLength","fromBufferLayout","getData","x","precisionMultiplier","offset","elementOffset","toBufferLayout","bufferLayout","hasBufferLayout","toLength","toData","getValue","getter","chunk","_normalizeConstant","getMissingData","i","subarray","source","data","Float32Array","target","sourceLayout","targetLayout","setData"],"mappings":"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","sourcesContent":["import BaseAttribute from '../lib/base-attribute';\nimport {padArray} from '../utils/array-utils';\n\nconst DEFAULT_TRANSITION_SETTINGS = {\n  interpolation: {\n    duration: 0,\n    easing: t => t\n  },\n  spring: {\n    stiffness: 0.05,\n    damping: 0.5\n  }\n};\n\nexport function normalizeTransitionSettings(userSettings, layerSettings) {\n  if (!userSettings) {\n    return null;\n  }\n  if (Number.isFinite(userSettings)) {\n    userSettings = {duration: userSettings};\n  }\n  userSettings.type = userSettings.type || 'interpolation';\n  return Object.assign(\n    {},\n    DEFAULT_TRANSITION_SETTINGS[userSettings.type],\n    layerSettings,\n    userSettings\n  );\n}\n\n// NOTE: NOT COPYING OVER OFFSET OR STRIDE HERE BECAUSE:\n// (1) WE DON'T SUPPORT INTERLEAVED BUFFERS FOR TRANSITIONS\n// (2) BUFFERS WITH OFFSETS ALWAYS CONTAIN VALUES OF THE SAME SIZE\n// (3) THE OPERATIONS IN THE SHADER ARE PER-COMPONENT (addition and scaling)\nexport function getSourceBufferAttribute(gl, attribute) {\n  const {size, value, normalized, constant} = attribute;\n  // The Attribute we pass to Transform as a sourceBuffer must have {divisor: 0}\n  // so we create a copy of the attribute (with divisor=0) to use when running\n  // transform feedback\n  if (constant) {\n    // don't pass normalized here because the `value` from a normalized attribute is\n    // already normalized\n    return new BaseAttribute(gl, {constant, value, size});\n  }\n  const buffer = attribute.getBuffer();\n  return new BaseAttribute(gl, {divisor: 0, constant, buffer, size, normalized});\n}\n\nexport function getAttributeTypeFromSize(size) {\n  switch (size) {\n    case 1:\n      return 'float';\n    case 2:\n      return 'vec2';\n    case 3:\n      return 'vec3';\n    case 4:\n      return 'vec4';\n    default:\n      throw new Error(`No defined attribute type for size \"${size}\"`);\n  }\n}\n\nexport function cycleBuffers(buffers) {\n  buffers.push(buffers.shift());\n}\n\nexport function getAttributeBufferLength(attribute, numInstances) {\n  const {doublePrecision, userData, value, size} = attribute;\n  const multiplier = doublePrecision ? 2 : 1;\n  return (userData.noAlloc ? value.length : numInstances * size) * multiplier;\n}\n\n// This helper is used when transitioning attributes from a set of values in one buffer layout\n// to a set of values in a different buffer layout. (Buffer layouts are used when attribute values\n// within a buffer should be grouped for drawElements, like the Polygon layer.) For example, a\n// buffer layout of [3, 4] might have data [A1, A2, A3, B1, B2, B3, B4]. If it needs to transition\n// to a buffer layout of [4, 2], it should produce a buffer, using the transition setting's `enter`\n// function, that looks like this: [A1, A2, A3, A4 (user `enter` fn), B1, B2, 0]. Note: the final\n// 0 in this buffer is because we never shrink buffers, only grow them, for performance reasons.\nexport function padBuffer({\n  buffer,\n  numInstances,\n  attribute,\n  fromLength,\n  fromBufferLayout,\n  getData = x => x\n}) {\n  // TODO: move the precisionMultiplier logic to the attribute when retrieving\n  // its `size` and `elementOffset`?\n  const precisionMultiplier = attribute.doublePrecision ? 2 : 1;\n  const size = attribute.size * precisionMultiplier;\n  const offset = attribute.elementOffset * precisionMultiplier;\n  const toBufferLayout = attribute.bufferLayout;\n  const hasBufferLayout = fromBufferLayout && toBufferLayout;\n  const toLength = getAttributeBufferLength(attribute, numInstances);\n\n  // check if buffer needs to be padded\n  if (!hasBufferLayout && fromLength >= toLength) {\n    return;\n  }\n\n  const toData = attribute.constant ? attribute.getValue() : attribute.getBuffer().getData({});\n  if (attribute.normalized) {\n    const getter = getData;\n    getData = (value, chunk) => attribute._normalizeConstant(getter(value, chunk));\n  }\n\n  const getMissingData = attribute.constant\n    ? (i, chunk) => getData(toData, chunk)\n    : (i, chunk) => getData(toData.subarray(i, i + size), chunk);\n\n  const source = buffer.getData({length: fromLength});\n  const data = new Float32Array(toLength);\n  padArray({\n    source,\n    target: data,\n    sourceLayout: fromBufferLayout,\n    targetLayout: toBufferLayout,\n    offset,\n    size,\n    getData: getMissingData\n  });\n\n  buffer.setData({data});\n}\n"],"file":"attribute-transition-utils.js"}