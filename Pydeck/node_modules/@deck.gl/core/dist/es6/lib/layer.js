import { COORDINATE_SYSTEM } from './constants';
import AttributeManager from './attribute-manager';
import { removeLayerInSeer } from './seer-integration';
import UniformTransitionManager from './uniform-transition-manager';
import { diffProps, validateProps } from '../lifecycle/props';
import { count } from '../utils/count';
import log from '../utils/log';
import { withParameters } from '@luma.gl/core';
import assert from '../utils/assert';
import { mergeShaders } from '../utils/shader';
import { projectPosition, getWorldPosition } from '../shaderlib/project/project-functions';
import Component from '../lifecycle/component';
import LayerState from './layer-state';
import { worldToPixels } from 'viewport-mercator-project';
import { load } from '@loaders.gl/core';
const LOG_PRIORITY_UPDATE = 1;
const EMPTY_ARRAY = Object.freeze([]);
let pickingColorCache = new Uint8ClampedArray(0);
const defaultProps = {
  data: {
    type: 'data',
    value: EMPTY_ARRAY,
    async: true
  },
  dataComparator: null,
  _dataDiff: {
    type: 'function',
    value: data => data && data.__diff,
    compare: false,
    optional: true
  },
  dataTransform: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  onDataLoad: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  fetch: {
    type: 'function',
    value: (url, {
      layer
    }) => load(url, layer.getLoadOptions()),
    compare: false
  },
  updateTriggers: {},
  numInstances: undefined,
  visible: true,
  pickable: false,
  opacity: {
    type: 'number',
    min: 0,
    max: 1,
    value: 0.8
  },
  onHover: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  onClick: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  onDragStart: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  onDrag: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  onDragEnd: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
  coordinateOrigin: {
    type: 'array',
    value: [0, 0, 0],
    compare: true
  },
  modelMatrix: {
    type: 'array',
    value: null,
    compare: true,
    optional: true
  },
  wrapLongitude: false,
  positionFormat: 'XYZ',
  colorFormat: 'RGBA',
  parameters: {},
  uniforms: {},
  extensions: [],
  framebuffer: null,
  animation: null,
  getPolygonOffset: {
    type: 'function',
    value: ({
      layerIndex
    }) => [0, -layerIndex * 100],
    compare: false
  },
  highlightedObjectIndex: null,
  autoHighlight: false,
  highlightColor: {
    type: 'color',
    value: [0, 0, 128, 128]
  }
};
export default class Layer extends Component {
  toString() {
    const className = this.constructor.layerName || this.constructor.name;
    return "".concat(className, "({id: '").concat(this.props.id, "'})");
  }

  setState(updateObject) {
    this.setChangeFlags({
      stateChanged: true
    });
    Object.assign(this.state, updateObject);
    this.setNeedsRedraw();
  }

  setNeedsRedraw(redraw = true) {
    if (this.internalState) {
      this.internalState.needsRedraw = redraw;
    }
  }

  setNeedsUpdate() {
    this.context.layerManager.setNeedsUpdate(String(this));
    this.internalState.needsUpdate = true;
  }

  getNeedsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    return this._getNeedsRedraw(opts);
  }

  needsUpdate() {
    return this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams());
  }

  hasUniformTransition() {
    return this.internalState.uniformTransitions.active;
  }

  isPickable() {
    return this.props.pickable && this.props.visible;
  }

  getModels() {
    return this.state && (this.state.models || (this.state.model ? [this.state.model] : []));
  }

  getSingleModel() {
    return this.state && this.state.model;
  }

  getAttributeManager() {
    return this.internalState && this.internalState.attributeManager;
  }

  getCurrentLayer() {
    return this.internalState && this.internalState.layer;
  }

  getLoadOptions() {
    return this.props.loadOptions;
  }

  getFirstObject() {
    const {
      data
    } = this.props;

    for (const object of data) {
      return object;
    }

    return null;
  }

  project(xyz) {
    const {
      viewport
    } = this.context;
    const worldPosition = getWorldPosition(xyz, {
      viewport,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem
    });
    const [x, y, z] = worldToPixels(worldPosition, viewport.pixelProjectionMatrix);
    return xyz.length === 2 ? [x, y] : [x, y, z];
  }

  unproject(xy) {
    const {
      viewport
    } = this.context;
    assert(Array.isArray(xy));
    return viewport.unproject(xy);
  }

  projectPosition(xyz) {
    assert(Array.isArray(xyz));
    return projectPosition(xyz, {
      viewport: this.context.viewport,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem
    });
  }

  projectFlat(lngLat) {
    log.deprecated('layer.projectFlat', 'layer.projectPosition')();
    const {
      viewport
    } = this.context;
    assert(Array.isArray(lngLat));
    return viewport.projectFlat(lngLat);
  }

  unprojectFlat(xy) {
    log.deprecated('layer.unprojectFlat')();
    const {
      viewport
    } = this.context;
    assert(Array.isArray(xy));
    return viewport.unprojectFlat(xy);
  }

  use64bitPositions() {
    return this.props.coordinateSystem === COORDINATE_SYSTEM.LNGLAT || this.props.coordinateSystem === COORDINATE_SYSTEM.IDENTITY;
  }

  onHover(info, pickingEvent) {
    if (this.props.onHover) {
      return this.props.onHover(info, pickingEvent);
    }

    return false;
  }

  onClick(info, pickingEvent) {
    if (this.props.onClick) {
      return this.props.onClick(info, pickingEvent);
    }

    return false;
  }

  nullPickingColor() {
    return [0, 0, 0];
  }

  encodePickingColor(i, target = []) {
    assert(i < 16777215, 'index out of picking color range');
    target[0] = i + 1 & 255;
    target[1] = i + 1 >> 8 & 255;
    target[2] = i + 1 >> 8 >> 8 & 255;
    return target;
  }

  decodePickingColor(color) {
    assert(color instanceof Uint8Array);
    const [i1, i2, i3] = color;
    const index = i1 + i2 * 256 + i3 * 65536 - 1;
    return index;
  }

  initializeState() {
    throw new Error("Layer ".concat(this, " has not defined initializeState"));
  }

  getShaders(shaders) {
    for (const extension of this.props.extensions) {
      shaders = mergeShaders(shaders, extension.getShaders.call(this, extension));
    }

    return shaders;
  }

  shouldUpdateState({
    oldProps,
    props,
    context,
    changeFlags
  }) {
    return changeFlags.propsOrDataChanged;
  }

  updateState({
    oldProps,
    props,
    context,
    changeFlags
  }) {
    const attributeManager = this.getAttributeManager();

    if (changeFlags.dataChanged && attributeManager) {
      const {
        dataChanged
      } = changeFlags;

      if (Array.isArray(dataChanged)) {
        for (const dataRange of dataChanged) {
          attributeManager.invalidateAll(dataRange);
        }
      } else {
        attributeManager.invalidateAll();
      }
    }
  }

  finalizeState() {
    for (const model of this.getModels()) {
      model.delete();
    }

    const attributeManager = this.getAttributeManager();

    if (attributeManager) {
      attributeManager.finalize();
    }

    this.internalState.uniformTransitions.clear();
  }

  draw(opts) {
    for (const model of this.getModels()) {
      model.draw(opts);
    }
  }

  getPickingInfo({
    info,
    mode
  }) {
    const {
      index
    } = info;

    if (index >= 0) {
      if (Array.isArray(this.props.data)) {
        info.object = this.props.data[index];
      }
    }

    return info;
  }

  invalidateAttribute(name = 'all', diffReason = '') {
    const attributeManager = this.getAttributeManager();

    if (!attributeManager) {
      return;
    }

    if (name === 'all') {
      log.log(LOG_PRIORITY_UPDATE, "updateTriggers invalidating all attributes: ".concat(diffReason))();
      attributeManager.invalidateAll();
    } else {
      log.log(LOG_PRIORITY_UPDATE, "updateTriggers invalidating attribute ".concat(name, ": ").concat(diffReason))();
      attributeManager.invalidate(name);
    }
  }

  updateAttributes(changedAttributes) {
    for (const model of this.getModels()) {
      this._setModelAttributes(model, changedAttributes);
    }
  }

  _updateAttributes(props) {
    const attributeManager = this.getAttributeManager();

    if (!attributeManager) {
      return;
    }

    const numInstances = this.getNumInstances(props);
    const bufferLayout = this.getBufferLayout(props);
    attributeManager.update({
      data: props.data,
      numInstances,
      bufferLayout,
      props,
      transitions: props.transitions,
      buffers: props,
      context: this,
      ignoreUnknownAttributes: true
    });
    const changedAttributes = attributeManager.getChangedAttributes({
      clearChangedFlags: true
    });
    this.updateAttributes(changedAttributes);
  }

  _updateAttributeTransition() {
    const attributeManager = this.getAttributeManager();

    if (attributeManager) {
      attributeManager.updateTransition();
    }
  }

  _updateUniformTransition() {
    const {
      uniformTransitions
    } = this.internalState;

    if (uniformTransitions.active) {
      const propsInTransition = uniformTransitions.update();
      const props = Object.create(this.props);

      for (const key in propsInTransition) {
        Object.defineProperty(props, key, {
          value: propsInTransition[key]
        });
      }

      return props;
    }

    return this.props;
  }

  calculateInstancePickingColors(attribute, {
    numInstances,
    startRow,
    endRow
  }) {
    const {
      value,
      size
    } = attribute;
    const cacheSize = pickingColorCache.length / size;

    if (cacheSize < numInstances) {
      const newPickingColorCache = new Uint8ClampedArray(numInstances * size);
      newPickingColorCache.set(pickingColorCache);
      const pickingColor = [];

      for (let i = cacheSize; i < numInstances; i++) {
        this.encodePickingColor(i, pickingColor);
        newPickingColorCache[i * size + 0] = pickingColor[0];
        newPickingColorCache[i * size + 1] = pickingColor[1];
        newPickingColorCache[i * size + 2] = pickingColor[2];
      }

      pickingColorCache = newPickingColorCache;
    }

    endRow = Math.min(endRow, numInstances);
    value.set(pickingColorCache.subarray(startRow * size, endRow * size), startRow * size);
  }

  _setModelAttributes(model, changedAttributes) {
    const shaderAttributes = {};
    const excludeAttributes = model.userData.excludeAttributes || {};

    for (const attributeName in changedAttributes) {
      if (!excludeAttributes[attributeName]) {
        Object.assign(shaderAttributes, changedAttributes[attributeName].getShaderAttributes());
      }
    }

    model.setAttributes(shaderAttributes);
  }

  clearPickingColor(color) {
    const {
      pickingColors,
      instancePickingColors
    } = this.getAttributeManager().attributes;
    const colors = pickingColors || instancePickingColors;
    const i = this.decodePickingColor(color);
    const start = colors.getVertexOffset(i);
    const end = colors.getVertexOffset(i + 1);
    colors.buffer.subData({
      data: new Uint8Array(end - start),
      offset: start
    });
  }

  restorePickingColors() {
    const {
      pickingColors,
      instancePickingColors
    } = this.getAttributeManager().attributes;
    const colors = pickingColors || instancePickingColors;
    colors.update({
      value: colors.value
    });
  }

  getNumInstances(props) {
    props = props || this.props;

    if (props.numInstances !== undefined) {
      return props.numInstances;
    }

    if (this.state && this.state.numInstances !== undefined) {
      return this.state.numInstances;
    }

    const {
      data
    } = this.props;
    return count(data);
  }

  getBufferLayout(props) {
    props = props || this.props;

    if (props.bufferLayout !== undefined) {
      return props.bufferLayout;
    }

    if (this.state && this.state.bufferLayout !== undefined) {
      return this.state.bufferLayout;
    }

    return null;
  }

  _initialize() {
    this._initState();

    this.initializeState(this.context);

    for (const extension of this.props.extensions) {
      extension.initializeState.call(this, this.context, extension);
    }

    this.state.attributeManager = this.getAttributeManager();
    this.setChangeFlags({
      dataChanged: true,
      propsChanged: true,
      viewportChanged: true,
      extensionsChanged: true
    });

    this._updateState();

    const model = this.getSingleModel();

    if (model) {
      model.id = this.props.id;
      model.program.id = "".concat(this.props.id, "-program");
    }
  }

  _update() {
    const stateNeedsUpdate = this.needsUpdate();

    if (stateNeedsUpdate) {
      this._updateState();
    }
  }

  _updateState() {
    const currentProps = this.props;

    const propsInTransition = this._updateUniformTransition();

    this.internalState.propsInTransition = propsInTransition;
    this.props = propsInTransition;

    const updateParams = this._getUpdateParams();

    if (this.context.gl) {
      this.updateState(updateParams);
    } else {
      try {
        this.updateState(updateParams);
      } catch (error) {}
    }

    for (const extension of this.props.extensions) {
      extension.updateState.call(this, updateParams, extension);
    }

    if (this.isComposite) {
      this._renderLayers(updateParams);
    } else {
      this.setNeedsRedraw();

      this._updateAttributes(this.props);

      if (this.state.model) {
        this.state.model.setInstanceCount(this.getNumInstances());
      }
    }

    this.props = currentProps;
    this.clearChangeFlags();
    this.internalState.needsUpdate = false;
    this.internalState.resetOldProps();
  }

  _finalize() {
    assert(this.internalState && this.state);
    this.finalizeState(this.context);

    for (const extension of this.props.extensions) {
      extension.finalizeState.call(this, extension);
    }

    removeLayerInSeer(this.id);
  }

  drawLayer({
    moduleParameters = null,
    uniforms = {},
    parameters = {}
  }) {
    this._updateAttributeTransition();

    const currentProps = this.props;
    this.props = this.internalState.propsInTransition;
    const {
      opacity
    } = this.props;
    uniforms.opacity = Math.pow(opacity, 1 / 2.2);

    if (moduleParameters) {
      this.setModuleParameters(moduleParameters);
    }

    const {
      getPolygonOffset
    } = this.props;
    const offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];
    parameters.polygonOffset = offsets;
    withParameters(this.context.gl, parameters, () => {
      this.draw({
        moduleParameters,
        uniforms,
        parameters,
        context: this.context
      });
    });
    this.props = currentProps;
  }

  pickLayer(opts) {
    return this.getPickingInfo(opts);
  }

  getChangeFlags() {
    return this.internalState.changeFlags;
  }

  setChangeFlags(flags) {
    this.internalState.changeFlags = this.internalState.changeFlags || {};
    const changeFlags = this.internalState.changeFlags;

    if (flags.dataChanged && !changeFlags.dataChanged) {
      changeFlags.dataChanged = flags.dataChanged;
      log.log(LOG_PRIORITY_UPDATE + 1, () => "dataChanged: ".concat(flags.dataChanged, " in ").concat(this.id))();
    }

    if (flags.updateTriggersChanged && !changeFlags.updateTriggersChanged) {
      changeFlags.updateTriggersChanged = changeFlags.updateTriggersChanged && flags.updateTriggersChanged ? Object.assign({}, flags.updateTriggersChanged, changeFlags.updateTriggersChanged) : flags.updateTriggersChanged || changeFlags.updateTriggersChanged;
      log.log(LOG_PRIORITY_UPDATE + 1, () => 'updateTriggersChanged: ' + "".concat(Object.keys(flags.updateTriggersChanged).join(', '), " in ").concat(this.id))();
    }

    if (flags.propsChanged && !changeFlags.propsChanged) {
      changeFlags.propsChanged = flags.propsChanged;
      log.log(LOG_PRIORITY_UPDATE + 1, () => "propsChanged: ".concat(flags.propsChanged, " in ").concat(this.id))();
    }

    if (flags.extensionsChanged && !changeFlags.extensionsChanged) {
      changeFlags.extensionsChanged = flags.extensionsChanged;
      log.log(LOG_PRIORITY_UPDATE + 1, () => "extensionsChanged: ".concat(flags.extensionsChanged, " in ").concat(this.id))();
    }

    if (flags.viewportChanged && !changeFlags.viewportChanged) {
      changeFlags.viewportChanged = flags.viewportChanged;
      log.log(LOG_PRIORITY_UPDATE + 2, () => "viewportChanged: ".concat(flags.viewportChanged, " in ").concat(this.id))();
    }

    if (flags.stateChanged && !changeFlags.stateChanged) {
      changeFlags.stateChanged = flags.stateChanged;
      log.log(LOG_PRIORITY_UPDATE + 1, () => "stateChanged: ".concat(flags.stateChanged, " in ").concat(this.id))();
    }

    const propsOrDataChanged = flags.dataChanged || flags.updateTriggersChanged || flags.propsChanged || flags.extensionsChanged;
    changeFlags.propsOrDataChanged = changeFlags.propsOrDataChanged || propsOrDataChanged;
    changeFlags.somethingChanged = changeFlags.somethingChanged || propsOrDataChanged || flags.viewportChanged || flags.stateChanged;
  }

  clearChangeFlags() {
    this.internalState.changeFlags = {
      dataChanged: false,
      propsChanged: false,
      updateTriggersChanged: false,
      viewportChanged: false,
      stateChanged: false,
      extensionsChanged: false,
      propsOrDataChanged: false,
      somethingChanged: false
    };
  }

  printChangeFlags() {
    const flags = this.internalState.changeFlags;
    return "".concat(flags.dataChanged ? 'data ' : '').concat(flags.propsChanged ? 'props ' : '').concat(flags.updateTriggersChanged ? 'triggers ' : '').concat(flags.viewportChanged ? 'viewport' : '');
  }

  diffProps(newProps, oldProps) {
    const changeFlags = diffProps(newProps, oldProps);

    if (changeFlags.updateTriggersChanged) {
      for (const key in changeFlags.updateTriggersChanged) {
        if (changeFlags.updateTriggersChanged[key]) {
          this._activeUpdateTrigger(key);
        }
      }
    }

    if (changeFlags.transitionsChanged) {
      for (const key in changeFlags.transitionsChanged) {
        this.internalState.uniformTransitions.add(key, oldProps[key], newProps[key], newProps.transitions[key]);
      }
    }

    return this.setChangeFlags(changeFlags);
  }

  validateProps() {
    validateProps(this.props);
  }

  setModuleParameters(moduleParameters) {
    for (const model of this.getModels()) {
      model.updateModuleSettings(moduleParameters);
    }
  }

  _getUpdateParams() {
    return {
      props: this.props,
      oldProps: this.internalState.getOldProps(),
      context: this.context,
      changeFlags: this.internalState.changeFlags
    };
  }

  _getNeedsRedraw(opts) {
    if (!this.internalState) {
      return false;
    }

    let redraw = false;
    redraw = redraw || this.internalState.needsRedraw && this.id;
    this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;
    const attributeManager = this.getAttributeManager();
    const attributeManagerNeedsRedraw = attributeManager && attributeManager.getNeedsRedraw(opts);
    redraw = redraw || attributeManagerNeedsRedraw;
    return redraw;
  }

  _getAttributeManager() {
    return new AttributeManager(this.context.gl, {
      id: this.props.id,
      stats: this.context.stats,
      timeline: this.context.timeline
    });
  }

  _initState() {
    assert(!this.internalState && !this.state);

    const attributeManager = this._getAttributeManager();

    if (attributeManager) {
      attributeManager.addInstanced({
        instancePickingColors: {
          type: 5121,
          size: 3,
          update: this.calculateInstancePickingColors
        }
      });
    }

    this.internalState = new LayerState({
      attributeManager,
      layer: this
    });
    this.state = {};
    this.state.attributeManager = attributeManager;
    this.internalState.uniformTransitions = new UniformTransitionManager(this.context.timeline);
    this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);
    this.internalState.setAsyncProps(this.props);
  }

  _transferState(oldLayer) {
    const {
      state,
      internalState
    } = oldLayer;
    assert(state && internalState);

    if (this === oldLayer) {
      return;
    }

    this.internalState = internalState;
    this.internalState.component = this;
    this.state = state;
    state.layer = this;
    this.internalState.setAsyncProps(this.props);

    for (const model of this.getModels()) {
      model.userData.layer = this;
    }

    this.diffProps(this.props, this.internalState.getOldProps());
  }

  _onAsyncPropUpdated() {
    this.diffProps(this.props, this.internalState.getOldProps());
    this.setNeedsUpdate();
  }

  _activeUpdateTrigger(propName) {
    this.invalidateAttribute(propName);
  }

  setLayerNeedsUpdate() {
    log.deprecated('layer.setLayerNeedsUpdate', 'layer.setNeedsUpdate')();
    this.setNeedsUpdate();
  }

  setUniforms(uniformMap) {
    for (const model of this.getModels()) {
      model.setUniforms(uniformMap);
    }

    this.setNeedsRedraw();
    log.deprecated('layer.setUniforms', 'model.setUniforms')();
  }

  use64bitProjection() {
    log.removed('use64bitProjection', 'Fp64Extension')();
    return false;
  }

}
Layer.layerName = 'Layer';
Layer.defaultProps = defaultProps;
//# sourceMappingURL=layer.js.map