{"version":3,"sources":["../../../src/lifecycle/component-state.js"],"names":["log","assert","isAsyncIterable","EMPTY_PROPS","Object","freeze","ComponentState","component","asyncProps","onAsyncPropUpdated","oldProps","oldAsyncProps","props","create","propName","defineProperty","enumerable","value","asyncProp","resolvedValue","Boolean","pendingLoadCount","resolvedLoadCount","resolvedValues","_asyncPropResolvedValues","originalValues","_asyncPropOriginalValues","defaultValues","_asyncPropDefaultValues","_createAsyncPropData","_updateAsyncProp","_didAsyncInputValueChange","fetch","layer","url","Promise","_watchPromise","_resolveAsyncIterable","_setPropValue","lastValue","loadCount","undefined","freezeAsyncOldProps","promise","then","data","_postProcessValue","_setAsyncPropValue","onDataLoad","error","iterable","count","chunk","startRow","endRow","length","previousValue","dataTransform","concat","defaultValue"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport log from '../utils/log';\nimport assert from '../utils/assert';\nimport {isAsyncIterable} from '../utils/iterable-utils';\n\nconst EMPTY_PROPS = Object.freeze({});\n\nexport default class ComponentState {\n  constructor(component = null) {\n    this.component = component;\n    this.asyncProps = {}; // Prop values that the layer sees\n    this.onAsyncPropUpdated = () => {};\n    this.oldProps = EMPTY_PROPS; // Last props before update\n    this.oldAsyncProps = null; // Last props before update, with async values copied.\n  }\n\n  getOldProps() {\n    return this.oldAsyncProps || this.oldProps;\n  }\n\n  resetOldProps() {\n    this.oldAsyncProps = null;\n    this.oldProps = this.component.props;\n  }\n\n  // Whenever async props are changing, we need to make a copy of oldProps\n  // otherwise the prop rewriting will affect the value both in props and oldProps.\n  // While the copy is relatively expensive, this only happens on load completion.\n  freezeAsyncOldProps() {\n    if (!this.oldAsyncProps) {\n      // Make sure oldProps is set\n      this.oldProps = this.oldProps || this.component.props;\n\n      // 1. inherit all synchronous props from oldProps\n      // 2. reconfigure the async prop descriptors to fixed values\n      this.oldAsyncProps = Object.create(this.oldProps);\n      for (const propName in this.asyncProps) {\n        Object.defineProperty(this.oldAsyncProps, propName, {\n          enumerable: true,\n          value: this.oldProps[propName]\n        });\n      }\n    }\n  }\n\n  // ASYNC PROP HANDLING\n  //\n\n  // Checks if a prop is overridden\n  hasAsyncProp(propName) {\n    return propName in this.asyncProps;\n  }\n\n  // Returns value of an overriden prop\n  getAsyncProp(propName) {\n    const asyncProp = this.asyncProps[propName];\n    return asyncProp && asyncProp.resolvedValue;\n  }\n\n  isAsyncPropLoading(propName) {\n    const asyncProp = this.asyncProps[propName];\n    return Boolean(\n      asyncProp &&\n        asyncProp.pendingLoadCount > 0 &&\n        asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount\n    );\n  }\n\n  // Updates all async/overridden props (when new props come in)\n  // Checks if urls have changed, starts loading, or removes override\n  setAsyncProps(props) {\n    // NOTE: prop param and default values are only support for testing\n    const resolvedValues = props._asyncPropResolvedValues || {};\n    const originalValues = props._asyncPropOriginalValues || props;\n    const defaultValues = props._asyncPropDefaultValues || {};\n\n    // TODO - use async props from the layer's prop types\n    for (const propName in resolvedValues) {\n      const value = resolvedValues[propName];\n      this._createAsyncPropData(propName, value, defaultValues[propName]);\n      this._updateAsyncProp(propName, value);\n    }\n\n    for (const propName in originalValues) {\n      const value = originalValues[propName];\n      // Makes sure a record exists for this prop\n      this._createAsyncPropData(propName, value, defaultValues[propName]);\n      this._updateAsyncProp(propName, value);\n    }\n  }\n\n  // Intercept strings (URLs) and Promises and activates loading and prop rewriting\n  _updateAsyncProp(propName, value) {\n    if (!this._didAsyncInputValueChange(propName, value)) {\n      return;\n    }\n\n    // interpret value string as url and start a new load tracked by a promise\n    if (typeof value === 'string') {\n      const fetch = this.layer && this.layer.props.fetch;\n      const url = value;\n      if (fetch) {\n        value = fetch(url, {propName, layer: this.layer});\n      }\n    }\n\n    // interprets promise and track the \"loading\"\n    if (value instanceof Promise) {\n      this._watchPromise(propName, value);\n      return;\n    }\n\n    if (isAsyncIterable(value)) {\n      this._resolveAsyncIterable(propName, value);\n      return;\n    }\n\n    // else, normal, non-async value. Just store value for now\n    this._setPropValue(propName, value);\n  }\n\n  // Checks if an input value actually changed (to avoid reloading/rewatching promises/urls)\n  _didAsyncInputValueChange(propName, value) {\n    const asyncProp = this.asyncProps[propName];\n    if (value === asyncProp.lastValue) {\n      return false;\n    }\n    asyncProp.lastValue = value;\n    return true;\n  }\n\n  // Set normal, non-async value\n  _setPropValue(propName, value) {\n    const asyncProp = this.asyncProps[propName];\n    asyncProp.value = value;\n    asyncProp.resolvedValue = value;\n    asyncProp.pendingLoadCount++;\n    asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;\n  }\n\n  // Set a just resolved async value, calling onAsyncPropUpdates if value changes asynchronously\n  _setAsyncPropValue(propName, value, loadCount) {\n    // Only update if loadCount is larger or equal to resolvedLoadCount\n    // otherwise a more recent load has already completed\n    const asyncProp = this.asyncProps[propName];\n    if (asyncProp && loadCount >= asyncProp.resolvedLoadCount) {\n      assert(value !== undefined);\n\n      // A chance to copy old props before updating\n      this.freezeAsyncOldProps();\n\n      asyncProp.resolvedValue = value;\n      asyncProp.resolvedLoadCount = loadCount;\n\n      // Call callback to inform listener\n      this.onAsyncPropUpdated(propName, value);\n    }\n  }\n\n  // Tracks a promise, sets the prop when loaded, handles load count\n  _watchPromise(propName, promise) {\n    const asyncProp = this.asyncProps[propName];\n    asyncProp.pendingLoadCount++;\n    const loadCount = asyncProp.pendingLoadCount;\n    promise\n      .then(data => {\n        data = this._postProcessValue(propName, data);\n        this._setAsyncPropValue(propName, data, loadCount);\n\n        const onDataLoad = this.layer && this.layer.props.onDataLoad;\n        if (propName === 'data' && onDataLoad) {\n          onDataLoad(data, {propName, layer: this.layer});\n        }\n      })\n      .catch(error => log.error(error)());\n  }\n\n  async _resolveAsyncIterable(propName, iterable) {\n    if (propName !== 'data') {\n      // we only support data as async iterable\n      this._setPropValue(propName, iterable);\n    }\n\n    const asyncProp = this.asyncProps[propName];\n    asyncProp.pendingLoadCount++;\n    const loadCount = asyncProp.pendingLoadCount;\n    let data = [];\n    let count = 0;\n\n    for await (const chunk of iterable) {\n      data = this._postProcessValue(propName, chunk, data);\n\n      // Used by the default _dataDiff function\n      Object.defineProperty(data, '__diff', {\n        enumerable: false,\n        value: [{startRow: count, endRow: data.length}]\n      });\n\n      count = data.length;\n      this._setAsyncPropValue(propName, data, loadCount);\n    }\n\n    const onDataLoad = this.layer && this.layer.props.onDataLoad;\n    if (onDataLoad) {\n      onDataLoad(data, {propName, layer: this.layer});\n    }\n  }\n\n  // Give the app a chance to post process the loaded data\n  _postProcessValue(propName, value, previousValue) {\n    const {dataTransform} = this.component ? this.component.props : {};\n    if (propName !== 'data') {\n      return value;\n    }\n    if (dataTransform) {\n      return dataTransform(value, previousValue);\n    }\n    // previousValue is assigned if loaded with async iterator\n    return previousValue ? previousValue.concat(value) : value;\n  }\n\n  // Creating an asyncProp record if needed\n  _createAsyncPropData(propName, value, defaultValue) {\n    const asyncProp = this.asyncProps[propName];\n    if (!asyncProp) {\n      // assert(defaultValue !== undefined);\n      this.asyncProps[propName] = {\n        lastValue: null, // Supplied prop value (can be url/promise, not visible to layer)\n        resolvedValue: defaultValue, // Resolved prop value (valid data, can be \"shown\" to layer)\n        pendingLoadCount: 0, // How many loads have been issued\n        resolvedLoadCount: 0 // Latest resolved load, (earlier loads will be ignored)\n      };\n    }\n  }\n}\n"],"file":"component-state.js"}