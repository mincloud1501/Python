{"version":3,"sources":["../../../src/utils/typed-array-manager.js"],"names":["TypedArrayManager","overAlloc","poolSize","_pool","typedArray","count","size","type","padding","copy","Type","constructor","Float32Array","newSize","ArrayBuffer","isView","length","BYTES_PER_ELEMENT","buffer","byteLength","newArray","_allocate","set","fill","_release","Math","max","ceil","pool","i","findIndex","b","splice","push","shift"],"mappings":"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","sourcesContent":["export class TypedArrayManager {\n  constructor({overAlloc = 2, poolSize = 100} = {}) {\n    this.overAlloc = overAlloc;\n    this.poolSize = poolSize;\n\n    this._pool = [];\n  }\n\n  allocate(typedArray, count, {size = 1, type, padding = 0, copy = false}) {\n    const Type = type || (typedArray && typedArray.constructor) || Float32Array;\n\n    const newSize = count * size + padding;\n    if (ArrayBuffer.isView(typedArray)) {\n      if (newSize <= typedArray.length) {\n        return typedArray;\n      }\n      if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {\n        return new Type(typedArray.buffer, 0, newSize);\n      }\n    }\n\n    const newArray = this._allocate(Type, newSize);\n\n    if (typedArray && copy) {\n      newArray.set(typedArray);\n    } else {\n      // Hack - viewing a buffer with a different type may create NaNs\n      // which crashes the Attribute validation\n      newArray.fill(0, 0, 4);\n    }\n\n    this._release(typedArray);\n    return newArray;\n  }\n\n  release(typedArray) {\n    this._release(typedArray);\n  }\n\n  _allocate(Type, size) {\n    // Allocate at least one element to ensure a valid buffer\n    size = Math.max(Math.ceil(size * this.overAlloc), 1);\n\n    // Check if available in pool\n    const pool = this._pool;\n    const byteLength = Type.BYTES_PER_ELEMENT * size;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n    if (i >= 0) {\n      // Create a new array using an existing buffer\n      return new Type(pool.splice(i, 1)[0], 0, size);\n    }\n    return new Type(size);\n  }\n\n  _release(typedArray) {\n    if (!ArrayBuffer.isView(typedArray)) {\n      return;\n    }\n    const pool = this._pool;\n    const {buffer} = typedArray;\n    // Save the buffer of the released array into the pool\n    // Sort buffers by size\n    // TODO - implement binary search?\n    const {byteLength} = buffer;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n    if (i < 0) {\n      pool.push(buffer);\n    } else if (i > 0 || pool.length < this.poolSize) {\n      pool.splice(i, 0, buffer);\n    }\n    if (pool.length > this.poolSize) {\n      // Drop the smallest one\n      pool.shift();\n    }\n  }\n}\n\nexport default new TypedArrayManager();\n"],"file":"typed-array-manager.js"}