{"version":3,"sources":["../../../src/text-layer/utils.js"],"names":["MISSING_CHAR_WIDTH","nextPowOfTwo","number","Math","pow","ceil","log2","buildMapping","characterSet","getFontWidth","fontHeight","buffer","maxCanvasWidth","mapping","xOffset","yOffset","row","x","Array","from","forEach","char","i","width","y","height","mask","rowHeight","canvasHeight","transformRow","iconMapping","lineHeight","offsetLeft","characters","map","character","datum","text","frame","log","warn","rowWidth","transformParagraph","paragraph","transformCharacter","transformedData","rows","split","size","offsetTop","rowSize","push","max"],"mappings":"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","sourcesContent":["// TODO merge with icon-layer/icon-manager\nimport {log} from '@deck.gl/core';\n\nconst MISSING_CHAR_WIDTH = 32;\n\nexport function nextPowOfTwo(number) {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\n\n/**\n * Generate character mapping table or update from an existing mapping table\n * @param characterSet {Array|Set} new characters\n * @param getFontWidth {Function} function to get width of each character\n * @param fontHeight {Number} height of font\n * @param buffer {Number} buffer surround each character\n * @param maxCanvasWidth {Number} max width of font atlas\n * @param mapping {Object} old mapping table\n * @param xOffset {Number} x position of last character in old mapping table\n * @param yOffset {Number} y position of last character in old mapping table\n * @returns {{\n *   mapping: Object,\n *   xOffset: Number, x position of last character\n *   yOffset: Number, y position of last character in old mapping table\n *   canvasHeight: Number, height of the font atlas canvas, power of 2\n *  }}\n */\nexport function buildMapping({\n  characterSet,\n  getFontWidth,\n  fontHeight,\n  buffer,\n  maxCanvasWidth,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0\n}) {\n  let row = 0;\n  // continue from x position of last character in the old mapping\n  let x = xOffset;\n  Array.from(characterSet).forEach((char, i) => {\n    if (!mapping[char]) {\n      // measure texts\n      // TODO - use Advanced text metrics when they are adopted:\n      // https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics\n      const width = getFontWidth(char, i);\n\n      if (x + width + buffer * 2 > maxCanvasWidth) {\n        x = 0;\n        row++;\n      }\n      mapping[char] = {\n        x: x + buffer,\n        y: yOffset + row * (fontHeight + buffer * 2) + buffer,\n        width,\n        height: fontHeight,\n        mask: true\n      };\n      x += width + buffer * 2;\n    }\n  });\n\n  const rowHeight = fontHeight + buffer * 2;\n\n  return {\n    mapping,\n    xOffset: x,\n    yOffset: yOffset + row * rowHeight,\n    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight)\n  };\n}\n\nexport function transformRow(row, iconMapping, lineHeight) {\n  let offsetLeft = 0;\n  let rowHeight = 0;\n\n  let characters = Array.from(row);\n  characters = characters.map((character, i) => {\n    const datum = {\n      text: character,\n      offsetLeft\n    };\n\n    const frame = iconMapping[character];\n\n    if (frame) {\n      offsetLeft += frame.width;\n      if (!rowHeight) {\n        // frame.height should be a constant\n        rowHeight = frame.height * lineHeight;\n      }\n    } else {\n      log.warn(`Missing character: ${character}`)();\n      offsetLeft += MISSING_CHAR_WIDTH;\n    }\n\n    return datum;\n  });\n\n  return {characters, rowWidth: offsetLeft, rowHeight};\n}\n\n/**\n * Transform a text paragraph to an array of characters, each character contains\n * @param paragraph {String}\n * @param lineHeight {Number} css line-height\n * @param iconMapping {Object} character mapping table for retrieving a character from font atlas\n * @param transformCharacter {Function} callback to transform a single character\n * @param transformedData {Array} output transformed data array, each datum contains\n *   - text: character\n *   - index: character index in the paragraph\n *   - offsetLeft: x offset in the row,\n *   - offsetTop: y offset in the paragraph\n *   - size: [width, height] size of the paragraph\n *   - rowSize: [rowWidth, rowHeight] size of the row\n *   - len: length of the paragraph\n */\nexport function transformParagraph(\n  paragraph,\n  lineHeight,\n  iconMapping,\n  transformCharacter,\n  transformedData\n) {\n  const rows = paragraph.split('\\n');\n\n  // width and height of the paragraph\n  const size = [0, 0];\n  let offsetTop = 0;\n\n  rows.forEach(row => {\n    const {characters, rowWidth, rowHeight} = transformRow(row, iconMapping, lineHeight);\n    const rowSize = [rowWidth, rowHeight];\n\n    characters.forEach(datum => {\n      datum.offsetTop = offsetTop;\n      datum.size = size;\n      datum.rowSize = rowSize;\n\n      transformedData.push(transformCharacter(datum));\n    });\n\n    offsetTop = offsetTop + rowHeight;\n    size[0] = Math.max(size[0], rowWidth);\n  });\n\n  // last row\n  size[1] = offsetTop;\n}\n"],"file":"utils.js"}