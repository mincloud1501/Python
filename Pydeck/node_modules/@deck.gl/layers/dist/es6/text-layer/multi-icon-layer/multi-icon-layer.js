import { createIterable } from '@deck.gl/core';
import IconLayer from '../../icon-layer/icon-layer';
import vs from './multi-icon-layer-vertex.glsl';
import fs from './multi-icon-layer-fragment.glsl';
const DEFAULT_GAMMA = 0.2;
const DEFAULT_BUFFER = 192.0 / 256;
const defaultProps = {
  getRowSize: {
    type: 'accessor',
    value: x => x.rowSize || [0, 0]
  },
  getOffsets: {
    type: 'accessor',
    value: x => x.offsets || [0, 0]
  },
  getParagraphSize: {
    type: 'accessor',
    value: x => x.size || [1, 1]
  },
  getAnchorX: {
    type: 'accessor',
    value: x => x.anchorX || 0
  },
  getAnchorY: {
    type: 'accessor',
    value: x => x.anchorY || 0
  },
  getPixelOffset: {
    type: 'accessor',
    value: [0, 0]
  },
  getPickingIndex: {
    type: 'accessor',
    value: x => x.objectIndex
  }
};
export default class MultiIconLayer extends IconLayer {
  getShaders() {
    return Object.assign({}, super.getShaders(), {
      vs,
      fs
    });
  }

  initializeState() {
    super.initializeState();
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceOffsets: {
        size: 2,
        accessor: ['getIcon', 'getAnchorX', 'getAnchorY'],
        update: this.calculateInstanceOffsets
      },
      instancePixelOffset: {
        size: 2,
        transition: true,
        accessor: 'getPixelOffset'
      }
    });
  }

  updateState(updateParams) {
    super.updateState(updateParams);
    const {
      changeFlags
    } = updateParams;

    if (changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.getAnchorX || changeFlags.updateTriggersChanged.getAnchorY)) {
      this.getAttributeManager().invalidate('instanceOffsets');
    }
  }

  draw({
    uniforms
  }) {
    const {
      sdf
    } = this.props;
    super.draw({
      uniforms: Object.assign({}, uniforms, {
        buffer: DEFAULT_BUFFER,
        gamma: DEFAULT_GAMMA,
        sdf: Boolean(sdf)
      })
    });
  }

  calculateInstanceOffsets(attribute, {
    startRow,
    endRow
  }) {
    const {
      data,
      iconMapping,
      getIcon,
      getAnchorX,
      getAnchorY,
      getParagraphSize,
      getRowSize,
      getOffsets
    } = this.props;
    const {
      value,
      size
    } = attribute;
    let i = startRow * size;
    const {
      iterable
    } = createIterable(data, startRow, endRow);

    for (const object of iterable) {
      const icon = getIcon(object);
      const rect = iconMapping[icon] || {};
      const [width, height] = getParagraphSize(object);
      const [rowWidth] = getRowSize(object);
      const [offsetX, offsetY] = getOffsets(object);
      const anchorX = getAnchorX(object);
      const anchorY = getAnchorY(object);
      const rowOffset = (1 - anchorX) * (width - rowWidth) / 2;
      value[i++] = (anchorX - 1) * width / 2 + rowOffset + rect.width / 2 + offsetX || 0;
      value[i++] = (anchorY - 1) * height / 2 + rect.height / 2 + offsetY || 0;
    }
  }

  calculateInstancePickingColors(attribute, {
    startRow,
    endRow
  }) {
    const {
      data,
      getPickingIndex
    } = this.props;
    const {
      value,
      size
    } = attribute;
    let i = startRow * size;
    const pickingColor = [];
    const {
      iterable
    } = createIterable(data, startRow, endRow);

    for (const point of iterable) {
      const index = getPickingIndex(point);
      this.encodePickingColor(index, pickingColor);
      value[i++] = pickingColor[0];
      value[i++] = pickingColor[1];
      value[i++] = pickingColor[2];
    }
  }

}
MultiIconLayer.layerName = 'MultiIconLayer';
MultiIconLayer.defaultProps = defaultProps;
//# sourceMappingURL=multi-icon-layer.js.map