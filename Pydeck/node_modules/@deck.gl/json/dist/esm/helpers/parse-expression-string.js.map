{"version":3,"sources":["../../../src/helpers/parse-expression-string.js"],"names":["get","expressionEval","cachedExpressionMap","object","parseExpressionString","propValue","configuration","isAccessor","func","ast","parse","right","left","type","row","traverse","node","Error","eval","args","visitor","Array","isArray","forEach","element","key"],"mappings":";AAAA,SAAQA,GAAR,QAAkB,cAAlB;AAGA,OAAOC,cAAP,MAA2B,iBAA3B;AAEA,IAAMC,mBAAmB,GAAG;AAC1B,OAAK,WAAAC,MAAM;AAAA,WAAIA,MAAJ;AAAA;AADe,CAA5B;AAOA,eAAe,SAASC,qBAAT,CAA+BC,SAA/B,EAA0CC,aAA1C,EAAyDC,UAAzD,EAAqE;AAElF,MAAIF,SAAS,IAAIH,mBAAjB,EAAsC;AACpC,WAAOA,mBAAmB,CAACG,SAAD,CAA1B;AACD;;AAED,MAAIG,IAAJ;AAEA,MAAMC,GAAG,GAAGR,cAAc,CAACS,KAAf,CAAqBL,SAArB,CAAZ;;AACA,MAAI,CAACI,GAAG,CAACE,KAAL,IAAc,CAACF,GAAG,CAACG,IAAnB,IAA2BH,GAAG,CAACI,IAAJ,KAAa,YAA5C,EAA0D;AACxDL,IAAAA,IAAI,GAAG,cAAAM,GAAG;AAAA,aAAId,GAAG,CAACc,GAAD,EAAMT,SAAN,CAAP;AAAA,KAAV;AACD,GAFD,MAEO;AAILU,IAAAA,QAAQ,CAACN,GAAD,EAAM,UAAAO,IAAI,EAAI;AACpB,UAAIA,IAAI,CAACH,IAAL,KAAc,gBAAlB,EAAoC;AAClC,cAAM,IAAII,KAAJ,CAAU,gDAAV,CAAN;AACD;AACF,KAJO,CAAR;AAKAT,IAAAA,IAAI,GAAGD,UAAU,GACb,UAAAO,GAAG;AAAA,aAAIb,cAAc,CAACiB,IAAf,CAAoBT,GAApB,EAAyBK,GAAzB,CAAJ;AAAA,KADU,GAGb,UAAAK,IAAI;AAAA,aAAIlB,cAAc,CAACiB,IAAf,CAAoBT,GAApB,EAAyB;AAACU,QAAAA,IAAI,EAAJA;AAAD,OAAzB,CAAJ;AAAA,KAHR;AAID;;AAGDjB,EAAAA,mBAAmB,CAACG,SAAD,CAAnB,GAAiCG,IAAjC;AACA,SAAOA,IAAP;AACD;;AAID,SAASO,QAAT,CAAkBC,IAAlB,EAAwBI,OAAxB,EAAiC;AAC/B,MAAIC,KAAK,CAACC,OAAN,CAAcN,IAAd,CAAJ,EAAyB;AACvBA,IAAAA,IAAI,CAACO,OAAL,CAAa,UAAAC,OAAO;AAAA,aAAIT,QAAQ,CAACS,OAAD,EAAUJ,OAAV,CAAZ;AAAA,KAApB;AACD,GAFD,MAEO,IAAIJ,IAAI,IAAI,QAAOA,IAAP,MAAgB,QAA5B,EAAsC;AAC3C,QAAIA,IAAI,CAACH,IAAT,EAAe;AACbO,MAAAA,OAAO,CAACJ,IAAD,CAAP;AACD;;AACD,SAAK,IAAMS,GAAX,IAAkBT,IAAlB,EAAwB;AACtBD,MAAAA,QAAQ,CAACC,IAAI,CAACS,GAAD,CAAL,EAAYL,OAAZ,CAAR;AACD;AACF;AACF","sourcesContent":["import {get} from '../utils/get';\n\n// expression-eval: Small jsep based expression parser that supports array and object indexing\nimport expressionEval from 'expression-eval';\n\nconst cachedExpressionMap = {\n  '-': object => object\n};\n\n// Calculates an accessor function from a JSON string\n// '-' : x => x\n// 'a.b.c': x => x.a.b.c\nexport default function parseExpressionString(propValue, configuration, isAccessor) {\n  // NOTE: Can be null which represents invalid function. Return null so that prop can be ommitted\n  if (propValue in cachedExpressionMap) {\n    return cachedExpressionMap[propValue];\n  }\n\n  let func;\n  // Compile with expression-eval\n  const ast = expressionEval.parse(propValue);\n  if (!ast.right && !ast.left && ast.type === 'Identifier') {\n    func = row => get(row, propValue);\n  } else {\n    // NOTE: To avoid security risks, the arguments passed to the\n    // compiled expresion must only give access to pure data (no globals etc)\n    // We disable function call syntax?\n    traverse(ast, node => {\n      if (node.type === 'CallExpression') {\n        throw new Error('Function calls not allowed in JSON expressions');\n      }\n    });\n    func = isAccessor\n      ? row => expressionEval.eval(ast, row)\n      : // TBD - how do we pass args to general (non-accessor) functions?\n        args => expressionEval.eval(ast, {args});\n  }\n\n  // Cache the compiled function\n  cachedExpressionMap[propValue] = func;\n  return func;\n}\n\n// Helper function to search all nodes in AST returned by expressionEval\n// eslint-disable-next-line complexity\nfunction traverse(node, visitor) {\n  if (Array.isArray(node)) {\n    node.forEach(element => traverse(element, visitor));\n  } else if (node && typeof node === 'object') {\n    if (node.type) {\n      visitor(node);\n    }\n    for (const key in node) {\n      traverse(node[key], visitor);\n    }\n  }\n}\n"],"file":"parse-expression-string.js"}