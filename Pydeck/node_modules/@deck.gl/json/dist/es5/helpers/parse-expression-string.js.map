{"version":3,"sources":["../../../src/helpers/parse-expression-string.js"],"names":["cachedExpressionMap","object","parseExpressionString","propValue","configuration","isAccessor","func","ast","expressionEval","parse","right","left","type","row","traverse","node","Error","eval","args","visitor","Array","isArray","forEach","element","key"],"mappings":";;;;;;;;;;;AAAA;;AAGA;;AAEA,IAAMA,mBAAmB,GAAG;AAC1B,OAAK,WAAAC,MAAM;AAAA,WAAIA,MAAJ;AAAA;AADe,CAA5B;;AAOe,SAASC,qBAAT,CAA+BC,SAA/B,EAA0CC,aAA1C,EAAyDC,UAAzD,EAAqE;AAElF,MAAIF,SAAS,IAAIH,mBAAjB,EAAsC;AACpC,WAAOA,mBAAmB,CAACG,SAAD,CAA1B;AACD;;AAED,MAAIG,IAAJ;;AAEA,MAAMC,GAAG,GAAGC,2BAAeC,KAAf,CAAqBN,SAArB,CAAZ;;AACA,MAAI,CAACI,GAAG,CAACG,KAAL,IAAc,CAACH,GAAG,CAACI,IAAnB,IAA2BJ,GAAG,CAACK,IAAJ,KAAa,YAA5C,EAA0D;AACxDN,IAAAA,IAAI,GAAG,cAAAO,GAAG;AAAA,aAAI,cAAIA,GAAJ,EAASV,SAAT,CAAJ;AAAA,KAAV;AACD,GAFD,MAEO;AAILW,IAAAA,QAAQ,CAACP,GAAD,EAAM,UAAAQ,IAAI,EAAI;AACpB,UAAIA,IAAI,CAACH,IAAL,KAAc,gBAAlB,EAAoC;AAClC,cAAM,IAAII,KAAJ,CAAU,gDAAV,CAAN;AACD;AACF,KAJO,CAAR;AAKAV,IAAAA,IAAI,GAAGD,UAAU,GACb,UAAAQ,GAAG;AAAA,aAAIL,2BAAeS,IAAf,CAAoBV,GAApB,EAAyBM,GAAzB,CAAJ;AAAA,KADU,GAGb,UAAAK,IAAI;AAAA,aAAIV,2BAAeS,IAAf,CAAoBV,GAApB,EAAyB;AAACW,QAAAA,IAAI,EAAJA;AAAD,OAAzB,CAAJ;AAAA,KAHR;AAID;;AAGDlB,EAAAA,mBAAmB,CAACG,SAAD,CAAnB,GAAiCG,IAAjC;AACA,SAAOA,IAAP;AACD;;AAID,SAASQ,QAAT,CAAkBC,IAAlB,EAAwBI,OAAxB,EAAiC;AAC/B,MAAIC,KAAK,CAACC,OAAN,CAAcN,IAAd,CAAJ,EAAyB;AACvBA,IAAAA,IAAI,CAACO,OAAL,CAAa,UAAAC,OAAO;AAAA,aAAIT,QAAQ,CAACS,OAAD,EAAUJ,OAAV,CAAZ;AAAA,KAApB;AACD,GAFD,MAEO,IAAIJ,IAAI,IAAI,yBAAOA,IAAP,MAAgB,QAA5B,EAAsC;AAC3C,QAAIA,IAAI,CAACH,IAAT,EAAe;AACbO,MAAAA,OAAO,CAACJ,IAAD,CAAP;AACD;;AACD,SAAK,IAAMS,GAAX,IAAkBT,IAAlB,EAAwB;AACtBD,MAAAA,QAAQ,CAACC,IAAI,CAACS,GAAD,CAAL,EAAYL,OAAZ,CAAR;AACD;AACF;AACF","sourcesContent":["import {get} from '../utils/get';\n\n// expression-eval: Small jsep based expression parser that supports array and object indexing\nimport expressionEval from 'expression-eval';\n\nconst cachedExpressionMap = {\n  '-': object => object\n};\n\n// Calculates an accessor function from a JSON string\n// '-' : x => x\n// 'a.b.c': x => x.a.b.c\nexport default function parseExpressionString(propValue, configuration, isAccessor) {\n  // NOTE: Can be null which represents invalid function. Return null so that prop can be ommitted\n  if (propValue in cachedExpressionMap) {\n    return cachedExpressionMap[propValue];\n  }\n\n  let func;\n  // Compile with expression-eval\n  const ast = expressionEval.parse(propValue);\n  if (!ast.right && !ast.left && ast.type === 'Identifier') {\n    func = row => get(row, propValue);\n  } else {\n    // NOTE: To avoid security risks, the arguments passed to the\n    // compiled expresion must only give access to pure data (no globals etc)\n    // We disable function call syntax?\n    traverse(ast, node => {\n      if (node.type === 'CallExpression') {\n        throw new Error('Function calls not allowed in JSON expressions');\n      }\n    });\n    func = isAccessor\n      ? row => expressionEval.eval(ast, row)\n      : // TBD - how do we pass args to general (non-accessor) functions?\n        args => expressionEval.eval(ast, {args});\n  }\n\n  // Cache the compiled function\n  cachedExpressionMap[propValue] = func;\n  return func;\n}\n\n// Helper function to search all nodes in AST returned by expressionEval\n// eslint-disable-next-line complexity\nfunction traverse(node, visitor) {\n  if (Array.isArray(node)) {\n    node.forEach(element => traverse(element, visitor));\n  } else if (node && typeof node === 'object') {\n    if (node.type) {\n      visitor(node);\n    }\n    for (const key in node) {\n      traverse(node[key], visitor);\n    }\n  }\n}\n"],"file":"parse-expression-string.js"}