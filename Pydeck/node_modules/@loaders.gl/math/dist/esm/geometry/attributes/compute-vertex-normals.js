import { Vector3 } from 'math.gl';
import { GL } from '../constants';
import assert from '../utils/assert';
import primitiveIterator from '../iterators/primitive-iterator';
import { getPrimitiveModeType } from '../primitives/modes';
import { getPositions } from './get-attribute-from-geometry';
export default function computeVertexNormals(_ref) {
  var mode = _ref.mode,
      indices = _ref.indices,
      attributes = _ref.attributes;
  assert(getPrimitiveModeType(mode) === GL.TRIANGLES, 'TRIANGLES required');

  var _getPositions = getPositions({
    mode: mode,
    indices: indices,
    attributes: attributes
  }),
      positions = _getPositions.values;

  var normals = new Float32Array(positions.length);
  var vectorA = new Vector3();
  var vectorB = new Vector3();
  var vectorC = new Vector3();
  var vectorCB = new Vector3();
  var vectorAB = new Vector3();
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = primitiveIterator({
      mode: mode,
      indices: indices,
      attributes: attributes
    })[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var primitive = _step.value;
      vectorA.fromArray(positions, primitive.i1 * 3);
      vectorB.fromArray(positions, primitive.i2 * 3 + 3);
      vectorC.fromArray(positions, primitive.i3 * 3 + 6);
      vectorCB.subVectors(vectorC, vectorB);
      vectorAB.subVectors(vectorA, vectorB);
      var normal = vectorCB.cross(vectorAB);
      normal.normalize();
      var primitiveIndex = primitive.primitiveIndex;
      normals[primitiveIndex * 9 + 0] = normal.x;
      normals[primitiveIndex * 9 + 1] = normal.y;
      normals[primitiveIndex * 9 + 2] = normal.z;
      normals[primitiveIndex * 9 + 3] = normal.x;
      normals[primitiveIndex * 9 + 4] = normal.y;
      normals[primitiveIndex * 9 + 5] = normal.z;
      normals[primitiveIndex * 9 + 6] = normal.x;
      normals[primitiveIndex * 9 + 7] = normal.y;
      normals[primitiveIndex * 9 + 8] = normal.z;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return normals;
}
//# sourceMappingURL=compute-vertex-normals.js.map