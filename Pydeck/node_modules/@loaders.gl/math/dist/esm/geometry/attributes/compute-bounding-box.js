export function computeBoundingBox(positions) {
  var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Box3();
  var min = [+Infinity, +Infinity, +Infinity];
  var max = [-Infinity, -Infinity, -Infinity];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = attributeIterator(positions)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var position = _step.value;
      var x = position[0];
      var y = position[1];
      var z = position[2];
      if (x < min[0]) min[0] = x;
      if (y < min[1]) min[1] = y;
      if (z < min[2]) min[2] = z;
      if (x > max[0]) max[0] = x;
      if (y > max[1]) max[1] = y;
      if (z > max[2]) max[2] = z;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var boundingBox = {
    min: min,
    max: max
  };
  validateBoundingBox(boundingBox);
  return boundingBox;
}

function validateBoundingBox(boundingBox) {
  assert(Number.isFinite(boundingBox.min[0]) && Number.isFinite(boundingBox.min[1]) && Number.isFinite(boundingBox.min[2]) && Number.isFinite(boundingBox.max[0]) && Number.isFinite(boundingBox.max[1]) && Number.isFinite(boundingBox.max[2]));
}
//# sourceMappingURL=compute-bounding-box.js.map