{"version":3,"sources":["../../../../src/geometry/attributes/compute-bounding-box.js"],"names":["computeBoundingBox","positions","target","Box3","min","Infinity","max","position","attributeIterator","x","y","z","boundingBox","validateBoundingBox","assert","Number","isFinite"],"mappings":"AAEA,OAAO,SAASA,kBAAT,CAA4BC,SAA5B,EAAuCC,MAAM,GAAG,IAAIC,IAAJ,EAAhD,EAA4D;AACjE,QAAMC,GAAG,GAAG,CAAC,CAACC,QAAF,EAAY,CAACA,QAAb,EAAuB,CAACA,QAAxB,CAAZ;AACA,QAAMC,GAAG,GAAG,CAAC,CAACD,QAAF,EAAY,CAACA,QAAb,EAAuB,CAACA,QAAxB,CAAZ;;AAEA,OAAK,MAAME,QAAX,IAAuBC,iBAAiB,CAACP,SAAD,CAAxC,EAAqD;AACnD,UAAMQ,CAAC,GAAGF,QAAQ,CAAC,CAAD,CAAlB;AACA,UAAMG,CAAC,GAAGH,QAAQ,CAAC,CAAD,CAAlB;AACA,UAAMI,CAAC,GAAGJ,QAAQ,CAAC,CAAD,CAAlB;AAEA,QAAIE,CAAC,GAAGL,GAAG,CAAC,CAAD,CAAX,EAAgBA,GAAG,CAAC,CAAD,CAAH,GAASK,CAAT;AAChB,QAAIC,CAAC,GAAGN,GAAG,CAAC,CAAD,CAAX,EAAgBA,GAAG,CAAC,CAAD,CAAH,GAASM,CAAT;AAChB,QAAIC,CAAC,GAAGP,GAAG,CAAC,CAAD,CAAX,EAAgBA,GAAG,CAAC,CAAD,CAAH,GAASO,CAAT;AAEhB,QAAIF,CAAC,GAAGH,GAAG,CAAC,CAAD,CAAX,EAAgBA,GAAG,CAAC,CAAD,CAAH,GAASG,CAAT;AAChB,QAAIC,CAAC,GAAGJ,GAAG,CAAC,CAAD,CAAX,EAAgBA,GAAG,CAAC,CAAD,CAAH,GAASI,CAAT;AAChB,QAAIC,CAAC,GAAGL,GAAG,CAAC,CAAD,CAAX,EAAgBA,GAAG,CAAC,CAAD,CAAH,GAASK,CAAT;AACjB;;AAED,QAAMC,WAAW,GAAG;AAACR,IAAAA,GAAD;AAAME,IAAAA;AAAN,GAApB;AACAO,EAAAA,mBAAmB,CAACD,WAAD,CAAnB;AACA,SAAOA,WAAP;AACD;;AAED,SAASC,mBAAT,CAA6BD,WAA7B,EAA0C;AACxCE,EAAAA,MAAM,CACJC,MAAM,CAACC,QAAP,CAAgBJ,WAAW,CAACR,GAAZ,CAAgB,CAAhB,CAAhB,KACEW,MAAM,CAACC,QAAP,CAAgBJ,WAAW,CAACR,GAAZ,CAAgB,CAAhB,CAAhB,CADF,IAEEW,MAAM,CAACC,QAAP,CAAgBJ,WAAW,CAACR,GAAZ,CAAgB,CAAhB,CAAhB,CAFF,IAGEW,MAAM,CAACC,QAAP,CAAgBJ,WAAW,CAACN,GAAZ,CAAgB,CAAhB,CAAhB,CAHF,IAIES,MAAM,CAACC,QAAP,CAAgBJ,WAAW,CAACN,GAAZ,CAAgB,CAAhB,CAAhB,CAJF,IAKES,MAAM,CAACC,QAAP,CAAgBJ,WAAW,CAACN,GAAZ,CAAgB,CAAhB,CAAhB,CANE,CAAN;AAQD","sourcesContent":["/* eslint-disable */\n\nexport function computeBoundingBox(positions, target = new Box3()) {\n  const min = [+Infinity, +Infinity, +Infinity];\n  const max = [-Infinity, -Infinity, -Infinity];\n\n  for (const position of attributeIterator(positions)) {\n    const x = position[0];\n    const y = position[1];\n    const z = position[2];\n\n    if (x < min[0]) min[0] = x;\n    if (y < min[1]) min[1] = y;\n    if (z < min[2]) min[2] = z;\n\n    if (x > max[0]) max[0] = x;\n    if (y > max[1]) max[1] = y;\n    if (z > max[2]) max[2] = z;\n  }\n\n  const boundingBox = {min, max};\n  validateBoundingBox(boundingBox);\n  return boundingBox;\n}\n\nfunction validateBoundingBox(boundingBox) {\n  assert(\n    Number.isFinite(boundingBox.min[0]) &&\n      Number.isFinite(boundingBox.min[1]) &&\n      Number.isFinite(boundingBox.min[2]) &&\n      Number.isFinite(boundingBox.max[0]) &&\n      Number.isFinite(boundingBox.max[1]) &&\n      Number.isFinite(boundingBox.max[2])\n  );\n}\n"],"file":"compute-bounding-box.js"}