"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = computeVertexNormals;

var _math = require("math.gl");

var _constants = require("../constants");

var _assert = _interopRequireDefault(require("../utils/assert"));

var _primitiveIterator = _interopRequireDefault(require("../iterators/primitive-iterator"));

var _modes = require("../primitives/modes");

var _getAttributeFromGeometry = require("./get-attribute-from-geometry");

function computeVertexNormals(_ref) {
  var mode = _ref.mode,
      indices = _ref.indices,
      attributes = _ref.attributes;
  (0, _assert["default"])((0, _modes.getPrimitiveModeType)(mode) === _constants.GL.TRIANGLES, 'TRIANGLES required');

  var _getPositions = (0, _getAttributeFromGeometry.getPositions)({
    mode: mode,
    indices: indices,
    attributes: attributes
  }),
      positions = _getPositions.values;

  var normals = new Float32Array(positions.length);
  var vectorA = new _math.Vector3();
  var vectorB = new _math.Vector3();
  var vectorC = new _math.Vector3();
  var vectorCB = new _math.Vector3();
  var vectorAB = new _math.Vector3();
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _primitiveIterator["default"])({
      mode: mode,
      indices: indices,
      attributes: attributes
    })[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var primitive = _step.value;
      vectorA.fromArray(positions, primitive.i1 * 3);
      vectorB.fromArray(positions, primitive.i2 * 3 + 3);
      vectorC.fromArray(positions, primitive.i3 * 3 + 6);
      vectorCB.subVectors(vectorC, vectorB);
      vectorAB.subVectors(vectorA, vectorB);
      var normal = vectorCB.cross(vectorAB);
      normal.normalize();
      var primitiveIndex = primitive.primitiveIndex;
      normals[primitiveIndex * 9 + 0] = normal.x;
      normals[primitiveIndex * 9 + 1] = normal.y;
      normals[primitiveIndex * 9 + 2] = normal.z;
      normals[primitiveIndex * 9 + 3] = normal.x;
      normals[primitiveIndex * 9 + 4] = normal.y;
      normals[primitiveIndex * 9 + 5] = normal.z;
      normals[primitiveIndex * 9 + 6] = normal.x;
      normals[primitiveIndex * 9 + 7] = normal.y;
      normals[primitiveIndex * 9 + 8] = normal.z;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return normals;
}
//# sourceMappingURL=compute-vertex-normals.js.map