{"version":3,"sources":["../../../src/parsers/parse-3d-tile-point-cloud.js"],"names":["Vector3","GL","Tile3DFeatureTable","Tile3DBatchTable","parse3DTileHeaderSync","parse3DTileTablesHeaderSync","parse3DTileTablesSync","normalize3DTileColorAttribute","normalize3DTileNormalAttribute","normalize3DTilePositionAttribute","parsePointCloud3DTile","tile","arrayBuffer","byteOffset","options","context","initializeTile","parsePointCloudTables","featureTable","batchTable","parseDraco","parsePositions","parseColors","parseNormals","parsePointCloud3DTileSync","attributes","positions","colors","normals","batchIds","isQuantized","isTranslucent","isRGB565","isOctEncoded16P","featureTableJson","featureTableBinary","pointsLength","getGlobalProperty","Number","isFinite","Error","featuresLength","pointCount","rtcCenter","FLOAT","parseBatchIds","hasProperty","getPropertyArray","UNSIGNED_SHORT","quantizedRange","quantizedVolumeScale","quantizedVolumeOffset","UNSIGNED_BYTE","constantRGBA","batchFeatureLength","batchTableJson","batchTableBinary","batchTableDraco","getExtension","dracoBatchTableProperties","properties","featureTableDraco","dracoFeatureTableProperties","dracoByteOffset","dracoByteLength","byteLength","dracoBuffer","slice","hasPositions","POSITION","hasColors","RGB","RGBA","hasNormals","NORMAL","hasBatchIds","BATCH_ID","dracoData","buffer","featureTableProperties","batchTableProperties","dequantizeInShader","loadDraco","parse","DracoLoader","data","decodedPositions","value","decodedColors","COLOR_0","decodedNormals","decodedBatchIds","isQuantizedDraco","quantization","isOctEncodedDraco","range","minValues","quantizationBits","octEncodedRange"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3} from 'math.gl';\nimport {GL} from '@loaders.gl/math'; // 'math.gl/geometry';\n\nimport Tile3DFeatureTable from '../classes/tile-3d-feature-table';\nimport Tile3DBatchTable from '../classes/tile-3d-batch-table';\nimport {parse3DTileHeaderSync} from './helpers/parse-3d-tile-header';\nimport {parse3DTileTablesHeaderSync, parse3DTileTablesSync} from './helpers/parse-3d-tile-tables';\nimport {normalize3DTileColorAttribute} from './helpers/normalize-3d-tile-colors';\nimport {normalize3DTileNormalAttribute} from './helpers/normalize-3d-tile-normals';\nimport {normalize3DTilePositionAttribute} from './helpers/normalize-3d-tile-positions';\n\nexport async function parsePointCloud3DTile(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset, options);\n  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset, options);\n  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n  initializeTile(tile);\n\n  const {featureTable, batchTable} = parsePointCloudTables(tile);\n\n  await parseDraco(tile, featureTable, batchTable, options, context);\n\n  parsePositions(tile, featureTable, options);\n  parseColors(tile, featureTable, batchTable, options);\n  parseNormals(tile, featureTable, options);\n\n  return byteOffset;\n}\n\n// TODO - is there really a need for sync tile parsing?\nexport function parsePointCloud3DTileSync(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset, options);\n  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset, options);\n  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n\n  initializeTile(tile);\n\n  const {featureTable} = parsePointCloudTables(tile);\n\n  // parseDracoSync(tile, featureTable, batchTable, options);\n\n  parsePositions(tile, featureTable, options);\n  parseColors(tile, featureTable, options);\n  parseNormals(tile, featureTable, options);\n\n  return byteOffset;\n}\n\nfunction initializeTile(tile) {\n  // Initialize point cloud tile defaults\n  tile.attributes = {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  };\n  tile.isQuantized = false;\n  tile.isTranslucent = false;\n  tile.isRGB565 = false;\n  tile.isOctEncoded16P = false;\n}\n\nfunction parsePointCloudTables(tile) {\n  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n\n  const pointsLength = featureTable.getGlobalProperty('POINTS_LENGTH');\n  if (!Number.isFinite(pointsLength)) {\n    throw new Error('POINTS_LENGTH must be defined');\n  }\n  featureTable.featuresLength = pointsLength;\n\n  tile.featuresLength = pointsLength;\n  tile.pointsLength = pointsLength;\n  tile.pointCount = pointsLength;\n\n  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL.FLOAT, 3);\n\n  const batchTable = parseBatchIds(tile, featureTable);\n\n  return {featureTable, batchTable};\n}\n\nfunction parsePositions(tile, featureTable, options) {\n  if (!tile.attributes.positions) {\n    if (featureTable.hasProperty('POSITION')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      const positions = featureTable.getPropertyArray('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3);\n\n      tile.isQuantized = true;\n      tile.quantizedRange = (1 << 16) - 1;\n\n      tile.quantizedVolumeScale = featureTable.getGlobalProperty(\n        'QUANTIZED_VOLUME_SCALE',\n        GL.FLOAT,\n        3\n      );\n      if (!tile.quantizedVolumeScale) {\n        throw new Error('QUANTIZED_VOLUME_SCALE must be defined for quantized positions.');\n      }\n\n      tile.quantizedVolumeOffset = featureTable.getGlobalProperty(\n        'QUANTIZED_VOLUME_OFFSET',\n        GL.FLOAT,\n        3\n      );\n      if (!tile.quantizedVolumeOffset) {\n        throw new Error('QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.');\n      }\n\n      tile.attributes.positions = normalize3DTilePositionAttribute(tile, positions, options);\n    }\n  }\n\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n}\n\nfunction parseColors(tile, featureTable, batchTable) {\n  if (!tile.attributes.colors) {\n    let colors = null;\n    if (featureTable.hasProperty('RGBA')) {\n      colors = featureTable.getPropertyArray('RGBA', GL.UNSIGNED_BYTE, 4);\n      tile.isTranslucent = true;\n    } else if (featureTable.hasProperty('RGB')) {\n      colors = featureTable.getPropertyArray('RGB', GL.UNSIGNED_BYTE, 3);\n    } else if (featureTable.hasProperty('RGB565')) {\n      colors = featureTable.getPropertyArray('RGB565', GL.UNSIGNED_SHORT, 1);\n      tile.isRGB565 = true;\n    }\n\n    tile.attributes.colors = normalize3DTileColorAttribute(tile, colors, batchTable);\n  }\n\n  if (featureTable.hasProperty('CONSTANT_RGBA')) {\n    tile.constantRGBA = featureTable.getGlobalProperty('CONSTANT_RGBA', GL.UNSIGNED_BYTE, 4);\n  }\n}\n\nfunction parseNormals(tile, featureTable) {\n  if (!tile.attributes.normals) {\n    let normals = null;\n    if (featureTable.hasProperty('NORMAL')) {\n      normals = featureTable.getPropertyArray('NORMAL', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('NORMAL_OCT16P')) {\n      normals = featureTable.getPropertyArray('NORMAL_OCT16P', GL.UNSIGNED_BYTE, 2);\n      tile.isOctEncoded16P = true;\n    }\n\n    tile.attributes.normals = normalize3DTileNormalAttribute(tile, normals);\n  }\n}\n\nfunction parseBatchIds(tile, featureTable) {\n  let batchTable = null;\n  if (!tile.batchIds && featureTable.hasProperty('BATCH_ID')) {\n    tile.batchIds = featureTable.getPropertyArray('BATCH_ID', GL.UNSIGNED_SHORT, 1);\n\n    if (tile.batchIds) {\n      const batchFeatureLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n      if (!batchFeatureLength) {\n        throw new Error('Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.');\n      }\n      const {batchTableJson, batchTableBinary} = tile;\n      batchTable = new Tile3DBatchTable(batchTableJson, batchTableBinary, batchFeatureLength);\n    }\n  }\n  return batchTable;\n}\n\n// eslint-disable-next-line complexity\nasync function parseDraco(tile, featureTable, batchTable, options, context) {\n  let dracoBuffer;\n  let dracoFeatureTableProperties;\n  let dracoBatchTableProperties;\n  const batchTableDraco = batchTable && batchTable.getExtension('3DTILES_draco_point_compression');\n  if (batchTableDraco) {\n    dracoBatchTableProperties = batchTableDraco.properties;\n  }\n\n  const featureTableDraco = featureTable.getExtension('3DTILES_draco_point_compression');\n  if (featureTableDraco) {\n    dracoFeatureTableProperties = featureTableDraco.properties;\n    const dracoByteOffset = featureTableDraco.byteOffset;\n    const dracoByteLength = featureTableDraco.byteLength;\n    if (!dracoFeatureTableProperties || !Number.isFinite(dracoByteOffset) || !dracoByteLength) {\n      throw new Error('Draco properties, byteOffset, and byteLength must be defined');\n    }\n\n    dracoBuffer = tile.featureTableBinary.slice(dracoByteOffset, dracoByteOffset + dracoByteLength);\n\n    tile.hasPositions = Number.isFinite(dracoFeatureTableProperties.POSITION);\n    tile.hasColors =\n      Number.isFinite(dracoFeatureTableProperties.RGB) ||\n      Number.isFinite(dracoFeatureTableProperties.RGBA);\n    tile.hasNormals = Number.isFinite(dracoFeatureTableProperties.NORMAL);\n    tile.hasBatchIds = Number.isFinite(dracoFeatureTableProperties.BATCH_ID);\n    tile.isTranslucent = Number.isFinite(dracoFeatureTableProperties.RGBA);\n  }\n\n  if (dracoBuffer) {\n    const dracoData = {\n      buffer: dracoBuffer,\n      properties: {...dracoFeatureTableProperties, ...dracoBatchTableProperties},\n      featureTableProperties: dracoFeatureTableProperties,\n      batchTableProperties: dracoBatchTableProperties,\n      dequantizeInShader: false\n    };\n\n    await loadDraco(tile, dracoData, options, context);\n  }\n}\n\n// eslint-disable-next-line complexity, max-statements\nexport async function loadDraco(tile, dracoData, options, context) {\n  const {parse} = context;\n  const data = await parse(dracoData.buffer, options.DracoLoader);\n  const decodedPositions = data.attributes.POSITION && data.attributes.POSITION.value;\n  const decodedColors = data.attributes.COLOR_0 && data.attributes.COLOR_0.value;\n  const decodedNormals = data.attributes.NORMAL && data.attributes.NORMAL.value;\n  const decodedBatchIds = data.attributes.BATCH_ID && data.attributes.BATCH_ID.value;\n  const isQuantizedDraco = decodedPositions && data.attributes.POSITION.value.quantization;\n  const isOctEncodedDraco = decodedNormals && data.attributes.NORMAL.value.quantization;\n  if (isQuantizedDraco) {\n    // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n    // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n    const quantization = data.POSITION.data.quantization;\n    const range = quantization.range;\n    tile.quantizedVolumeScale = new Vector3(range, range, range);\n    tile.quantizedVolumeOffset = new Vector3(quantization.minValues);\n    tile.quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n    tile.isQuantizedDraco = true;\n  }\n  if (isOctEncodedDraco) {\n    tile.octEncodedRange = (1 << data.NORMAL.data.quantization.quantizationBits) - 1.0;\n    tile.isOctEncodedDraco = true;\n  }\n\n  tile.attributes = {\n    positions: decodedPositions,\n    colors: normalize3DTileColorAttribute(tile, decodedColors),\n    normals: decodedNormals,\n    batchIds: decodedBatchIds\n  };\n}\n\n/*\n  const batchTable = new Tile3DBatchTable(tile);\n\n  // parseDracoBuffer(tile, featureTable, batchTable);\n\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n}\n/*\n\n  if (!tile.attributes.positions) {\n    if (featureTable.hasProperty('POSITION')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3);\n\n\n  if (!tile.colors) {\n    if (featureTable.hasProperty('RGBA')) {\n      tile.colors = featureTable.getPropertyArray('RGBA', GL.UNSIGNED_BYTE, 4);\n      tile.isTranslucent = true;\n    } else if (featureTable.hasProperty('RGB')) {\n      tile.colors = featureTable.getPropertyArray('RGB', GL.UNSIGNED_BYTE, 3);\n    } else if (featureTable.hasPropertry('RGB565')) {\n      tile.colors = featureTable.getPropertyArray('RGB565', GL.UNSIGNED_SHORT, 1);\n      tile.isRGB565 = true;\n    }\n  }\n\n  if (!tile.attributes.normals) {\n    if (featureTable.getPropertry('NORMAL')) {\n      tile.attributes.normals = featureTable.getPropertyArray('NORMAL', GL.FLOAT, 3);\n    } else if (featureTable.getProperty('NORMAL_OCT16P')) {\n      tile.attributes.normals = featureTable.getPropertyArray('NORMAL_OCT16P', GL.UNSIGNED_BYTE, 2);\n      tile.isOctEncoded16P = true;\n    }\n  }\n\n  if (!tile.batchIds) {\n    if (featureTable.hasProperty('BATCH_ID')) {\n      tile.batchIds = featureTable.getPropertyArray('BATCH_ID', GL.UNSIGNED_SHORT, 1);\n    }\n  }\n\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n\n  if (featureTable.getPropertry('CONSTANT_RGBA')) {\n    tile.constantRGBA = featureTable.getGlobalProperty('CONSTANT_RGBA', GL.UNSIGNED_BYTE, 4);\n  }\n\n  if (tile.batchIds) {\n    const batchLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n    if (!defined(batchLength)) {\n      throw new Error('Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.');\n    }\n\n    if (defined(batchTableBinary)) {\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      batchTableBinary = new Uint8Array(batchTableBinary);\n    }\n\n    if (defined(pointCloud._batchTableLoaded)) {\n      pointCloud._batchTableLoaded(batchLength, batchTableJson, batchTableBinary);\n    }\n  }\n\n  // If points are not batched and there are per-point properties, use these properties for styling purposes\n  var styleableProperties;\n  if (!hasBatchIds && defined(batchTableBinary)) {\n    tile.styleableProperties = Cesium3DTileBatchTable.getBinaryProperties(\n      pointsLength,\n      batchTableJson,\n      batchTableBinary\n    );\n  }\n\n  tile.draco = draco;\n}\n\n// Separate parsing and decoding of Draco\nexport function parseDracoBuffer(tile, featureTable, batchTable) {\n  let dracoBuffer;\n  let dracoFeatureTableProperties;\n  let dracoBatchTableProperties;\n\n  const batchTableDraco = batchTable.getExtension('3DTILES_draco_point_compression');\n  if (batchTableDraco) {\n    dracoBatchTableProperties = batchTableDraco.properties;\n  }\n\n  const featureTableDraco = featureTable.getExtension('3DTILES_draco_point_compression');\n  if (featureTableDraco) {\n    dracoFeatureTableProperties = featureTableDraco.properties;\n    const dracoByteOffset = featureTableDraco.byteOffset;\n    const dracoByteLength = featureTableDraco.byteLength;\n    if (!dracoFeatureTableProperties || !dracoByteOffset || !dracoByteLength) {\n      throw new Error('Draco properties, byteOffset, and byteLength must be defined');\n    }\n\n    dracoBuffer = arraySlice(\n      featureTableBinary,\n      dracoByteOffset,\n      dracoByteOffset + dracoByteLength\n    );\n    tile.hasPositions = dracoFeatureTableProperties.POSITION;\n    tile.hasColors = dracoFeatureTableProperties.RGB || dracoFeatureTableProperties.RGBA;\n    tile.hasNormals = dracoFeatureTableProperties.NORMAL;\n    tile.hasBatchIds = dracoFeatureTableProperties.BATCH_ID;\n    tile.isTranslucent = dracoFeatureTableProperties.RGBA;\n  }\n\n  if (dracoBuffer) {\n    tile.draco = {\n      buffer: dracoBuffer,\n      properties: {...dracoFeatureTableProperties, ...dracoBatchTableProperties},\n      featureTableProperties: dracoFeatureTableProperties,\n      batchTableProperties: dracoBatchTableProperties,\n      dequantizeInShader: false\n    };\n\n    tile.decodingState = DECODING_STATE.NEEDS_DECODE;\n  }\n}\n\n/*\nfunction decodeDraco(tile, context) {\n  if (tile.decodingState === DECODING_STATE.READY) {\n    return false;\n  }\n  if (tile.decodingState === DECODING_STATE.NEEDS_DECODE) {\n    var parsedContent = tile._parsedContent;\n    var draco = parsedContent.draco;\n    var decodePromise = DracoLoader.decodePointCloud(draco, context);\n    if (defined(decodePromise)) {\n      tile.decodingState = DECODING_STATE.DECODING;\n      decodePromise.then(function(result) {\n        tile.decodingState = DECODING_STATE.READY;\n        var decodedPositions = defined(result.POSITION) ? result.POSITION.array : undefined;\n        var decodedRgb = defined(result.RGB) ? result.RGB.array : undefined;\n        var decodedRgba = defined(result.RGBA) ? result.RGBA.array : undefined;\n        var decodedNormals = defined(result.NORMAL) ? result.NORMAL.array : undefined;\n        var decodedBatchIds = defined(result.BATCH_ID) ? result.BATCH_ID.array : undefined;\n        var isQuantizedDraco = defined(decodedPositions) && defined(result.POSITION.data.quantization);\n        var isOctEncodedDraco = defined(decodedNormals) && defined(result.NORMAL.data.quantization);\n        if (isQuantizedDraco) {\n          // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n          // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n          var quantization = result.POSITION.data.quantization;\n          var range = quantization.range;\n          tile._quantizedVolumeScale = Cartesian3.fromElements(range, range, range);\n          tile._quantizedVolumeOffset = Cartesian3.unpack(quantization.minValues);\n          tile._quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n          tile._isQuantizedDraco = true;\n        }\n        if (isOctEncodedDraco) {\n          tile._octEncodedRange = (1 << result.NORMAL.data.quantization.quantizationBits) - 1.0;\n          tile._isOctEncodedDraco = true;\n        }\n        var styleableProperties = parsedContent.styleableProperties;\n        var batchTableProperties = draco.batchTableProperties;\n        for (var name in batchTableProperties) {\n          if (batchTableProperties.hasOwnProperty(name)) {\n            var property = result[name];\n            if (!defined(styleableProperties)) {\n              styleableProperties = {};\n            }\n            styleableProperties[name] = {\n              typedArray : property.array,\n              componentCount : property.data.componentsPerAttribute\n            };\n          }\n        }\n        parsedContent.positions = defaultValue(decodedPositions, parsedContent.positions);\n        parsedContent.colors = defaultValue(defaultValue(decodedRgba, decodedRgb), parsedContent.colors);\n        parsedContent.normals = defaultValue(decodedNormals, parsedContent.normals);\n        parsedContent.batchIds = defaultValue(decodedBatchIds, parsedContent.batchIds);\n        parsedContent.styleableProperties = styleableProperties;\n      }).otherwise(function(error) {\n        tile.decodingState = DECODING_STATE.FAILED;\n        tile._readyPromise.reject(error);\n      });\n    }\n  }\n  return true;\n}\n*/\n"],"file":"parse-3d-tile-point-cloud.js"}