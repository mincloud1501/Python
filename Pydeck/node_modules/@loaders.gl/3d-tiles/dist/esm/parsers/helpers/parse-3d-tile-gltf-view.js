export var GLTF_FORMAT = {
  URI: 0,
  EMBEDDED: 1
};
export function parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset) {
  var gltfByteLength = tile.byteOffset + tile.byteLength - byteOffset;

  if (gltfByteLength === 0) {
    throw new Error('glTF byte length must be greater than 0.');
  }

  var subArray = new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + gltfByteLength);
  var arrayCopy = new Uint8Array(subArray);
  tile.gltfArrayBuffer = arrayCopy.buffer;
  tile.gltfByteOffset = 0;
  tile.gltfByteLength = gltfByteLength;
  tile.rotateYtoZ = true;
  return tile.byteOffset + tile.byteLength;
}
export function extractGLTF(tile, gltfFormat, options) {
  switch (gltfFormat) {
    case GLTF_FORMAT.URI:
      var gltfUrlBytes = new Uint8Array(tile.gltfArrayBuffer, tile.gltfByteOffset);
      var textDecoder = new TextDecoder();
      var gltfUrl = textDecoder.decode(gltfUrlBytes);
      tile.gltfUrl = gltfUrl.replace(/[\s\0]+$/, '');
      break;

    case GLTF_FORMAT.EMBEDDED:
      tile.gltf = {};
      break;

    default:
      throw new Error("i3dm: glTF format ".concat(gltfFormat, ": Must be 0 (uri) or 1 (embedded)"));
  }
}
//# sourceMappingURL=parse-3d-tile-gltf-view.js.map