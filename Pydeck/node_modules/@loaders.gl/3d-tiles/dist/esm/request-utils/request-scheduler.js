import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { Stats } from 'probe.gl';
var STAT_QUEUED_REQUESTS = 'Queued Requests';
var STAT_ACTIVE_REQUESTS = 'Active Requests';
var STAT_CANCELLED_REQUESTS = 'Cancelled Requests';
var STAT_QUEUED_REQUESTS_EVER = 'Queued Requests Ever';
var STAT_ACTIVE_REQUESTS_EVER = 'Active Requests Ever';
var DEFAULT_PROPS = {
  id: 'request-scheduler',
  throttleRequests: true,
  maxRequests: 6
};

var RequestScheduler = function () {
  function RequestScheduler() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, RequestScheduler);

    this.props = _objectSpread({}, props, {}, DEFAULT_PROPS);
    this.requestQueue = [];
    this.activeRequestCount = 0;
    this.stats = new Stats({
      id: props.id
    });
    this.stats.get(STAT_QUEUED_REQUESTS);
    this.stats.get(STAT_ACTIVE_REQUESTS);
    this.stats.get(STAT_CANCELLED_REQUESTS);
    this.stats.get(STAT_QUEUED_REQUESTS_EVER);
    this.stats.get(STAT_ACTIVE_REQUESTS_EVER);
  }

  _createClass(RequestScheduler, [{
    key: "scheduleRequest",
    value: function scheduleRequest(handle) {
      var _this = this;

      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
        return 0;
      };

      if (!this.props.throttleRequests) {
        return Promise.resolve(handle);
      }

      var promise = new Promise(function (resolve, reject) {
        _this.requestQueue.push({
          handle: handle,
          callback: callback,
          resolve: resolve,
          reject: reject
        });
      });

      this._issueNewRequests();

      return promise;
    }
  }, {
    key: "startRequest",
    value: function startRequest(handle) {
      this.activeRequestCount++;
    }
  }, {
    key: "endRequest",
    value: function endRequest(handle) {
      this.activeRequestCount--;

      this._issueNewRequests();
    }
  }, {
    key: "trackRequestPromise",
    value: function trackRequestPromise(handle, promise) {
      var _this2 = this;

      this.startRequest(handle);
      promise.then(function () {
        return _this2.endRequest(handle);
      })["catch"](function () {
        return _this2.endRequest(handle);
      });
    }
  }, {
    key: "_issueNewRequests",
    value: function _issueNewRequests() {
      var _this3 = this;

      this._updateNeeded = true;
      setTimeout(function () {
        return _this3._issueNewRequestsAsync();
      }, 0);
    }
  }, {
    key: "_issueNewRequestsAsync",
    value: function _issueNewRequestsAsync() {
      this._updateNeeded = false;
      var freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);

      if (freeSlots === 0) {
        return;
      }

      this._updateAllRequests();

      for (var i = 0; i < freeSlots; ++i) {
        if (this.requestQueue.length > 0) {
          var request = this.requestQueue.shift();
          request.resolve(true);
        }
      }
    }
  }, {
    key: "_updateAllRequests",
    value: function _updateAllRequests() {
      var requestQueue = this.requestQueue;

      for (var i = 0; i < requestQueue.length; ++i) {
        var request = requestQueue[i];

        if (!this._updateRequest(request)) {
          requestQueue.splice(i, 1);
          i--;
        }
      }

      requestQueue.sort(function (a, b) {
        return a.priority - b.priority;
      });
    }
  }, {
    key: "_updateRequest",
    value: function _updateRequest(request) {
      request.priority = request.callback(request.handle);

      if (request.priority < 0) {
        request.resolve(false);
        return false;
      }

      return true;
    }
  }]);

  return RequestScheduler;
}();

export { RequestScheduler as default };
//# sourceMappingURL=request-scheduler.js.map