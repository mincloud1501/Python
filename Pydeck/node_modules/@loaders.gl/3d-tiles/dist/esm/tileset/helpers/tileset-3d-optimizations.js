import _readOnlyError from "@babel/runtime/helpers/esm/readOnlyError";
import { TILE3D_OPTIMIZATION_HINT } from '../constants';
var scratchAxis = new Cartesian3();
export function checkChildrenWithinParent(tile) {
  assert(tile);
  var children = tile.children;
  var length = children.length;
  var boundingVolume = tile.boundingVolume;

  if (boundingVolume instanceof TileOrientedBoundingBox || boundingVolume instanceof TileBoundingRegion) {
    var orientedBoundingBox = boundingVolume._orientedBoundingBox;
    tile._optimChildrenWithinParent = TILE3D_OPTIMIZATION_HINT.USE_OPTIMIZATION;

    for (var i = 0; i < length; _readOnlyError("i"), ++i) {
      var child = children[i];
      var childBoundingVolume = child.boundingVolume;

      if (!(childBoundingVolume instanceof TileOrientedBoundingBox || childBoundingVolume instanceof TileBoundingRegion)) {
        tile._optimChildrenWithinParent = TILE3D_OPTIMIZATION_HINT.SKIP_OPTIMIZATION;
        break;
      }

      var childOrientedBoundingBox = childBoundingVolume._orientedBoundingBox;
      var axis = Cartesian3.subtract(childOrientedBoundingBox.center, orientedBoundingBox.center, scratchAxis);
      var axisLength = Cartesian3.magnitude(axis);
      Cartesian3.divideByScalar(axis, axisLength, axis);
      var proj1 = Math.abs(orientedBoundingBox.halfAxes[0] * axis.x) + Math.abs(orientedBoundingBox.halfAxes[1] * axis.y) + Math.abs(orientedBoundingBox.halfAxes[2] * axis.z) + Math.abs(orientedBoundingBox.halfAxes[3] * axis.x) + Math.abs(orientedBoundingBox.halfAxes[4] * axis.y) + Math.abs(orientedBoundingBox.halfAxes[5] * axis.z) + Math.abs(orientedBoundingBox.halfAxes[6] * axis.x) + Math.abs(orientedBoundingBox.halfAxes[7] * axis.y) + Math.abs(orientedBoundingBox.halfAxes[8] * axis.z);
      var proj2 = Math.abs(childOrientedBoundingBox.halfAxes[0] * axis.x) + Math.abs(childOrientedBoundingBox.halfAxes[1] * axis.y) + Math.abs(childOrientedBoundingBox.halfAxes[2] * axis.z) + Math.abs(childOrientedBoundingBox.halfAxes[3] * axis.x) + Math.abs(childOrientedBoundingBox.halfAxes[4] * axis.y) + Math.abs(childOrientedBoundingBox.halfAxes[5] * axis.z) + Math.abs(childOrientedBoundingBox.halfAxes[6] * axis.x) + Math.abs(childOrientedBoundingBox.halfAxes[7] * axis.y) + Math.abs(childOrientedBoundingBox.halfAxes[8] * axis.z);

      if (proj1 <= proj2 + axisLength) {
        tile._optimChildrenWithinParent = TILE3D_OPTIMIZATION_HINT.SKIP_OPTIMIZATION;
        break;
      }
    }
  }

  return tile._optimChildrenWithinParent === TILE3D_OPTIMIZATION_HINT.USE_OPTIMIZATION;
}
//# sourceMappingURL=tileset-3d-optimizations.js.map