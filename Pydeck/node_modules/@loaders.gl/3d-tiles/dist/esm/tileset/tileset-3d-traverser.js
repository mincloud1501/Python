import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import { TILE3D_REFINEMENT } from '../constants';
import ManagedArray from '../utils/managed-array';
import assert from '../utils/assert';

var Tileset3DTraverser = function () {
  function Tileset3DTraverser() {
    _classCallCheck(this, Tileset3DTraverser);

    this.traversal = {
      stack: new ManagedArray(),
      stackMaximumLength: 0
    };
    this.emptyTraversal = {
      stack: new ManagedArray(),
      stackMaximumLength: 0
    };
    this.result = {
      _requestedTiles: [],
      selectedTiles: [],
      _emptyTiles: [],
      _hasMixedContent: false
    };
    this._disableSkipLevelOfDetail = false;
  }

  _createClass(Tileset3DTraverser, [{
    key: "traverse",
    value: function traverse(root, frameState, options) {
      this.root = root;
      this.options = options;
      this.result._requestedTiles.length = 0;
      this.result.selectedTiles.length = 0;
      this.result._emptyTiles.length = 0;
      this.result._hasMixedContent = false;
      this.updateTile(root, frameState);

      if (!root.isVisibleAndInRequestVolume) {
        return false;
      }

      if (root.getScreenSpaceError(frameState, true) <= options.maximumScreenSpaceError) {
        return false;
      }

      var baseScreenSpaceError = options.maximumScreenSpaceError;
      this.executeTraversal(root, baseScreenSpaceError, frameState);
      this.traversal.stack.trim(this.traversal.stackMaximumLength);
      this.emptyTraversal.stack.trim(this.emptyTraversal.stackMaximumLength);
      return true;
    }
  }, {
    key: "selectTile",
    value: function selectTile(tile, frameState) {
      tile._selectedFrame = frameState.frameNumber;
      this.result.selectedTiles.push(tile);
    }
  }, {
    key: "selectDesiredTile",
    value: function selectDesiredTile(tile, frameState) {
      if (!this.options.skipLevelOfDetail) {
        if (tile.contentAvailable) {
          this.selectTile(tile, frameState);
        }

        return;
      }

      var loadedTile = tile.contentAvailable ? tile : tile._ancestorWithContentAvailable;

      if (loadedTile) {
        loadedTile._shouldSelect = true;
      } else {
        this.selectDescendants(tile, frameState);
      }
    }
  }, {
    key: "visitTile",
    value: function visitTile(tileset, tile, frameState) {
      ++tileset._statistics.visited;
      tile._visitedFrame = frameState.frameNumber;
    }
  }, {
    key: "touchTile",
    value: function touchTile(tile, frameState) {
      tile.tileset._cache.touch(tile);

      tile._touchedFrame = frameState.frameNumber;
    }
  }, {
    key: "getPriority",
    value: function getPriority(tile, options) {
      switch (tile.refine) {
        case TILE3D_REFINEMENT.ADD:
          return tile._distanceToCamera;

        case TILE3D_REFINEMENT.REPLACE:
          var parent = tile.parent;
          var useParentScreenSpaceError = parent && (!options.skipLevelOfDetail || tile._screenSpaceError === 0.0 || parent.hasTilesetContent);
          var screenSpaceError = useParentScreenSpaceError ? parent._screenSpaceError : tile._screenSpaceError;
          var rootScreenSpaceError = this.root._screenSpaceError;
          return rootScreenSpaceError - screenSpaceError;

        default:
          return assert(false);
      }
    }
  }, {
    key: "loadTile",
    value: function loadTile(tile, frameState) {
      if (tile.hasUnloadedContent || tile.contentExpired) {
        tile._requestedFrame = frameState.frameNumber;
        tile._priority = this.getPriority(tile, this.options);

        this.result._requestedTiles.push(tile);
      }
    }
  }, {
    key: "updateTileVisibility",
    value: function updateTileVisibility(tile, frameState) {
      tile.updateVisibility(frameState);
    }
  }, {
    key: "updateTile",
    value: function updateTile(tile, frameState) {
      this.updateTileVisibility(tile, frameState);
      tile.updateExpiration();
    }
  }, {
    key: "updateAndPushChildren",
    value: function updateAndPushChildren(tile, stack, frameState) {
      var children = tile.children;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var child = _step.value;
          this.updateTile(child, frameState);
          stack.push(child);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return true;
    }
  }, {
    key: "canTraverse",
    value: function canTraverse(tile, options) {
      if (tile.children.length === 0 || options.depthLimit < tile.depth) {
        return false;
      }

      if (tile.hasTilesetContent) {
        return !tile.contentExpired;
      }

      return tile._screenSpaceError > options.maximumScreenSpaceError;
    }
  }, {
    key: "executeTraversal",
    value: function executeTraversal(root, baseScreenSpaceError, frameState) {
      var traversal = this.traversal;
      var stack = traversal.stack;
      stack.push(root);

      while (stack.length > 0) {
        traversal.stackMaximumLength = Math.max(traversal.stackMaximumLength, stack.length);
        var tile = stack.pop();
        var add = tile.refine === TILE3D_REFINEMENT.ADD;
        var replace = tile.refine === TILE3D_REFINEMENT.REPLACE;
        var parent = tile.parent;
        var parentRefines = !parent || parent._refines;
        var refines = false;

        if (this.canTraverse(tile, this.options)) {
          refines = this.updateAndPushChildren(tile, stack, frameState) && parentRefines;
        }

        var stoppedRefining = !refines && parentRefines;

        if (!tile.hasRenderContent) {
          this.result._emptyTiles.push(tile);

          this.loadTile(tile, frameState);

          if (stoppedRefining) {
            this.selectDesiredTile(tile, frameState);
          }
        } else if (add) {
          this.loadTile(tile, frameState);
          this.selectDesiredTile(tile, frameState);
        } else if (replace) {
          this.loadTile(tile, frameState);

          if (stoppedRefining) {
            this.selectDesiredTile(tile, frameState);
          }
        }

        this.touchTile(tile, frameState);
        tile._refines = refines;
      }
    }
  }]);

  return Tileset3DTraverser;
}();

export { Tileset3DTraverser as default };
//# sourceMappingURL=tileset-3d-traverser.js.map