{"version":3,"sources":["../../../src/tileset/tile-3d-header.js"],"names":["Vector3","Matrix4","CullingVolume","parse","fetchFile","path","Tile3DLoader","Tileset3DLoader","TILE3D_REFINEMENT","TILE3D_CONTENT_STATE","TILE3D_OPTIMIZATION_HINT","assert","createBoundingVolume","defined","x","undefined","scratchDate","Date","scratchCommandList","scratchToTileCenter","scratchPlane","Plane","INTERSECT","Intersect","computeVisibilityWithPlaneMask","cullingVolume","boundingVolume","parentPlaneMask","Number","isFinite","MASK_OUTSIDE","MASK_INSIDE","mask","planes","k","length","flag","plane","fromNormalDistance","normal","distance","result","intersectPlane","OUTSIDE","INTERSECTING","Tile3DHeader","tileset","header","parentHeader","basePath","_tileset","_header","_basePath","_content","_contentState","UNLOADED","_gpuMemoryUsageInBytes","parent","children","refine","_getRefine","cacheNode","userData","geometricError","console","warn","_initializeTransforms","_initializeBoundingVolumes","_initializeContent","_initializeCache","_optimChildrenWithinParent","NOT_COMPUTED","_initializeRenderingState","Object","seal","frameState","useParentGeometricError","parentGeometricError","Math","max","_distanceToCamera","height","sseDenominator","error","_getDynamicScreenSpaceError","fog","distanceToCamera","density","scalar","exp","dynamicScreenSpaceError","_dynamicScreenSpaceErrorComputedDensity","factor","dynamicScreenSpaceErrorFactor","dynamicError","updatePriority","tile","_visible","_priority","hasEmptyContent","expired","contentExpired","expireDate","LOADING","_requestScheduler","scheduleRequest","cancelled","contentUri","uri","startRequest","options","fetchOptions","response","endRequest","indexOf","_initializeTileHeaders","dirname","READY","_contentLoaded","FAILED","hasRenderContent","destroy","_updatedVisibilityFrame","parentTransform","computedTransform","modelMatrix","parentVisibilityPlaneMask","_visibilityPlaneMask","MASK_INDETERMINATE","_updateTransform","distanceToTile","_screenSpaceError","getScreenSpaceError","visibility","_inRequestVolume","insideViewerRequestVolume","contentReady","now","lessThan","EXPIRED","_expiredContent","clippingPlanes","clippingPlanesOriginMatrix","enabled","intersection","computeIntersectionWithBoundingVolume","_isClipped","INSIDE","_boundingVolume","sqrt","distanceSquaredTo","camera","position","subVectors","center","direction","dot","viewerRequestVolume","_viewerRequestVolume","expire","expireDuration","duration","date","fromIso8601","tileHeader","transform","clone","multiplyRight","parentInitialTransform","_initialTransform","_contentBoundingVolume","content","_tile","contentState","_serverKey","hasTilesetContent","url","fullUri","_centerZDepth","_finalResolution","_depth","_stackLength","_selectionDepth","_touchedFrame","_visitedFrame","_selectedFrame","_requestedFrame","_ancestorWithContent","_ancestorWithContentAvailable","_refines","_shouldSelect","REPLACE","ADD","Boolean","asset","type","traverser","disableSkipLevelOfDetail","_isTileset","didTransformChange","equals","contentFailed","contentUnloaded","getTileUrl","boundingSphere","extras","updateContent","expiredContent","update","updateExpireDate","expireDurationDate","addSeconds","createPriorityFunction"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n// import {TILE3D_REFINEMENT, TILE3D_OPTIMIZATION_HINT} from '../constants';\nimport {Vector3, Matrix4} from 'math.gl';\nimport {CullingVolume} from '@math.gl/culling';\nimport {parse, fetchFile, path} from '@loaders.gl/core';\nimport Tile3DLoader from '../tile-3d-loader';\nimport Tileset3DLoader from '../tileset-3d-loader';\nimport {TILE3D_REFINEMENT, TILE3D_CONTENT_STATE, TILE3D_OPTIMIZATION_HINT} from '../constants';\nimport assert from '../utils/assert';\nimport {createBoundingVolume} from './helpers/bounding-volume';\n\nconst defined = x => x !== undefined && x !== null;\n\n/* eslint-disable */\nconst scratchDate = new Date();\nconst scratchCommandList = [];\nconst scratchToTileCenter = new Vector3();\n\n// TODO: Remove\nconst scratchPlane = new Plane();\nimport {INTERSECT, Intersect, Plane} from '@math.gl/culling';\n\nfunction computeVisibilityWithPlaneMask(cullingVolume, boundingVolume, parentPlaneMask) {\n  assert(boundingVolume, 'boundingVolume is required.');\n  assert(Number.isFinite(parentPlaneMask), 'parentPlaneMask is required.');\n\n  if (\n    parentPlaneMask === CullingVolume.MASK_OUTSIDE ||\n    parentPlaneMask === CullingVolume.MASK_INSIDE\n  ) {\n    // parent is completely outside or completely inside, so this child is as well.\n    return parentPlaneMask;\n  }\n\n  // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.\n  // (Because if there are fewer than 31 planes, the upper bits wont be changed.)\n  let mask = CullingVolume.MASK_INSIDE;\n\n  const planes = cullingVolume.planes;\n  for (let k = 0; k < cullingVolume.planes.length; ++k) {\n    // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.\n    const flag = k < 31 ? 1 << k : 0;\n    if (k < 31 && (parentPlaneMask & flag) === 0) {\n      // boundingVolume is known to be INSIDE this plane.\n      continue;\n    }\n\n    const plane = scratchPlane.fromNormalDistance(planes[k].normal, planes[k].distance);\n    const result = boundingVolume.intersectPlane(plane);\n\n    if (result === Intersect.OUTSIDE) {\n      return CullingVolume.MASK_OUTSIDE;\n    } else if (result === Intersect.INTERSECTING) {\n      mask |= flag;\n    }\n  }\n\n  return mask;\n}\n\n// A Tile3DHeader represents a tile a Tileset3D. When a tile is first created, its content is not loaded;\n// the content is loaded on-demand when needed based on the view.\n// Do not construct this directly, instead access tiles through {@link Tileset3D#tileVisible}.\nexport default class Tile3DHeader {\n  constructor(tileset, header, parentHeader, basePath) {\n    // assert(tileset._asset);\n    assert(typeof header === 'object');\n\n    this._tileset = tileset;\n    this._header = header;\n    this._basePath = basePath;\n    this._content = null;\n    this._contentState = TILE3D_CONTENT_STATE.UNLOADED;\n    this._gpuMemoryUsageInBytes = 0;\n\n    // This tile's parent or `undefined` if this tile is the root.\n    this.parent = parentHeader;\n    // The tile's children.\n    this.children = [];\n    // Specifies the type of refine that is used when traversing this tile for rendering.\n    this.refine = this._getRefine(header.refine);\n    this.cacheNode = undefined;\n    this.userData = {};\n\n    // The error, in meters, introduced if this tile is rendered and its children are not.\n    // This is used to compute screen space error, i.e., the error measured in pixels.\n    if ('geometricError' in header) {\n      this.geometricError = header.geometricError;\n    } else {\n      this.geometricError = (this.parent && this.parent.geometricError) || tileset.geometricError;\n      console.warn('3D Tile: Required prop geometricError is undefined. Using parent error');\n    }\n\n    this._initializeTransforms(header);\n    this._initializeBoundingVolumes(header);\n    this._initializeContent(header);\n    this._initializeCache(header);\n\n    // Marks whether the tile's children bounds are fully contained within the tile's bounds\n    // @type {TILE3D_OPTIMIZATION_HINT}\n    this._optimChildrenWithinParent = TILE3D_OPTIMIZATION_HINT.NOT_COMPUTED;\n\n    this._initializeRenderingState();\n\n    Object.seal(this);\n  }\n\n  destroy() {\n    this._header = null;\n  }\n\n  isDestroyed() {\n    return this._header === null;\n  }\n\n  // The tileset containing this tile.\n  get gpuMemoryUsageInBytes() {\n    return this._gpuMemoryUsageInBytes;\n  }\n\n  // The tileset containing this tile.\n  get tileset() {\n    return this._tileset;\n  }\n\n  // The depth of the tile in the tileset tree.\n  get depth() {\n    return this._depth;\n  }\n\n  // The most recent frame that the tile was selected\n  get selectedFrame() {\n    return this._selectedFrame;\n  }\n\n  get isVisibleAndInRequestVolume() {\n    return this._visible && this._inRequestVolume;\n  }\n\n  // The tile's content.  This represents the actual tile's payload,\n  // not the content's metadata in the tileset JSON file.\n  get content() {\n    return this._content;\n  }\n\n  // Determines if the tile's content is ready. This is automatically `true` for\n  // tile's with empty content.\n  get contentReady() {\n    return this._contentState === TILE3D_CONTENT_STATE.READY;\n  }\n\n  // Returns true if tile is not an empty tile and not an external tileset\n  get hasRenderContent() {\n    return !this.hasEmptyContent && !this.hasTilesetContent;\n  }\n\n  // Determines if the tile has available content to render.  `true` if the tile's\n  // content is ready or if it has expired content this renders while new content loads; otherwise,\n  get contentAvailable() {\n    return (\n      (this.contentReady && this.hasRenderContent) ||\n      (defined(this._expiredContent) && !this.contentFailed)\n    );\n  }\n\n  // Returns true if tile has renderable content but it's unloaded\n  get hasUnloadedContent() {\n    return this.hasRenderContent && this.contentUnloaded;\n  }\n\n  // Determines if the tile's content has not be requested. `true` if tile's\n  // content has not be requested; otherwise, `false`.\n  get contentUnloaded() {\n    return this._contentState === TILE3D_CONTENT_STATE.UNLOADED;\n  }\n\n  // Determines if the tile's content is expired. `true` if tile's\n  // content is expired; otherwise, `false`.\n  get contentExpired() {\n    return this._contentState === TILE3D_CONTENT_STATE.EXPIRED;\n  }\n\n  // Determines if the tile's content failed to load.  `true` if the tile's\n  // content failed to load; otherwise, `false`.\n  get contentFailed() {\n    return this._contentState === TILE3D_CONTENT_STATE.FAILED;\n  }\n\n  get url() {\n    return this.tileset.getTileUrl(this.contentUri, this._basePath);\n  }\n\n  get uri() {\n    return this.tileset.getTileUrl(this.contentUri, this._basePath);\n  }\n\n  // Get the tile's bounding volume.\n  get boundingVolume() {\n    return this._boundingVolume;\n  }\n\n  // Get the bounding volume of the tile's contents.  This defaults to the\n  // tile's bounding volume when the content's bounding volume is `undefined`.\n  get contentBoundingVolume() {\n    return this._contentBoundingVolume || this._boundingVolume;\n  }\n\n  // Get the bounding sphere derived from the tile's bounding volume.\n  get boundingSphere() {\n    return this._boundingVolume.boundingSphere;\n  }\n\n  // Returns the `extras` property in the tileset JSON for this tile, which contains application specific metadata.\n  // Returns `undefined` if `extras` does not exist.\n  // @see {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#specifying-extensions-and-application-specific-extras|Extras in the 3D Tiles specification.}\n  get extras() {\n    return this._header.extras;\n  }\n\n  get depth() {\n    return this._depth;\n  }\n\n  // Get the tile's screen space error.\n  getScreenSpaceError(frameState, useParentGeometricError) {\n    const tileset = this._tileset;\n    const parentGeometricError =\n      (this.parent && this.parent.geometricError) || tileset.geometricError;\n    const geometricError = useParentGeometricError ? parentGeometricError : this.geometricError;\n\n    // Leaf tiles do not have any error so save the computation\n    if (geometricError === 0.0) {\n      return 0.0;\n    }\n\n    // TODO: Orthographic Frustum needs special treatment?\n    // this._getOrthograhicScreenSpaceError();\n\n    // Avoid divide by zero when viewer is inside the tile\n    const distance = Math.max(this._distanceToCamera, 1e-7);\n    const {height, sseDenominator} = frameState;\n    let error = (geometricError * height) / (distance * sseDenominator);\n\n    error -= this._getDynamicScreenSpaceError(distance);\n\n    return error;\n  }\n\n  // TODO: Refined screen space error that minimizes tiles in non-first-person\n  _getDynamicScreenSpaceError(distance) {\n    function fog(distanceToCamera, density) {\n      const scalar = distanceToCamera * density;\n      return 1.0 - Math.exp(-(scalar * scalar));\n    }\n\n    const tileset = this._tileset;\n\n    if (tileset.dynamicScreenSpaceError && tileset._dynamicScreenSpaceErrorComputedDensity) {\n      const density = tileset._dynamicScreenSpaceErrorComputedDensity;\n      const factor = tileset.dynamicScreenSpaceErrorFactor;\n      const dynamicError = fog(distance, density) * factor;\n      return dynamicError;\n    }\n\n    return 0;\n  }\n\n  // Requests the tile's content.\n  // The request may not be made if the Request Scheduler can't prioritize it.\n  async loadContent() {\n    if (this.hasEmptyContent) {\n      return false;\n    }\n\n    if (this._content) {\n      return true;\n    }\n\n    const expired = this.contentExpired;\n\n    // Append a query parameter of the tile expiration date to prevent caching\n    // if (expired) {\n    //   expired: this.expireDate.toString()\n    // const request = new Request({\n    //   throttle: true,\n    //   throttleByServer: true,\n    //   type: RequestType.TILES3D,\n    //   priorityFunction: createPriorityFunction(this),\n    //   serverKey: this._serverKey\n    // });\n\n    if (expired) {\n      this.expireDate = undefined;\n    }\n\n    this._contentState = TILE3D_CONTENT_STATE.LOADING;\n\n    function updatePriority(tile) {\n      // Check if any reason to abort\n      if (!tile._visible) {\n        return -1;\n      }\n      if (tile._contentState === TILE3D_CONTENT_STATE.UNLOADED) {\n        return -1;\n      }\n      return Math.max(1e7 - tile._priority, 0) || 0;\n    }\n\n    const cancelled = !(await this.tileset._requestScheduler.scheduleRequest(this, updatePriority));\n\n    if (cancelled) {\n      this._contentState = TILE3D_CONTENT_STATE.UNLOADED;\n      return false;\n    }\n\n    try {\n      const contentUri = this.uri;\n\n      let response;\n      try {\n        this.tileset._requestScheduler.startRequest(this);\n        response = await fetchFile(contentUri, this.tileset.options.fetchOptions);\n      } finally {\n        this.tileset._requestScheduler.endRequest(this);\n      }\n\n      // The content can be a binary tile ot a JSON tileset\n      this._content = await parse(response, [Tile3DLoader, Tileset3DLoader]);\n      // if (Tile3D.isTile(content)) {\n      //   new Tileset3D(content, contentUri);\n\n      if (contentUri.indexOf('.json') !== -1) {\n        // Add tile headers for the nested tilset's subtree\n        // Async update of the tree should be fine since there would never be edits to the same node\n        // TODO - we need to capture the child tileset's URL\n        this._tileset._initializeTileHeaders(this._content, this, path.dirname(this.uri));\n      }\n\n      this._contentState = TILE3D_CONTENT_STATE.READY;\n      this._contentLoaded();\n      return true;\n    } catch (error) {\n      // Tile is unloaded before the content finishes loading\n      this._contentState = TILE3D_CONTENT_STATE.FAILED;\n      throw error;\n    }\n  }\n\n  // Unloads the tile's content.\n  unloadContent() {\n    if (!this.hasRenderContent) {\n      return false;\n    }\n    if (this._content && this._content.destroy) {\n      this._content.destroy();\n    }\n    this._content = null;\n    this._contentState = TILE3D_CONTENT_STATE.UNLOADED;\n    return true;\n  }\n\n  // _getOrthograhicScreenSpaceError() {\n  // if (frustum instanceof OrthographicFrustum) {\n  //   const pixelSize = Math.max(frustum.top - frustum.bottom, frustum.right - frustum.left) / Math.max(width, height);\n  //   error = geometricError / pixelSize;\n  // }\n\n  // Update the tile's visibility.\n  updateVisibility(frameState) {\n    const tileset = this._tileset;\n    if (this._updatedVisibilityFrame === tileset._updatedVisibilityFrame) {\n      // Return early if visibility has already been checked during the traversal.\n      // The visibility may have already been checked if the cullWithChildrenBounds optimization is used.\n      return;\n    }\n\n    const parent = this.parent;\n    const parentTransform = parent ? parent.computedTransform : this._tileset.modelMatrix;\n    const parentVisibilityPlaneMask = parent\n      ? parent._visibilityPlaneMask\n      : CullingVolume.MASK_INDETERMINATE;\n    this._updateTransform(parentTransform);\n    this._distanceToCamera = this.distanceToTile(frameState);\n    // this._centerZDepth = this.cameraSpaceZDepth(frameState);\n    this._screenSpaceError = this.getScreenSpaceError(frameState, false);\n    this._visibilityPlaneMask = this.visibility(frameState, parentVisibilityPlaneMask); // Use parent's plane mask to speed up visibility test\n    this._visible = this._visibilityPlaneMask !== CullingVolume.MASK_OUTSIDE;\n    this._inRequestVolume = this.insideViewerRequestVolume(frameState);\n\n    this._updatedVisibilityFrame = tileset._updatedVisibilityFrame;\n  }\n\n  // Update whether the tile has expired.\n  updateExpiration() {\n    if (defined(this.expireDate) && this.contentReady && !this.hasEmptyContent) {\n      const now = Date.now(scratchDate);\n      if (Date.lessThan(this.expireDate, now)) {\n        this._contentState = TILE3D_CONTENT_STATE.EXPIRED;\n        this._expiredContent = this._content;\n      }\n    }\n  }\n\n  // Determines whether the tile's bounding volume intersects the culling volume.\n  // @param {FrameState} frameState The frame state.\n  // @param {Number} parentVisibilityPlaneMask The parent's plane mask to speed up the visibility check.\n  // @returns {Number} A plane mask as described above in {@link CullingVolume#computeVisibilityWithPlaneMask}.\n  visibility(frameState, parentVisibilityPlaneMask) {\n    const {cullingVolume} = frameState;\n    const {boundingVolume, tileset} = this;\n\n    const {clippingPlanes, clippingPlanesOriginMatrix} = tileset;\n    if (clippingPlanes && clippingPlanes.enabled) {\n      const intersection = clippingPlanes.computeIntersectionWithBoundingVolume(\n        boundingVolume,\n        clippingPlanesOriginMatrix\n      );\n      this._isClipped = intersection !== Intersect.INSIDE;\n      if (intersection === Intersect.OUTSIDE) {\n        return CullingVolume.MASK_OUTSIDE;\n      }\n    }\n\n    // return cullingVolume.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);\n    return computeVisibilityWithPlaneMask(cullingVolume, boundingVolume, parentVisibilityPlaneMask);\n  }\n\n  // Assuming the tile's bounding volume intersects the culling volume, determines\n  // whether the tile's content's bounding volume intersects the culling volume.\n  // @param {FrameState} frameState The frame state.\n  // @returns {Intersect} The result of the intersection: the tile's content is completely outside, completely inside, or intersecting the culling volume.\n  contentVisibility(frameState) {\n    return true;\n    /*\n    // Assumes the tile's bounding volume intersects the culling volume already, so\n    // just return Intersect.INSIDE if there is no content bounding volume.\n    if (!defined(this._contentBoundingVolume)) {\n      return Intersect.INSIDE;\n    }\n\n    if (this._visibilityPlaneMask === CullingVolume.MASK_INSIDE) {\n      // The tile's bounding volume is completely inside the culling volume so\n      // the content bounding volume must also be inside.\n      return Intersect.INSIDE;\n    }\n\n    // PERFORMANCE_IDEA: is it possible to burn less CPU on this test since we know the\n    // tile's (not the content's) bounding volume intersects the culling volume?\n    const cullingVolume = frameState.cullingVolume;\n    const boundingVolume = tile._contentBoundingVolume;\n\n    const tileset = this._tileset;\n    const clippingPlanes = tileset.clippingPlanes;\n    if (defined(clippingPlanes) && clippingPlanes.enabled) {\n      const intersection = clippingPlanes.computeIntersectionWithBoundingVolume(\n        boundingVolume,\n        tileset.clippingPlanesOriginMatrix\n      );\n      this._isClipped = intersection !== Intersect.INSIDE;\n      if (intersection === Intersect.OUTSIDE) {\n        return Intersect.OUTSIDE;\n      }\n    }\n\n    return cullingVolume.computeVisibility(boundingVolume);\n    */\n  }\n\n  // Computes the (potentially approximate) distance from the closest point of the tile's bounding volume to the camera.\n  // @param {FrameState} frameState The frame state.\n  // @returns {Number} The distance, in meters, or zero if the camera is inside the bounding volume.\n  distanceToTile(frameState) {\n    const boundingVolume = this._boundingVolume;\n    return Math.sqrt(boundingVolume.distanceSquaredTo(frameState.camera.position));\n  }\n\n  // Computes the tile's camera-space z-depth.\n  // @param {FrameState} frameState The frame state.\n  // @returns {Number} The distance, in meters.\n  cameraSpaceZDepth({camera}) {\n    const boundingVolume = this.boundingVolume; // Gets the underlying OrientedBoundingBox or BoundingSphere\n    scratchToTileCenter.subVectors(boundingVolume.center, camera.position);\n    return camera.direction.dot(scratchToTileCenter);\n  }\n\n  /**\n   * Checks if the camera is inside the viewer request volume.\n   * @param {FrameState} frameState The frame state.\n   * @returns {Boolean} Whether the camera is inside the volume.\n   */\n  insideViewerRequestVolume(frameState) {\n    const viewerRequestVolume = this._viewerRequestVolume;\n    return !viewerRequestVolume || viewerRequestVolume.distanceToCamera(frameState) === 0.0;\n  }\n\n  // PRIVATE\n\n  _initializeCache(header) {\n    // The node in the tileset's LRU cache, used to determine when to unload a tile's content.\n    this.cacheNode = undefined;\n\n    let expire = header.expire;\n    let expireDuration;\n    let expireDate;\n    if (expire) {\n      expireDuration = expire.duration;\n      if (expire.date) {\n        expireDate = Date.fromIso8601(expire.date);\n      }\n    }\n\n    // The time in seconds after the tile's content is ready when the content expires and new content is requested.\n    // @type {Number}\n    this.expireDuration = expireDuration;\n\n    // The date when the content expires and new content is requested.\n    // @type {Date}\n    this.expireDate = expireDate;\n  }\n\n  _initializeTransforms(tileHeader) {\n    // The local transform of this tile.\n    this.transform = tileHeader.transform ? new Matrix4(tileHeader.transform) : new Matrix4();\n\n    const parent = this.parent;\n    const tileset = this._tileset;\n\n    const parentTransform =\n      parent && parent.computedTransform\n        ? parent.computedTransform.clone()\n        : tileset.modelMatrix.clone();\n    this.computedTransform = new Matrix4(parentTransform).multiplyRight(this.transform);\n\n    const parentInitialTransform =\n      parent && parent._initialTransform ? parent._initialTransform.clone() : new Matrix4();\n    this._initialTransform = new Matrix4(parentInitialTransform).multiplyRight(this.transform);\n  }\n\n  _initializeBoundingVolumes(tileHeader) {\n    this._boundingVolume = createBoundingVolume(tileHeader.boundingVolume, this.computedTransform);\n\n    this._contentBoundingVolume = null;\n    this._viewerRequestVolume = null;\n\n    // Non-leaf tiles may have a content bounding-volume, which is a tight-fit bounding volume\n    // around only the features in the tile. This box is useful for culling for rendering,\n    // but not for culling for traversing the tree since it does not guarantee spatial coherence, i.e.,\n    // since it only bounds features in the tile, not the entire tile, children may be\n    // outside of this box.\n    if (tileHeader.content && tileHeader.content.boundingVolume) {\n      this._contentBoundingVolume = createBoundingVolume(\n        tileHeader.boundingVolume,\n        this.computedTransform\n      );\n    }\n\n    if (tileHeader.viewerRequestVolume) {\n      this._viewerRequestVolume = createBoundingVolume(\n        tileHeader.viewerRequestVolume,\n        this.computedTransform\n      );\n    }\n  }\n\n  _initializeContent(tileHeader) {\n    // Empty tile by default\n    this._content = {_tileset: this._tileset, _tile: this};\n    this.hasEmptyContent = true;\n    this.contentState = TILE3D_CONTENT_STATE.UNLOADED;\n    this._expiredContent = undefined;\n    this._serverKey = null;\n\n    // When `true`, the tile's content points to an external tileset.\n    // This is `false` until the tile's content is loaded.\n    this.hasTilesetContent = false;\n\n    // If a content tileHeader\n    if (tileHeader.content) {\n      this.contentUri = tileHeader.content.uri || tileHeader.content.url;\n      if ('url' in tileHeader) {\n        console.warn('Tileset 3D: \"content.url\" property deprecated. Use \"content.uri\" instead.');\n        this.contentUri = tileHeader.url;\n      }\n      this._content = null;\n      this.hasEmptyContent = false;\n      this.contentState = TILE3D_CONTENT_STATE.UNLOADED;\n      this.fullUri = this._basePath + '/' + this.contentUri;\n      // this.serverKey = RequestScheduler.getServerKey(contentResource.getUrlComponent());\n    }\n  }\n\n  // TODO - remove anything not related to basic visibility detection\n  _initializeRenderingState() {\n    // Members this are updated every frame for tree traversal and rendering optimizations:\n    this._distanceToCamera = 0;\n    this._centerZDepth = 0;\n    this._screenSpaceError = 0;\n    this._visibilityPlaneMask = CullingVolume.MASK_INDETERMINATE;\n    this._visible = false;\n    this._inRequestVolume = false;\n\n    this._finalResolution = true;\n    this._depth = 0;\n    this._stackLength = 0;\n    this._selectionDepth = 0;\n\n    this._updatedVisibilityFrame = 0;\n    this._touchedFrame = 0;\n    this._visitedFrame = 0;\n    this._selectedFrame = 0;\n    this._requestedFrame = 0;\n    this._ancestorWithContent = undefined;\n    this._ancestorWithContentAvailable = undefined;\n    this._refines = false;\n    this._shouldSelect = false;\n    this._priority = 0.0;\n  }\n\n  _getRefine(refine) {\n    switch (refine) {\n      case 'REPLACE':\n      case 'replace':\n        return TILE3D_REFINEMENT.REPLACE;\n      case 'ADD':\n      case 'add':\n        return TILE3D_REFINEMENT.ADD;\n      default:\n        // Inherit from parent tile if omitted.\n        return this.parent ? this.parent.refine : TILE3D_REFINEMENT.REPLACE;\n    }\n  }\n\n  _isTileset(content) {\n    return Boolean(content.asset);\n  }\n\n  _contentLoaded() {\n    // Vector and Geometry tile rendering do not support the skip LOD optimization.\n    switch (this._content && this._content.type) {\n      case 'vctr':\n      case 'geom':\n        tileset.traverser.disableSkipLevelOfDetail = true;\n      default:\n    }\n\n    // The content may be tileset json\n    if (this._isTileset(this._content)) {\n      this.hasTilesetContent = true;\n    }\n  }\n\n  // Update the tile's transform. The transform is applied to the tile's bounding volumes.\n  _updateTransform(parentTransform = new Matrix4()) {\n    const computedTransform = parentTransform.clone().multiplyRight(this.transform);\n    const didTransformChange = !computedTransform.equals(this.computedTransform);\n\n    if (!didTransformChange) {\n      return;\n    }\n\n    this.computedTransform = computedTransform;\n\n    // Matrix4.clone(computedTransform, this.computedTransform);\n\n    // Update the bounding volumes\n    const header = this._header;\n\n    const content = this._header.content;\n    this._boundingVolume = createBoundingVolume(\n      header.boundingVolume,\n      this.computedTransform,\n      this._boundingVolume\n    );\n    if (this._contentBoundingVolume) {\n      this._contentBoundingVolume = createBoundingVolume(\n        content.boundingVolume,\n        this.computedTransform,\n        this._contentBoundingVolume\n      );\n    }\n    if (this._viewerRequestVolume) {\n      this._viewerRequestVolume = createBoundingVolume(\n        header.viewerRequestVolume,\n        this.computedTransform,\n        this._viewerRequestVolume\n      );\n    }\n  }\n}\n\nfunction updateContent(tile, tileset, frameState) {\n  const content = tile._content;\n  const expiredContent = tile._expiredContent;\n\n  if (expiredContent) {\n    if (!tile.contentReady) {\n      // Render the expired content while the content loads\n      expiredContent.update(tileset, frameState);\n      return;\n    }\n\n    // New content is ready, destroy expired content\n    tile._expiredContent.destroy();\n    tile._expiredContent = undefined;\n  }\n\n  content.update(tileset, frameState);\n}\n\nfunction updateExpireDate(tile) {\n  if (defined(tile.expireDuration)) {\n    const expireDurationDate = Date.now(scratchDate);\n    Date.addSeconds(expireDurationDate, tile.expireDuration, expireDurationDate);\n\n    if (defined(tile.expireDate)) {\n      if (Date.lessThan(tile.expireDate, expireDurationDate)) {\n        Date.clone(expireDurationDate, tile.expireDate);\n      }\n    } else {\n      tile.expireDate = Date.clone(expireDurationDate);\n    }\n  }\n}\n\nfunction createPriorityFunction(tile) {\n  return function() {\n    return tile._priority;\n  };\n}\n"],"file":"tile-3d-header.js"}