(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/bundle.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js":
/*!**************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _arrayWithHoles; });
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js":
/*!*****************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js ***!
  \*****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _arrayWithoutHoles; });
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js":
/*!*********************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js ***!
  \*********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _assertThisInitialized; });
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js":
/*!**************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@babel/runtime/helpers/esm/classCallCheck.js ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _classCallCheck; });
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/construct.js":
/*!*********************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@babel/runtime/helpers/esm/construct.js ***!
  \*********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _construct; });
/* harmony import */ var _setPrototypeOf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf */ "../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js");


function isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) Object(_setPrototypeOf__WEBPACK_IMPORTED_MODULE_0__["default"])(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!***********************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _createClass; });
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!**************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _defineProperty; });
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js":
/*!**************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _getPrototypeOf; });
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/inherits.js":
/*!********************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@babel/runtime/helpers/esm/inherits.js ***!
  \********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _inherits; });
/* harmony import */ var _setPrototypeOf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf */ "../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object(_setPrototypeOf__WEBPACK_IMPORTED_MODULE_0__["default"])(subClass, superClass);
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/isNativeFunction.js":
/*!****************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@babel/runtime/helpers/esm/isNativeFunction.js ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _isNativeFunction; });
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/iterableToArray.js":
/*!***************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@babel/runtime/helpers/esm/iterableToArray.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _iterableToArray; });
function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js":
/*!********************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js ***!
  \********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _iterableToArrayLimit; });
function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js":
/*!***************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _nonIterableRest; });
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js":
/*!*****************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js ***!
  \*****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _nonIterableSpread; });
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/objectSpread.js":
/*!************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@babel/runtime/helpers/esm/objectSpread.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _objectSpread; });
/* harmony import */ var _defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defineProperty */ "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js");

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      Object(_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]);
    });
  }

  return target;
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js":
/*!*************************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js ***!
  \*************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _possibleConstructorReturn; });
/* harmony import */ var _helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../helpers/esm/typeof */ "../../node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assertThisInitialized */ "../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");


function _possibleConstructorReturn(self, call) {
  if (call && (Object(_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(call) === "object" || typeof call === "function")) {
    return call;
  }

  return Object(_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__["default"])(self);
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js":
/*!**************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _setPrototypeOf; });
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js":
/*!*************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@babel/runtime/helpers/esm/slicedToArray.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _slicedToArray; });
/* harmony import */ var _arrayWithHoles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithHoles */ "../../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js");
/* harmony import */ var _iterableToArrayLimit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArrayLimit */ "../../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js");
/* harmony import */ var _nonIterableRest__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nonIterableRest */ "../../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js");



function _slicedToArray(arr, i) {
  return Object(_arrayWithHoles__WEBPACK_IMPORTED_MODULE_0__["default"])(arr) || Object(_iterableToArrayLimit__WEBPACK_IMPORTED_MODULE_1__["default"])(arr, i) || Object(_nonIterableRest__WEBPACK_IMPORTED_MODULE_2__["default"])();
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js":
/*!*****************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js ***!
  \*****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _toConsumableArray; });
/* harmony import */ var _arrayWithoutHoles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithoutHoles */ "../../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js");
/* harmony import */ var _iterableToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArray */ "../../node_modules/@babel/runtime/helpers/esm/iterableToArray.js");
/* harmony import */ var _nonIterableSpread__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nonIterableSpread */ "../../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js");



function _toConsumableArray(arr) {
  return Object(_arrayWithoutHoles__WEBPACK_IMPORTED_MODULE_0__["default"])(arr) || Object(_iterableToArray__WEBPACK_IMPORTED_MODULE_1__["default"])(arr) || Object(_nonIterableSpread__WEBPACK_IMPORTED_MODULE_2__["default"])();
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!******************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _typeof; });
function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js":
/*!***************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _wrapNativeSuper; });
/* harmony import */ var _getPrototypeOf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getPrototypeOf */ "../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _setPrototypeOf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./setPrototypeOf */ "../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js");
/* harmony import */ var _isNativeFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isNativeFunction */ "../../node_modules/@babel/runtime/helpers/esm/isNativeFunction.js");
/* harmony import */ var _construct__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./construct */ "../../node_modules/@babel/runtime/helpers/esm/construct.js");




function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !Object(_isNativeFunction__WEBPACK_IMPORTED_MODULE_2__["default"])(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return Object(_construct__WEBPACK_IMPORTED_MODULE_3__["default"])(Class, arguments, Object(_getPrototypeOf__WEBPACK_IMPORTED_MODULE_0__["default"])(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return Object(_setPrototypeOf__WEBPACK_IMPORTED_MODULE_1__["default"])(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

/***/ }),

/***/ "../../node_modules/@math.gl/culling/dist/esm/algorithms/bounding-box-from-points.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@math.gl/culling/dist/esm/algorithms/bounding-box-from-points.js ***!
  \**********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return makeOrientedBoundingBoxfromPoints; });
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");
/* harmony import */ var _compute_eigen_decomposition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./compute-eigen-decomposition */ "../../node_modules/@math.gl/culling/dist/esm/algorithms/compute-eigen-decomposition.js");


var scratchVector2 = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var scratchVector3 = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var scratchVector4 = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var scratchVector5 = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var scratchVector6 = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var scratchCovarianceResult = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix3"]();
var scratchEigenResult = {
  diagonal: new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix3"](),
  unitary: new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix3"]()
};
function makeOrientedBoundingBoxfromPoints(positions, result) {
  if (!positions || positions.length === 0) {
    result.halfAxes = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix3"]([0, 0, 0, 0, 0, 0, 0, 0, 0]);
    result.center = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
    return result;
  }

  var length = positions.length;
  var meanPoint = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 0);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = positions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var position = _step.value;
      meanPoint.add(position);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var invLength = 1.0 / length;
  meanPoint.multiplyByScalar(invLength);
  var exx = 0.0;
  var exy = 0.0;
  var exz = 0.0;
  var eyy = 0.0;
  var eyz = 0.0;
  var ezz = 0.0;
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = positions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _position = _step2.value;
      var p = scratchVector2.copy(_position).subtract(meanPoint);
      exx += p.x * p.x;
      exy += p.x * p.y;
      exz += p.x * p.z;
      eyy += p.y * p.y;
      eyz += p.y * p.z;
      ezz += p.z * p.z;
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  exx *= invLength;
  exy *= invLength;
  exz *= invLength;
  eyy *= invLength;
  eyz *= invLength;
  ezz *= invLength;
  var covarianceMatrix = scratchCovarianceResult;
  covarianceMatrix[0] = exx;
  covarianceMatrix[1] = exy;
  covarianceMatrix[2] = exz;
  covarianceMatrix[3] = exy;
  covarianceMatrix[4] = eyy;
  covarianceMatrix[5] = eyz;
  covarianceMatrix[6] = exz;
  covarianceMatrix[7] = eyz;
  covarianceMatrix[8] = ezz;

  var _computeEigenDecompos = Object(_compute_eigen_decomposition__WEBPACK_IMPORTED_MODULE_1__["default"])(covarianceMatrix, scratchEigenResult),
      unitary = _computeEigenDecompos.unitary;

  var rotation = result.halfAxes.copy(unitary);
  var v1 = rotation.getColumn(0, scratchVector4);
  var v2 = rotation.getColumn(1, scratchVector5);
  var v3 = rotation.getColumn(2, scratchVector6);
  var u1 = -Number.MAX_VALUE;
  var u2 = -Number.MAX_VALUE;
  var u3 = -Number.MAX_VALUE;
  var l1 = Number.MAX_VALUE;
  var l2 = Number.MAX_VALUE;
  var l3 = Number.MAX_VALUE;
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = positions[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var _position2 = _step3.value;
      u1 = Math.max(_position2.dot(v1), u1);
      u2 = Math.max(_position2.dot(v2), u2);
      u3 = Math.max(_position2.dot(v3), u3);
      l1 = Math.min(_position2.dot(v1), l1);
      l2 = Math.min(_position2.dot(v2), l2);
      l3 = Math.min(_position2.dot(v3), l3);
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  v1 = v1.multiplyByScalar(0.5 * (l1 + u1));
  v2 = v2.multiplyByScalar(0.5 * (l2 + u2));
  v3 = v3.multiplyByScalar(0.5 * (l3 + u3));
  result.center.copy(v1).add(v2).add(v3);
  var scale = scratchVector3.set(u1 - l1, u2 - l2, u3 - l3).multiplyByScalar(0.5);
  result.halfAxes.multiplyByScalar(scale);
  return result;
}
//# sourceMappingURL=bounding-box-from-points.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/culling/dist/esm/algorithms/bounding-sphere-from-points.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@math.gl/culling/dist/esm/algorithms/bounding-sphere-from-points.js ***!
  \*************************************************************************************************************************/
/*! exports provided: makeBoundingSphereFromPoints */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeBoundingSphereFromPoints", function() { return makeBoundingSphereFromPoints; });
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");
/* harmony import */ var _lib_bounding_sphere__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/bounding-sphere */ "../../node_modules/@math.gl/culling/dist/esm/lib/bounding-sphere.js");


var fromPointsXMin = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var fromPointsYMin = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var fromPointsZMin = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var fromPointsXMax = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var fromPointsYMax = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var fromPointsZMax = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var fromPointsCurrentPos = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var fromPointsScratch = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var fromPointsRitterCenter = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var fromPointsMinBoxPt = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var fromPointsMaxBoxPt = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var fromPointsNaiveCenterScratch = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var volumeConstant = 4.0 / 3.0 * Math.PI;
function makeBoundingSphereFromPoints(positions) {
  var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _lib_bounding_sphere__WEBPACK_IMPORTED_MODULE_1__["default"]();

  if (!positions || positions.length === 0) {
    return result.fromCenterRadius([0, 0, 0], 0);
  }

  var currentPos = fromPointsCurrentPos.copy(positions[0]);
  var xMin = fromPointsXMin.copy(currentPos);
  var yMin = fromPointsYMin.copy(currentPos);
  var zMin = fromPointsZMin.copy(currentPos);
  var xMax = fromPointsXMax.copy(currentPos);
  var yMax = fromPointsYMax.copy(currentPos);
  var zMax = fromPointsZMax.copy(currentPos);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = positions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var position = _step.value;
      currentPos.copy(position);
      var x = currentPos.x;
      var y = currentPos.y;
      var z = currentPos.z;

      if (x < xMin.x) {
        currentPos.copy(xMin);
      }

      if (x > xMax.x) {
        currentPos.copy(xMax);
      }

      if (y < yMin.y) {
        currentPos.copy(yMin);
      }

      if (y > yMax.y) {
        currentPos.copy(yMax);
      }

      if (z < zMin.z) {
        currentPos.copy(zMin);
      }

      if (z > zMax.z) {
        currentPos.copy(zMax);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var xSpan = fromPointsScratch.copy(xMax).subtract(xMin).magnitudeSquared();
  var ySpan = fromPointsScratch.copy(yMax).subtract(yMin).magnitudeSquared();
  var zSpan = fromPointsScratch.copy(zMax).subtract(zMin).magnitudeSquared();
  var diameter1 = xMin;
  var diameter2 = xMax;
  var maxSpan = xSpan;

  if (ySpan > maxSpan) {
    maxSpan = ySpan;
    diameter1 = yMin;
    diameter2 = yMax;
  }

  if (zSpan > maxSpan) {
    maxSpan = zSpan;
    diameter1 = zMin;
    diameter2 = zMax;
  }

  var ritterCenter = fromPointsRitterCenter;
  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;
  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;
  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;
  var radiusSquared = fromPointsScratch.copy(diameter2).subtract(ritterCenter).magnitudeSquared();
  var ritterRadius = Math.sqrt(radiusSquared);
  var minBoxPt = fromPointsMinBoxPt;
  minBoxPt.x = xMin.x;
  minBoxPt.y = yMin.y;
  minBoxPt.z = zMin.z;
  var maxBoxPt = fromPointsMaxBoxPt;
  maxBoxPt.x = xMax.x;
  maxBoxPt.y = yMax.y;
  maxBoxPt.z = zMax.z;
  var naiveCenter = fromPointsNaiveCenterScratch.copy(minBoxPt).add(maxBoxPt).multiplyByScalar(0.5);
  var naiveRadius = 0;
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = positions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _position = _step2.value;
      currentPos.copy(_position);
      var r = fromPointsScratch.copy(currentPos).subtract(naiveCenter).magnitude();

      if (r > naiveRadius) {
        naiveRadius = r;
      }

      var oldCenterToPointSquared = fromPointsScratch.copy(currentPos).subtract(ritterCenter).magnitudeSquared();

      if (oldCenterToPointSquared > radiusSquared) {
        var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);
        ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;
        radiusSquared = ritterRadius * ritterRadius;
        var oldToNew = oldCenterToPoint - ritterRadius;
        ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;
        ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;
        ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  if (ritterRadius < naiveRadius) {
    ritterCenter.to(result.center);
    result.radius = ritterRadius;
  } else {
    naiveCenter.to(result.center);
    result.radius = naiveRadius;
  }

  return result;
}
//# sourceMappingURL=bounding-sphere-from-points.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/culling/dist/esm/algorithms/compute-eigen-decomposition.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@math.gl/culling/dist/esm/algorithms/compute-eigen-decomposition.js ***!
  \*************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return computeEigenDecomposition; });
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");

var scratchMatrix = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix3"]();
var scratchUnitary = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix3"]();
var scratchDiagonal = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix3"]();
var jMatrix = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix3"]();
var jMatrixTranspose = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix3"]();
function computeEigenDecomposition(matrix) {
  var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var EIGEN_TOLERANCE = math_gl__WEBPACK_IMPORTED_MODULE_0__["_MathUtils"].EPSILON20;
  var EIGEN_MAX_SWEEPS = 10;
  var count = 0;
  var sweep = 0;
  var unitaryMatrix = scratchUnitary;
  var diagonalMatrix = scratchDiagonal;
  unitaryMatrix.identity();
  diagonalMatrix.copy(matrix);
  var epsilon = EIGEN_TOLERANCE * computeFrobeniusNorm(diagonalMatrix);

  while (sweep < EIGEN_MAX_SWEEPS && offDiagonalFrobeniusNorm(diagonalMatrix) > epsilon) {
    shurDecomposition(diagonalMatrix, jMatrix);
    jMatrixTranspose.copy(jMatrix).transpose();
    diagonalMatrix.multiplyRight(jMatrix);
    diagonalMatrix.multiplyLeft(jMatrixTranspose);
    unitaryMatrix.multiplyRight(jMatrix);

    if (++count > 2) {
      ++sweep;
      count = 0;
    }
  }

  result.unitary = unitaryMatrix.toTarget(result.unitary);
  result.diagonal = diagonalMatrix.toTarget(result.diagonal);
  return result;
}

function computeFrobeniusNorm(matrix) {
  var norm = 0.0;

  for (var i = 0; i < 9; ++i) {
    var temp = matrix[i];
    norm += temp * temp;
  }

  return Math.sqrt(norm);
}

var rowVal = [1, 0, 0];
var colVal = [2, 2, 1];

function offDiagonalFrobeniusNorm(matrix) {
  var norm = 0.0;

  for (var i = 0; i < 3; ++i) {
    var temp = matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])];
    norm += 2.0 * temp * temp;
  }

  return Math.sqrt(norm);
}

function shurDecomposition(matrix, result) {
  var tolerance = math_gl__WEBPACK_IMPORTED_MODULE_0__["_MathUtils"].EPSILON15;
  var maxDiagonal = 0.0;
  var rotAxis = 1;

  for (var i = 0; i < 3; ++i) {
    var temp = Math.abs(matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])]);

    if (temp > maxDiagonal) {
      rotAxis = i;
      maxDiagonal = temp;
    }
  }

  var p = rowVal[rotAxis];
  var q = colVal[rotAxis];
  var c = 1.0;
  var s = 0.0;

  if (Math.abs(matrix[scratchMatrix.getElementIndex(q, p)]) > tolerance) {
    var qq = matrix[scratchMatrix.getElementIndex(q, q)];
    var pp = matrix[scratchMatrix.getElementIndex(p, p)];
    var qp = matrix[scratchMatrix.getElementIndex(q, p)];
    var tau = (qq - pp) / 2.0 / qp;
    var t;

    if (tau < 0.0) {
      t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));
    } else {
      t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));
    }

    c = 1.0 / Math.sqrt(1.0 + t * t);
    s = t * c;
  }

  math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix3"].IDENTITY.to(result);
  result[scratchMatrix.getElementIndex(p, p)] = result[scratchMatrix.getElementIndex(q, q)] = c;
  result[scratchMatrix.getElementIndex(q, p)] = s;
  result[scratchMatrix.getElementIndex(p, q)] = -s;
  return result;
}
//# sourceMappingURL=compute-eigen-decomposition.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/culling/dist/esm/constants.js":
/*!********************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@math.gl/culling/dist/esm/constants.js ***!
  \********************************************************************************************/
/*! exports provided: INTERSECT, Intersect */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INTERSECT", function() { return INTERSECT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Intersect", function() { return Intersect; });
var INTERSECT = Object.freeze({
  OUTSIDE: -1,
  INTERSECTING: 0,
  INSIDE: 1
});
var Intersect = INTERSECT;
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/culling/dist/esm/index.js":
/*!****************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@math.gl/culling/dist/esm/index.js ***!
  \****************************************************************************************/
/*! exports provided: INTERSECT, Intersect, AxisAlignedBoundingBox, BoundingSphere, OrientedBoundingBox, CullingVolume, Plane, _PerspectiveOffCenterFrustum, _PerspectiveFrustum, makeBoundingSphereFromPoints */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "../../node_modules/@math.gl/culling/dist/esm/constants.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "INTERSECT", function() { return _constants__WEBPACK_IMPORTED_MODULE_0__["INTERSECT"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Intersect", function() { return _constants__WEBPACK_IMPORTED_MODULE_0__["INTERSECT"]; });

/* harmony import */ var _lib_axis_aligned_bounding_box__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/axis-aligned-bounding-box */ "../../node_modules/@math.gl/culling/dist/esm/lib/axis-aligned-bounding-box.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AxisAlignedBoundingBox", function() { return _lib_axis_aligned_bounding_box__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _lib_bounding_sphere__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/bounding-sphere */ "../../node_modules/@math.gl/culling/dist/esm/lib/bounding-sphere.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BoundingSphere", function() { return _lib_bounding_sphere__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _lib_oriented_bounding_box__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/oriented-bounding-box */ "../../node_modules/@math.gl/culling/dist/esm/lib/oriented-bounding-box.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OrientedBoundingBox", function() { return _lib_oriented_bounding_box__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _lib_culling_volume__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/culling-volume */ "../../node_modules/@math.gl/culling/dist/esm/lib/culling-volume.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CullingVolume", function() { return _lib_culling_volume__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _lib_plane__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/plane */ "../../node_modules/@math.gl/culling/dist/esm/lib/plane.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Plane", function() { return _lib_plane__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _lib_perspective_off_center_frustum__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/perspective-off-center-frustum */ "../../node_modules/@math.gl/culling/dist/esm/lib/perspective-off-center-frustum.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_PerspectiveOffCenterFrustum", function() { return _lib_perspective_off_center_frustum__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _lib_perspective_frustum__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/perspective-frustum */ "../../node_modules/@math.gl/culling/dist/esm/lib/perspective-frustum.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_PerspectiveFrustum", function() { return _lib_perspective_frustum__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _algorithms_bounding_sphere_from_points__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./algorithms/bounding-sphere-from-points */ "../../node_modules/@math.gl/culling/dist/esm/algorithms/bounding-sphere-from-points.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "makeBoundingSphereFromPoints", function() { return _algorithms_bounding_sphere_from_points__WEBPACK_IMPORTED_MODULE_8__["makeBoundingSphereFromPoints"]; });











//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/culling/dist/esm/lib/axis-aligned-bounding-box.js":
/*!****************************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@math.gl/culling/dist/esm/lib/axis-aligned-bounding-box.js ***!
  \****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AxisAlignedBoundingBox; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants */ "../../node_modules/@math.gl/culling/dist/esm/constants.js");




var scratchVector = new math_gl__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
var scratchNormal = new math_gl__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();

var AxisAlignedBoundingBox = function () {
  function AxisAlignedBoundingBox() {
    var minimum = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];
    var maximum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
    var center = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, AxisAlignedBoundingBox);

    center = center || scratchVector.copy(minimum).add(maximum).scale(0.5);
    this.minimum = new math_gl__WEBPACK_IMPORTED_MODULE_2__["Vector3"](minimum);
    this.maximum = new math_gl__WEBPACK_IMPORTED_MODULE_2__["Vector3"](maximum);
    this.center = new math_gl__WEBPACK_IMPORTED_MODULE_2__["Vector3"](center);
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(AxisAlignedBoundingBox, [{
    key: "fromPoints",
    value: function fromPoints(positions) {
      if (!positions || positions.length === 0) {
        this.minimum.set(0, 0, 0);
        this.maximum.set(0, 0, 0);
        this.center.set(0, 0, 0);
        return this;
      }

      var minimumX = positions[0][0];
      var minimumY = positions[0][1];
      var minimumZ = positions[0][2];
      var maximumX = positions[0][0];
      var maximumY = positions[0][1];
      var maximumZ = positions[0][2];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = positions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var p = _step.value;
          var x = p[0];
          var y = p[1];
          var z = p[2];
          minimumX = Math.min(x, minimumX);
          maximumX = Math.max(x, maximumX);
          minimumY = Math.min(y, minimumY);
          maximumY = Math.max(y, maximumY);
          minimumZ = Math.min(z, minimumZ);
          maximumZ = Math.max(z, maximumZ);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.minimum.set(minimumX, minimumY, minimumZ);
      this.maximum.set(maximumX, maximumY, maximumZ);
      this.center.copy(this.minimum).add(this.maximum).scale(0.5);
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);
    }
  }, {
    key: "equals",
    value: function equals(right) {
      return this === right || Boolean(right) && this.center.equals(right.center) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum);
    }
  }, {
    key: "intersectPlane",
    value: function intersectPlane(plane) {
      var h = scratchVector.copy(this.maximum).subtract(this.minimum).scale(0.5);
      var normal = scratchNormal.from(plane.normal);
      var e = h.x * Math.abs(normal.x) + h.y * Math.abs(normal.y) + h.z * Math.abs(normal.z);
      var s = this.center.dot(normal) + plane.distance;

      if (s - e > 0) {
        return _constants__WEBPACK_IMPORTED_MODULE_3__["Intersect"].INSIDE;
      }

      if (s + e < 0) {
        return _constants__WEBPACK_IMPORTED_MODULE_3__["Intersect"].OUTSIDE;
      }

      return _constants__WEBPACK_IMPORTED_MODULE_3__["Intersect"].INTERSECTING;
    }
  }]);

  return AxisAlignedBoundingBox;
}();


//# sourceMappingURL=axis-aligned-bounding-box.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/culling/dist/esm/lib/bounding-sphere.js":
/*!******************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@math.gl/culling/dist/esm/lib/bounding-sphere.js ***!
  \******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BoundingSphere; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");
/* harmony import */ var gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gl-matrix/mat4 */ "../../node_modules/gl-matrix/esm/mat4.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants */ "../../node_modules/@math.gl/culling/dist/esm/constants.js");





var scratchVector = new math_gl__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
var scratchVector2 = new math_gl__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();

var BoundingSphere = function () {
  function BoundingSphere() {
    var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];
    var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, BoundingSphere);

    this.radius = -0;
    this.center = new math_gl__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
    this.fromCenterRadius(center, radius);
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(BoundingSphere, [{
    key: "fromCenterRadius",
    value: function fromCenterRadius(center, radius) {
      this.center.from(center);
      this.radius = radius;
      return this;
    }
  }, {
    key: "fromCornerPoints",
    value: function fromCornerPoints(corner, oppositeCorner) {
      oppositeCorner = scratchVector.from(oppositeCorner);
      this.center = new math_gl__WEBPACK_IMPORTED_MODULE_2__["Vector3"]().from(corner).add(oppositeCorner).scale(0.5);
      this.radius = this.center.distance(oppositeCorner);
      return this;
    }
  }, {
    key: "equals",
    value: function equals(right) {
      return this === right || Boolean(right) && this.center.equals(right.center) && this.radius === right.radius;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new BoundingSphere(this.center, this.radius);
    }
  }, {
    key: "union",
    value: function union(boundingSphere) {
      var leftCenter = this.center;
      var leftRadius = this.radius;
      var rightCenter = boundingSphere.center;
      var rightRadius = boundingSphere.radius;
      var toRightCenter = scratchVector.copy(rightCenter).subtract(leftCenter);
      var centerSeparation = toRightCenter.magnitude();

      if (leftRadius >= centerSeparation + rightRadius) {
        return this.clone();
      }

      if (rightRadius >= centerSeparation + leftRadius) {
        return boundingSphere.clone();
      }

      var halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;
      scratchVector2.copy(toRightCenter).scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation).add(leftCenter);
      this.center.copy(scratchVector2);
      this.radius = halfDistanceBetweenTangentPoints;
      return this;
    }
  }, {
    key: "expand",
    value: function expand(point) {
      point = scratchVector.from(point);
      var radius = point.subtract(this.center).magnitude();

      if (radius > this.radius) {
        this.radius = radius;
      }

      return this;
    }
  }, {
    key: "intersectPlane",
    value: function intersectPlane(plane) {
      var center = this.center;
      var radius = this.radius;
      var normal = plane.normal;
      var distanceToPlane = normal.dot(center) + plane.distance;

      if (distanceToPlane < -radius) {
        return _constants__WEBPACK_IMPORTED_MODULE_4__["Intersect"].OUTSIDE;
      }

      if (distanceToPlane < radius) {
        return _constants__WEBPACK_IMPORTED_MODULE_4__["Intersect"].INTERSECTING;
      }

      return _constants__WEBPACK_IMPORTED_MODULE_4__["Intersect"].INSIDE;
    }
  }, {
    key: "transform",
    value: function transform(_transform) {
      this.center.transform(_transform);
      var scale = gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_3__["getScaling"](scratchVector, _transform);
      this.radius = Math.max(scale[0], Math.max(scale[1], scale[2])) * this.radius;
      return this;
    }
  }, {
    key: "distanceSquaredTo",
    value: function distanceSquaredTo(point) {
      point = scratchVector.from(point);
      var delta = point.subtract(this.center);
      return delta.lengthSquared() - this.radius * this.radius;
    }
  }, {
    key: "distanceTo",
    value: function distanceTo(point) {
      return Math.sqrt(this.distanceSquaredTo(point));
    }
  }]);

  return BoundingSphere;
}();


//# sourceMappingURL=bounding-sphere.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/culling/dist/esm/lib/culling-volume.js":
/*!*****************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@math.gl/culling/dist/esm/lib/culling-volume.js ***!
  \*****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CullingVolume; });
/* harmony import */ var _babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/toConsumableArray */ "../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants */ "../../node_modules/@math.gl/culling/dist/esm/constants.js");
/* harmony import */ var _plane__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./plane */ "../../node_modules/@math.gl/culling/dist/esm/lib/plane.js");






var faces = [new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector3"]([1, 0, 0]), new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector3"]([0, 1, 0]), new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector3"]([0, 0, 1])];
var scratchPlaneCenter = new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector3"]();
var scratchPlaneNormal = new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector3"]();
var scratchPlane = new _plane__WEBPACK_IMPORTED_MODULE_5__["default"](new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector3"](1.0, 0.0, 0.0), 0.0);

var CullingVolume = function () {
  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__["default"])(CullingVolume, null, [{
    key: "MASK_OUTSIDE",
    get: function get() {
      return 0xffffffff;
    }
  }, {
    key: "MASK_INSIDE",
    get: function get() {
      return 0x00000000;
    }
  }, {
    key: "MASK_INDETERMINATE",
    get: function get() {
      return 0x7fffffff;
    }
  }]);

  function CullingVolume() {
    var planes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__["default"])(this, CullingVolume);

    this.planes = planes;
    Object(math_gl__WEBPACK_IMPORTED_MODULE_3__["assert"])(this.planes.every(function (plane) {
      return plane instanceof _plane__WEBPACK_IMPORTED_MODULE_5__["default"];
    }));
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__["default"])(CullingVolume, [{
    key: "fromBoundingSphere",
    value: function fromBoundingSphere(boundingSphere) {
      this.planes.length = 2 * faces.length;
      var center = boundingSphere.center;
      var radius = boundingSphere.radius;
      var planeIndex = 0;

      for (var _i = 0, _faces = faces; _i < _faces.length; _i++) {
        var faceNormal = _faces[_i];
        var plane0 = this.planes[planeIndex];
        var plane1 = this.planes[planeIndex + 1];

        if (!plane0) {
          plane0 = this.planes[planeIndex] = new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector4"]();
        }

        if (!plane1) {
          plane1 = this.planes[planeIndex + 1] = new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector4"]();
        }

        var plane0Center = scratchPlaneCenter.copy(faceNormal).scale(-radius).add(center);
        var plane0Distance = -faceNormal.dot(plane0Center);
        plane0.x = faceNormal.x;
        plane0.y = faceNormal.y;
        plane0.z = faceNormal.z;
        plane0.w = plane0Distance;
        var plane1Center = scratchPlaneCenter.copy(faceNormal).scale(radius).add(center);
        var negatedFaceNormal = scratchPlaneNormal.copy(faceNormal).negate();
        var plane1Distance = -negatedFaceNormal.dot(plane1Center);
        plane1.x = negatedFaceNormal.x;
        plane1.y = negatedFaceNormal.y;
        plane1.z = negatedFaceNormal.z;
        plane1.w = plane1Distance;
        planeIndex += 2;
      }

      return this;
    }
  }, {
    key: "computeVisibility",
    value: function computeVisibility(boundingVolume) {
      Object(math_gl__WEBPACK_IMPORTED_MODULE_3__["assert"])(boundingVolume);
      var intersect = _constants__WEBPACK_IMPORTED_MODULE_4__["Intersect"].INSIDE;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.planes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var planeCoefficients = _step.value;
          var plane = scratchPlane.fromCoefficients.apply(scratchPlane, Object(_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__["default"])(planeCoefficients));
          var result = boundingVolume.intersectPlane(plane);

          switch (result) {
            case _constants__WEBPACK_IMPORTED_MODULE_4__["Intersect"].OUTSIDE:
              return _constants__WEBPACK_IMPORTED_MODULE_4__["Intersect"].OUTSIDE;

            case _constants__WEBPACK_IMPORTED_MODULE_4__["Intersect"].INTERSECTING:
              intersect = _constants__WEBPACK_IMPORTED_MODULE_4__["Intersect"].INTERSECTING;
              break;

            default:
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return intersect;
    }
  }, {
    key: "computeVisibilityWithPlaneMask",
    value: function computeVisibilityWithPlaneMask(boundingVolume, parentPlaneMask) {
      Object(math_gl__WEBPACK_IMPORTED_MODULE_3__["assert"])(boundingVolume, 'boundingVolume is required.');
      Object(math_gl__WEBPACK_IMPORTED_MODULE_3__["assert"])(Number.isFinite(parentPlaneMask), 'parentPlaneMask is required.');

      if (parentPlaneMask === CullingVolume.MASK_OUTSIDE || parentPlaneMask === CullingVolume.MASK_INSIDE) {
        return parentPlaneMask;
      }

      var mask = CullingVolume.MASK_INSIDE;
      var planes = this.planes;

      for (var k = 0; k < this.planes.length; ++k) {
        var flag = k < 31 ? 1 << k : 0;

        if (k < 31 && (parentPlaneMask & flag) === 0) {
          continue;
        }

        var plane = scratchPlane.fromCoefficients.apply(scratchPlane, Object(_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__["default"])(planes[k]));
        var result = boundingVolume.intersectPlane(plane);

        if (result === _constants__WEBPACK_IMPORTED_MODULE_4__["Intersect"].OUTSIDE) {
          return CullingVolume.MASK_OUTSIDE;
        } else if (result === _constants__WEBPACK_IMPORTED_MODULE_4__["Intersect"].INTERSECTING) {
          mask |= flag;
        }
      }

      return mask;
    }
  }]);

  return CullingVolume;
}();


//# sourceMappingURL=culling-volume.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/culling/dist/esm/lib/oriented-bounding-box.js":
/*!************************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@math.gl/culling/dist/esm/lib/oriented-bounding-box.js ***!
  \************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return OrientedBoundingBox; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");
/* harmony import */ var _bounding_sphere__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bounding-sphere */ "../../node_modules/@math.gl/culling/dist/esm/lib/bounding-sphere.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants */ "../../node_modules/@math.gl/culling/dist/esm/constants.js");
/* harmony import */ var _algorithms_bounding_box_from_points__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../algorithms/bounding-box-from-points */ "../../node_modules/@math.gl/culling/dist/esm/algorithms/bounding-box-from-points.js");






var scratchVector = new math_gl__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
var scratchOffset = new math_gl__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
var scratchVectorU = new math_gl__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
var scratchVectorV = new math_gl__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
var scratchVectorW = new math_gl__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
var scratchPPrime = new math_gl__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
var scratchCorner = new math_gl__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
var scratchToCenter = new math_gl__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
var fromOrientedBoundingBoxScratchU = new math_gl__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
var fromOrientedBoundingBoxScratchV = new math_gl__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
var fromOrientedBoundingBoxScratchW = new math_gl__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
var MATRIX3 = {
  COLUMN0ROW0: 0,
  COLUMN0ROW1: 1,
  COLUMN0ROW2: 2,
  COLUMN1ROW0: 3,
  COLUMN1ROW1: 4,
  COLUMN1ROW2: 5,
  COLUMN2ROW0: 6,
  COLUMN2ROW1: 7,
  COLUMN2ROW2: 8
};

var OrientedBoundingBox = function () {
  function OrientedBoundingBox() {
    var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];
    var halfAxes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0, 0, 0, 0, 0, 0, 0];

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, OrientedBoundingBox);

    this.center = new math_gl__WEBPACK_IMPORTED_MODULE_2__["Vector3"]().from(center);
    this.halfAxes = new math_gl__WEBPACK_IMPORTED_MODULE_2__["Matrix3"](halfAxes);
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(OrientedBoundingBox, [{
    key: "clone",
    value: function clone(result) {
      return new OrientedBoundingBox(this.center, this.halfAxes);
    }
  }, {
    key: "fromPoints",
    value: function fromPoints(points) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new OrientedBoundingBox();
      return Object(_algorithms_bounding_box_from_points__WEBPACK_IMPORTED_MODULE_5__["default"])(points, result);
    }
  }, {
    key: "equals",
    value: function equals(right) {
      return this === right || Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes);
    }
  }, {
    key: "getBoundingSphere",
    value: function getBoundingSphere() {
      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _bounding_sphere__WEBPACK_IMPORTED_MODULE_3__["default"]();
      var halfAxes = this.halfAxes;
      var u = halfAxes.getColumn(0, fromOrientedBoundingBoxScratchU);
      var v = halfAxes.getColumn(1, fromOrientedBoundingBoxScratchV);
      var w = halfAxes.getColumn(2, fromOrientedBoundingBoxScratchW);
      var cornerVector = scratchVector.copy(u).add(v).add(w);
      result.center.copy(this.center);
      result.radius = cornerVector.magnitude();
      return result;
    }
  }, {
    key: "intersectPlane",
    value: function intersectPlane(plane) {
      var center = this.center;
      var normal = plane.normal;
      var halfAxes = this.halfAxes;
      var normalX = normal.x;
      var normalY = normal.y;
      var normalZ = normal.z;
      var radEffective = Math.abs(normalX * halfAxes[MATRIX3.COLUMN0ROW0] + normalY * halfAxes[MATRIX3.COLUMN0ROW1] + normalZ * halfAxes[MATRIX3.COLUMN0ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN1ROW0] + normalY * halfAxes[MATRIX3.COLUMN1ROW1] + normalZ * halfAxes[MATRIX3.COLUMN1ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN2ROW0] + normalY * halfAxes[MATRIX3.COLUMN2ROW1] + normalZ * halfAxes[MATRIX3.COLUMN2ROW2]);
      var distanceToPlane = normal.dot(center) + plane.distance;

      if (distanceToPlane <= -radEffective) {
        return _constants__WEBPACK_IMPORTED_MODULE_4__["Intersect"].OUTSIDE;
      } else if (distanceToPlane >= radEffective) {
        return _constants__WEBPACK_IMPORTED_MODULE_4__["Intersect"].INSIDE;
      }

      return _constants__WEBPACK_IMPORTED_MODULE_4__["Intersect"].INTERSECTING;
    }
  }, {
    key: "distanceTo",
    value: function distanceTo(point) {
      return Math.sqrt(this.distanceSquaredTo(point));
    }
  }, {
    key: "distanceSquaredTo",
    value: function distanceSquaredTo(point) {
      var offset = scratchOffset.copy(point).subtract(this.center);
      var halfAxes = this.halfAxes;
      var u = halfAxes.getColumn(0, scratchVectorU);
      var v = halfAxes.getColumn(1, scratchVectorV);
      var w = halfAxes.getColumn(2, scratchVectorW);
      var uHalf = u.magnitude();
      var vHalf = v.magnitude();
      var wHalf = w.magnitude();
      u.normalize();
      v.normalize();
      w.normalize();
      var pPrime = scratchPPrime;
      pPrime.x = offset.dot(u);
      pPrime.y = offset.dot(v);
      pPrime.z = offset.dot(w);
      var distanceSquared = 0.0;
      var d;

      if (pPrime.x < -uHalf) {
        d = pPrime.x + uHalf;
        distanceSquared += d * d;
      } else if (pPrime.x > uHalf) {
        d = pPrime.x - uHalf;
        distanceSquared += d * d;
      }

      if (pPrime.y < -vHalf) {
        d = pPrime.y + vHalf;
        distanceSquared += d * d;
      } else if (pPrime.y > vHalf) {
        d = pPrime.y - vHalf;
        distanceSquared += d * d;
      }

      if (pPrime.z < -wHalf) {
        d = pPrime.z + wHalf;
        distanceSquared += d * d;
      } else if (pPrime.z > wHalf) {
        d = pPrime.z - wHalf;
        distanceSquared += d * d;
      }

      return distanceSquared;
    }
  }, {
    key: "computePlaneDistances",
    value: function computePlaneDistances(position, direction) {
      var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [[], []];
      var minDist = Number.POSITIVE_INFINITY;
      var maxDist = Number.NEGATIVE_INFINITY;
      var center = this.center;
      var halfAxes = this.halfAxes;
      var u = halfAxes.getColumn(0, scratchVectorU);
      var v = halfAxes.getColumn(1, scratchVectorV);
      var w = halfAxes.getColumn(2, scratchVectorW);
      var corner = scratchCorner.copy(u).add(v).add(w).add(center);
      var toCenter = scratchToCenter.copy(corner).subtract(position);
      var mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      corner.copy(center).add(u).add(v).subtract(w);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      corner.copy(center).add(u).subtract(v).add(w);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      corner.copy(center).add(u).subtract(v).subtract(w);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      center.copy(corner).subtract(u).add(v).add(w);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      center.copy(corner).subtract(u).add(v).subtract(w);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      center.copy(corner).subtract(u).subtract(v).add(w);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      center.copy(corner).subtract(u).subtract(v).subtract(w);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      result.start = minDist;
      result.stop = maxDist;
      return result;
    }
  }, {
    key: "getTransform",
    value: function getTransform() {}
  }]);

  return OrientedBoundingBox;
}();


//# sourceMappingURL=oriented-bounding-box.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/culling/dist/esm/lib/perspective-frustum.js":
/*!**********************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@math.gl/culling/dist/esm/lib/perspective-frustum.js ***!
  \**********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PerspectiveFrustum; });
/* harmony import */ var _babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectSpread */ "../../node_modules/@babel/runtime/helpers/esm/objectSpread.js");
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");
/* harmony import */ var _perspective_off_center_frustum__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./perspective-off-center-frustum */ "../../node_modules/@math.gl/culling/dist/esm/lib/perspective-off-center-frustum.js");






var defined = function defined(val) {
  return val !== null && typeof val !== 'undefined';
};

var PerspectiveFrustum = function () {
  function PerspectiveFrustum() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__["default"])(this, PerspectiveFrustum);

    options = Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__["default"])({
      near: 1.0,
      far: 500000000.0,
      xOffset: 0.0,
      yOffset: 0.0
    }, options);
    this._offCenterFrustum = new _perspective_off_center_frustum__WEBPACK_IMPORTED_MODULE_4__["default"]();
    this.fov = options.fov;
    this._fov = undefined;
    this._fovy = undefined;
    this._sseDenominator = undefined;
    this.aspectRatio = options.aspectRatio;
    this._aspectRatio = undefined;
    this.near = options.near;
    this._near = this.near;
    this.far = options.far;
    this._far = this.far;
    this.xOffset = options.xOffset;
    this._xOffset = this.xOffset;
    this.yOffset = options.yOffset;
    this._yOffset = this.yOffset;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__["default"])(PerspectiveFrustum, [{
    key: "clone",
    value: function clone() {
      return new PerspectiveFrustum({
        aspectRatio: this.aspectRatio,
        fov: this.fov,
        near: this.near,
        far: this.far
      });
    }
  }, {
    key: "equals",
    value: function equals(other) {
      if (!defined(other) || !(other instanceof PerspectiveFrustum)) {
        return false;
      }

      update(this);
      update(other);
      return this.fov === other.fov && this.aspectRatio === other.aspectRatio && this.near === other.near && this.far === other.far && this._offCenterFrustum.equals(other._offCenterFrustum);
    }
  }, {
    key: "computeCullingVolume",
    value: function computeCullingVolume(position, direction, up) {
      update(this);
      return this._offCenterFrustum.computeCullingVolume(position, direction, up);
    }
  }, {
    key: "getPixelDimensions",
    value: function getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, result) {
      update(this);
      return this._offCenterFrustum.getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, result);
    }
  }, {
    key: "projectionMatrix",
    get: function get() {
      update(this);
      return this._offCenterFrustum.projectionMatrix;
    }
  }, {
    key: "infiniteProjectionMatrix",
    get: function get() {
      update(this);
      return this._offCenterFrustum.infiniteProjectionMatrix;
    }
  }, {
    key: "fovy",
    get: function get() {
      update(this);
      return this._fovy;
    }
  }, {
    key: "sseDenominator",
    get: function get() {
      update(this);
      return this._sseDenominator;
    }
  }]);

  return PerspectiveFrustum;
}();



function update(frustum) {
  Object(math_gl__WEBPACK_IMPORTED_MODULE_3__["assert"])(Number.isFinite(frustum.fov) && Number.isFinite(frustum.aspectRatio) && Number.isFinite(frustum.near) && Number.isFinite(frustum.far));
  var f = frustum._offCenterFrustum;

  if (frustum.fov !== frustum._fov || frustum.aspectRatio !== frustum._aspectRatio || frustum.near !== frustum._near || frustum.far !== frustum._far || frustum.xOffset !== frustum._xOffset || frustum.yOffset !== frustum._yOffset) {
    Object(math_gl__WEBPACK_IMPORTED_MODULE_3__["assert"])(frustum.fov >= 0 && frustum.fov < Math.PI);
    Object(math_gl__WEBPACK_IMPORTED_MODULE_3__["assert"])(frustum.aspectRatio > 0);
    Object(math_gl__WEBPACK_IMPORTED_MODULE_3__["assert"])(frustum.near >= 0 && frustum.near < frustum.far);
    frustum._aspectRatio = frustum.aspectRatio;
    frustum._fov = frustum.fov;
    frustum._fovy = frustum.aspectRatio <= 1 ? frustum.fov : Math.atan(Math.tan(frustum.fov * 0.5) / frustum.aspectRatio) * 2.0;
    frustum._near = frustum.near;
    frustum._far = frustum.far;
    frustum._sseDenominator = 2.0 * Math.tan(0.5 * frustum._fovy);
    frustum._xOffset = frustum.xOffset;
    frustum._yOffset = frustum.yOffset;
    f.top = frustum.near * Math.tan(0.5 * frustum._fovy);
    f.bottom = -f.top;
    f.right = frustum.aspectRatio * f.top;
    f.left = -f.right;
    f.near = frustum.near;
    f.far = frustum.far;
    f.right += frustum.xOffset;
    f.left += frustum.xOffset;
    f.top += frustum.yOffset;
    f.bottom += frustum.yOffset;
  }
}
//# sourceMappingURL=perspective-frustum.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/culling/dist/esm/lib/perspective-off-center-frustum.js":
/*!*********************************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@math.gl/culling/dist/esm/lib/perspective-off-center-frustum.js ***!
  \*********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PerspectiveOffCenterFrustum; });
/* harmony import */ var _babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectSpread */ "../../node_modules/@babel/runtime/helpers/esm/objectSpread.js");
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");
/* harmony import */ var _culling_volume__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./culling-volume */ "../../node_modules/@math.gl/culling/dist/esm/lib/culling-volume.js");





var scratchPlaneRightVector = new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector3"]();
var scratchPlaneNearCenter = new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector3"]();
var scratchPlaneFarCenter = new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector3"]();
var scratchPlaneNormal = new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector3"]();

var PerspectiveOffCenterFrustum = function () {
  function PerspectiveOffCenterFrustum() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__["default"])(this, PerspectiveOffCenterFrustum);

    options = Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__["default"])({
      near: 1.0,
      far: 500000000.0
    }, options);
    this.left = options.left;
    this._left = undefined;
    this.right = options.right;
    this._right = undefined;
    this.top = options.top;
    this._top = undefined;
    this.bottom = options.bottom;
    this._bottom = undefined;
    this.near = options.near;
    this._near = this.near;
    this.far = options.far;
    this._far = this.far;
    this._cullingVolume = new _culling_volume__WEBPACK_IMPORTED_MODULE_4__["default"]();
    this._perspectiveMatrix = new math_gl__WEBPACK_IMPORTED_MODULE_3__["Matrix4"]();
    this._infinitePerspective = new math_gl__WEBPACK_IMPORTED_MODULE_3__["Matrix4"]();
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__["default"])(PerspectiveOffCenterFrustum, [{
    key: "clone",
    value: function clone() {
      return new PerspectiveOffCenterFrustum({
        right: this.right,
        left: this.left,
        top: this.top,
        bottom: this.bottom,
        near: this.near,
        far: this.far
      });
    }
  }, {
    key: "equals",
    value: function equals(other) {
      return other && other instanceof PerspectiveOffCenterFrustum && this.right === other.right && this.left === other.left && this.top === other.top && this.bottom === other.bottom && this.near === other.near && this.far === other.far;
    }
  }, {
    key: "computeCullingVolume",
    value: function computeCullingVolume(position, direction, up) {
      Object(math_gl__WEBPACK_IMPORTED_MODULE_3__["assert"])(position, 'position is required.');
      Object(math_gl__WEBPACK_IMPORTED_MODULE_3__["assert"])(direction, 'direction is required.');
      Object(math_gl__WEBPACK_IMPORTED_MODULE_3__["assert"])(up, 'up is required.');
      var planes = this._cullingVolume.planes;
      var right = scratchPlaneRightVector.copy(direction).cross(up);
      var nearCenter = scratchPlaneNearCenter.copy(direction).multiplyByScalar(this.near).add(position);
      var farCenter = scratchPlaneFarCenter.copy(direction).multiplyByScalar(this.far).add(position);
      var normal = scratchPlaneNormal;
      normal.copy(right).multiplyByScalar(this.left).add(nearCenter).subtract(position).normalize().cross(up).normalize();
      planes[0] = planes[0] || new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector4"]();
      var plane = planes[0];
      plane.x = normal.x;
      plane.y = normal.y;
      plane.z = normal.z;
      plane.w = -normal.dot(position);
      normal.copy(right).multiplyByScalar(this.right).add(nearCenter).subtract(position).normalize().cross(up).normalize();
      planes[1] = planes[1] || new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector4"]();
      plane = planes[1];
      plane.x = normal.x;
      plane.y = normal.y;
      plane.z = normal.z;
      plane.w = -normal.dot(position);
      normal.copy(up).multiplyByScalar(this.bottom).add(nearCenter).subtract(position).normalize().cross(right).normalize();
      planes[2] = planes[2] || new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector4"]();
      plane = planes[2];
      plane.x = normal.x;
      plane.y = normal.y;
      plane.z = normal.z;
      plane.w = -normal.dot(position);
      normal.copy(up).multiplyByScalar(this.top).add(nearCenter).subtract(position).normalize().cross(right).normalize();
      planes[3] = planes[3] || new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector4"]();
      plane = planes[3];
      plane.x = normal.x;
      plane.y = normal.y;
      plane.z = normal.z;
      plane.w = -normal.dot(position);
      normal = new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector3"]().copy(direction).normalize();
      planes[4] = planes[4] || new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector4"]();
      plane = planes[4];
      plane.x = direction.x;
      plane.y = direction.y;
      plane.z = direction.z;
      plane.w = -direction.dot(nearCenter);
      normal.copy(direction).negate().normalize();
      planes[5] = planes[5] || new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector4"]();
      plane = planes[5];
      plane.x = normal.x;
      plane.y = normal.y;
      plane.z = normal.z;
      plane.w = -normal.dot(farCenter);
      return this._cullingVolume;
    }
  }, {
    key: "getPixelDimensions",
    value: function getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, result) {
      update(this);
      Object(math_gl__WEBPACK_IMPORTED_MODULE_3__["assert"])(Number.isFinite(drawingBufferWidth) && Number.isFinite(drawingBufferHeight));
      Object(math_gl__WEBPACK_IMPORTED_MODULE_3__["assert"])(drawingBufferWidth > 0);
      Object(math_gl__WEBPACK_IMPORTED_MODULE_3__["assert"])(drawingBufferHeight > 0);
      Object(math_gl__WEBPACK_IMPORTED_MODULE_3__["assert"])(distance > 0);
      Object(math_gl__WEBPACK_IMPORTED_MODULE_3__["assert"])(result);
      var inverseNear = 1.0 / this.near;
      var tanTheta = this.top * inverseNear;
      var pixelHeight = 2.0 * distance * tanTheta / drawingBufferHeight;
      tanTheta = this.right * inverseNear;
      var pixelWidth = 2.0 * distance * tanTheta / drawingBufferWidth;
      result.x = pixelWidth;
      result.y = pixelHeight;
      return result;
    }
  }, {
    key: "projectionMatrix",
    get: function get() {
      update(this);
      return this._perspectiveMatrix;
    }
  }, {
    key: "infiniteProjectionMatrix",
    get: function get() {
      update(this);
      return this._infinitePerspective;
    }
  }]);

  return PerspectiveOffCenterFrustum;
}();



function update(frustum) {
  Object(math_gl__WEBPACK_IMPORTED_MODULE_3__["assert"])(Number.isFinite(frustum.right) && Number.isFinite(frustum.left) && Number.isFinite(frustum.top) && Number.isFinite(frustum.bottom) && Number.isFinite(frustum.near) && Number.isFinite(frustum.far));
  var top = frustum.top,
      bottom = frustum.bottom,
      right = frustum.right,
      left = frustum.left,
      near = frustum.near,
      far = frustum.far;

  if (top !== frustum._top || bottom !== frustum._bottom || left !== frustum._left || right !== frustum._right || near !== frustum._near || far !== frustum._far) {
    Object(math_gl__WEBPACK_IMPORTED_MODULE_3__["assert"])(frustum.near > 0 && frustum.near < frustum.far, 'near must be greater than zero and less than far.');
    frustum._left = left;
    frustum._right = right;
    frustum._top = top;
    frustum._bottom = bottom;
    frustum._near = near;
    frustum._far = far;
    frustum._perspectiveMatrix = new math_gl__WEBPACK_IMPORTED_MODULE_3__["Matrix4"]().frustum({
      left: left,
      right: right,
      bottom: bottom,
      top: top,
      near: near,
      far: far
    });
    frustum._infinitePerspective = new math_gl__WEBPACK_IMPORTED_MODULE_3__["Matrix4"]().frustum({
      left: left,
      right: right,
      bottom: bottom,
      top: top,
      near: near,
      far: Infinity
    });
  }
}
//# sourceMappingURL=perspective-off-center-frustum.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/culling/dist/esm/lib/plane.js":
/*!********************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@math.gl/culling/dist/esm/lib/plane.js ***!
  \********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Plane; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");



var scratchPosition = new math_gl__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
var scratchNormal = new math_gl__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();

var Plane = function () {
  function Plane() {
    var normal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 1];
    var distance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Plane);

    this.normal = new math_gl__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
    this.distance = -0;
    this.fromNormalDistance(normal, distance);
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Plane, [{
    key: "fromNormalDistance",
    value: function fromNormalDistance(normal, distance) {
      Object(math_gl__WEBPACK_IMPORTED_MODULE_2__["assert"])(Number.isFinite(distance));
      this.normal.from(normal).normalize();
      this.distance = distance;
      return this;
    }
  }, {
    key: "fromPointNormal",
    value: function fromPointNormal(point, normal) {
      point = scratchPosition.from(point);
      this.normal.from(normal).normalize();
      var distance = -this.normal.dot(point);
      this.distance = distance;
      return this;
    }
  }, {
    key: "fromCoefficients",
    value: function fromCoefficients(a, b, c, d) {
      this.normal.set(a, b, c);
      Object(math_gl__WEBPACK_IMPORTED_MODULE_2__["assert"])(this.normal.len() === 1);
      this.distance = d;
      return this;
    }
  }, {
    key: "clone",
    value: function clone(plane) {
      return new Plane(this.normal, this.distance);
    }
  }, {
    key: "equals",
    value: function equals(right) {
      return Object(math_gl__WEBPACK_IMPORTED_MODULE_2__["equals"])(this.distance, right.distance) && Object(math_gl__WEBPACK_IMPORTED_MODULE_2__["equals"])(this.normal, right.normal);
    }
  }, {
    key: "getPointDistance",
    value: function getPointDistance(point) {
      return this.normal.dot(point) + this.distance;
    }
  }, {
    key: "transform",
    value: function transform(matrix4) {
      var normal = scratchNormal.copy(this.normal).transformAsVector(matrix4).normalize();
      var point = this.normal.scale(-this.distance).transform(matrix4);
      return this.fromPointNormal(point, normal);
    }
  }, {
    key: "projectPointOntoPlane",
    value: function projectPointOntoPlane(point) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
      point = scratchPosition.from(point);
      var pointDistance = this.getPointDistance(point);
      var scaledNormal = scratchNormal.copy(this.normal).scale(pointDistance);
      return point.subtract(scaledNormal).to(result);
    }
  }]);

  return Plane;
}();


//# sourceMappingURL=plane.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/geospatial/dist/esm/constants.js":
/*!***********************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@math.gl/geospatial/dist/esm/constants.js ***!
  \***********************************************************************************************/
/*! exports provided: WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z, WGS84_CONSTANTS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WGS84_RADIUS_X", function() { return WGS84_RADIUS_X; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WGS84_RADIUS_Y", function() { return WGS84_RADIUS_Y; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WGS84_RADIUS_Z", function() { return WGS84_RADIUS_Z; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WGS84_CONSTANTS", function() { return WGS84_CONSTANTS; });
var WGS84_RADIUS_X = 6378137.0;
var WGS84_RADIUS_Y = 6378137.0;
var WGS84_RADIUS_Z = 6356752.3142451793;
var WGS84_CONSTANTS = {
  radii: [WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z],
  radiiSquared: [WGS84_RADIUS_X * WGS84_RADIUS_X, WGS84_RADIUS_Y * WGS84_RADIUS_Y, WGS84_RADIUS_Z * WGS84_RADIUS_Z],
  oneOverRadii: [1.0 / WGS84_RADIUS_X, 1.0 / WGS84_RADIUS_Y, 1.0 / WGS84_RADIUS_Z],
  oneOverRadiiSquared: [1.0 / (WGS84_RADIUS_X * WGS84_RADIUS_X), 1.0 / (WGS84_RADIUS_Y * WGS84_RADIUS_Y), 1.0 / (WGS84_RADIUS_Z * WGS84_RADIUS_Z)],
  maximumRadius: Math.max(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z),
  centerToleranceSquared: 1e-1
};
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/geospatial/dist/esm/ellipsoid/ellipsoid.js":
/*!*********************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@math.gl/geospatial/dist/esm/ellipsoid/ellipsoid.js ***!
  \*********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Ellipsoid; });
/* harmony import */ var _babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/slicedToArray */ "../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");
/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! gl-matrix/vec3 */ "../../node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants */ "../../node_modules/@math.gl/geospatial/dist/esm/constants.js");
/* harmony import */ var _type_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../type-utils */ "../../node_modules/@math.gl/geospatial/dist/esm/type-utils.js");
/* harmony import */ var _helpers_scale_to_geodetic_surface__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./helpers/scale-to-geodetic-surface */ "../../node_modules/@math.gl/geospatial/dist/esm/ellipsoid/helpers/scale-to-geodetic-surface.js");
/* harmony import */ var _helpers_ellipsoid_transform__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./helpers/ellipsoid-transform */ "../../node_modules/@math.gl/geospatial/dist/esm/ellipsoid/helpers/ellipsoid-transform.js");









var scratchVector = new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector3"]();
var scratchNormal = new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector3"]();
var scratchK = new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector3"]();
var scratchPosition = new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector3"]();
var scratchHeight = new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector3"]();
var scratchCartesian = new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector3"]();
var wgs84;

var Ellipsoid = function () {
  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__["default"])(Ellipsoid, null, [{
    key: "WGS84",
    get: function get() {
      wgs84 = wgs84 || new Ellipsoid(_constants__WEBPACK_IMPORTED_MODULE_5__["WGS84_RADIUS_X"], _constants__WEBPACK_IMPORTED_MODULE_5__["WGS84_RADIUS_Y"], _constants__WEBPACK_IMPORTED_MODULE_5__["WGS84_RADIUS_Z"]);
      return wgs84;
    }
  }]);

  function Ellipsoid() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.0;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__["default"])(this, Ellipsoid);

    Object(math_gl__WEBPACK_IMPORTED_MODULE_3__["assert"])(x >= 0.0);
    Object(math_gl__WEBPACK_IMPORTED_MODULE_3__["assert"])(y >= 0.0);
    Object(math_gl__WEBPACK_IMPORTED_MODULE_3__["assert"])(z >= 0.0);
    this.radii = new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector3"](x, y, z);
    this.radiiSquared = new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector3"](x * x, y * y, z * z);
    this.radiiToTheFourth = new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector3"](x * x * x * x, y * y * y * y, z * z * z * z);
    this.oneOverRadii = new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector3"](x === 0.0 ? 0.0 : 1.0 / x, y === 0.0 ? 0.0 : 1.0 / y, z === 0.0 ? 0.0 : 1.0 / z);
    this.oneOverRadiiSquared = new math_gl__WEBPACK_IMPORTED_MODULE_3__["Vector3"](x === 0.0 ? 0.0 : 1.0 / (x * x), y === 0.0 ? 0.0 : 1.0 / (y * y), z === 0.0 ? 0.0 : 1.0 / (z * z));
    this.minimumRadius = Math.min(x, y, z);
    this.maximumRadius = Math.max(x, y, z);
    this.centerToleranceSquared = math_gl__WEBPACK_IMPORTED_MODULE_3__["_MathUtils"].EPSILON1;

    if (this.radiiSquared.z !== 0) {
      this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z;
    }

    Object.freeze(this);
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__["default"])(Ellipsoid, [{
    key: "equals",
    value: function equals(right) {
      return this === right || Boolean(right && this.radii.equals(right.radii));
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.radii.toString();
    }
  }, {
    key: "cartographicToCartesian",
    value: function cartographicToCartesian(cartographic) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
      var normal = scratchNormal;
      var k = scratchK;

      var _cartographic = Object(_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(cartographic, 3),
          height = _cartographic[2];

      this.geodeticSurfaceNormalCartographic(cartographic, normal);
      k.copy(this.radiiSquared).scale(normal);
      var gamma = Math.sqrt(normal.dot(k));
      k.scale(1 / gamma);
      normal.scale(height);
      k.add(normal);
      return k.to(result);
    }
  }, {
    key: "cartesianToCartographic",
    value: function cartesianToCartographic(cartesian) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
      scratchCartesian.from(cartesian);
      var point = this.scaleToGeodeticSurface(scratchCartesian, scratchPosition);

      if (!point) {
        return undefined;
      }

      var normal = this.geodeticSurfaceNormal(point, scratchNormal);
      var h = scratchHeight;
      h.copy(scratchCartesian).subtract(point);
      var longitude = Math.atan2(normal.y, normal.x);
      var latitude = Math.asin(normal.z);
      var height = Math.sign(gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_4__["dot"](h, scratchCartesian)) * gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_4__["length"](h);
      return Object(_type_utils__WEBPACK_IMPORTED_MODULE_6__["toCartographicFromRadians"])([longitude, latitude, height], result);
    }
  }, {
    key: "eastNorthUpToFixedFrame",
    value: function eastNorthUpToFixedFrame(origin) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new math_gl__WEBPACK_IMPORTED_MODULE_3__["Matrix4"]();
      return Object(_helpers_ellipsoid_transform__WEBPACK_IMPORTED_MODULE_8__["default"])(this, 'east', 'north', 'up', origin, result);
    }
  }, {
    key: "localFrameToFixedFrame",
    value: function localFrameToFixedFrame(firstAxis, secondAxis, thirdAxis, origin) {
      var result = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new math_gl__WEBPACK_IMPORTED_MODULE_3__["Matrix4"]();
      return Object(_helpers_ellipsoid_transform__WEBPACK_IMPORTED_MODULE_8__["default"])(this, firstAxis, secondAxis, thirdAxis, origin, result);
    }
  }, {
    key: "geocentricSurfaceNormal",
    value: function geocentricSurfaceNormal(cartesian) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
      return scratchVector.from(cartesian).normalize().to(result);
    }
  }, {
    key: "geodeticSurfaceNormalCartographic",
    value: function geodeticSurfaceNormalCartographic(cartographic) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
      var cartographicVectorRadians = Object(_type_utils__WEBPACK_IMPORTED_MODULE_6__["fromCartographicToRadians"])(cartographic);
      var longitude = cartographicVectorRadians[0];
      var latitude = cartographicVectorRadians[1];
      var cosLatitude = Math.cos(latitude);
      scratchVector.set(cosLatitude * Math.cos(longitude), cosLatitude * Math.sin(longitude), Math.sin(latitude)).normalize();
      return scratchVector.to(result);
    }
  }, {
    key: "geodeticSurfaceNormal",
    value: function geodeticSurfaceNormal(cartesian) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
      return scratchVector.from(cartesian).scale(this.oneOverRadiiSquared).normalize().to(result);
    }
  }, {
    key: "scaleToGeodeticSurface",
    value: function scaleToGeodeticSurface(cartesian, result) {
      return Object(_helpers_scale_to_geodetic_surface__WEBPACK_IMPORTED_MODULE_7__["default"])(cartesian, this, result);
    }
  }, {
    key: "scaleToGeocentricSurface",
    value: function scaleToGeocentricSurface(cartesian) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
      scratchPosition.from(cartesian);
      var positionX = scratchPosition.x;
      var positionY = scratchPosition.y;
      var positionZ = scratchPosition.z;
      var oneOverRadiiSquared = this.oneOverRadiiSquared;
      var beta = 1.0 / Math.sqrt(positionX * positionX * oneOverRadiiSquared.x + positionY * positionY * oneOverRadiiSquared.y + positionZ * positionZ * oneOverRadiiSquared.z);
      return scratchPosition.multiplyScalar(beta).to(result);
    }
  }, {
    key: "transformPositionToScaledSpace",
    value: function transformPositionToScaledSpace(position) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
      return scratchPosition.from(position).scale(this.oneOverRadii).to(result);
    }
  }, {
    key: "transformPositionFromScaledSpace",
    value: function transformPositionFromScaledSpace(position) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
      return scratchPosition.from(position).scale(this.radii).to(result);
    }
  }, {
    key: "getSurfaceNormalIntersectionWithZAxis",
    value: function getSurfaceNormalIntersectionWithZAxis(position) {
      var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;
      var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0, 0];
      Object(math_gl__WEBPACK_IMPORTED_MODULE_3__["assert"])(Object(math_gl__WEBPACK_IMPORTED_MODULE_3__["equals"])(this.radii.x, this.radii.y, math_gl__WEBPACK_IMPORTED_MODULE_3__["_MathUtils"].EPSILON15));
      Object(math_gl__WEBPACK_IMPORTED_MODULE_3__["assert"])(this.radii.z > 0);
      scratchPosition.from(position);
      var z = scratchPosition.z * (1 - this.squaredXOverSquaredZ);

      if (Math.abs(z) >= this.radii.z - buffer) {
        return undefined;
      }

      return scratchPosition.set(0.0, 0.0, z).to(result);
    }
  }]);

  return Ellipsoid;
}();


//# sourceMappingURL=ellipsoid.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/geospatial/dist/esm/ellipsoid/helpers/ellipsoid-transform.js":
/*!***************************************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@math.gl/geospatial/dist/esm/ellipsoid/helpers/ellipsoid-transform.js ***!
  \***************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return localFrameToFixedFrame; });
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");

var EPSILON14 = 1e-14;
var scratchOrigin = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var VECTOR_PRODUCT_LOCAL_FRAME = {
  up: {
    south: 'east',
    north: 'west',
    west: 'south',
    east: 'north'
  },
  down: {
    south: 'west',
    north: 'east',
    west: 'north',
    east: 'south'
  },
  south: {
    up: 'west',
    down: 'east',
    west: 'down',
    east: 'up'
  },
  north: {
    up: 'east',
    down: 'west',
    west: 'up',
    east: 'down'
  },
  west: {
    up: 'north',
    down: 'south',
    north: 'down',
    south: 'up'
  },
  east: {
    up: 'south',
    down: 'north',
    north: 'up',
    south: 'down'
  }
};
var degeneratePositionLocalFrame = {
  north: [-1, 0, 0],
  east: [0, 1, 0],
  up: [0, 0, 1],
  south: [1, 0, 0],
  west: [0, -1, 0],
  down: [0, 0, -1]
};
var scratchAxisVectors = {
  east: new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
  north: new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
  up: new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
  west: new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
  south: new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
  down: new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]()
};
var scratchVector1 = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var scratchVector2 = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var scratchVector3 = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
function localFrameToFixedFrame(ellipsoid, firstAxis, secondAxis, thirdAxis, cartesianOrigin, result) {
  var thirdAxisInferred = VECTOR_PRODUCT_LOCAL_FRAME[firstAxis] && VECTOR_PRODUCT_LOCAL_FRAME[firstAxis][secondAxis];
  Object(math_gl__WEBPACK_IMPORTED_MODULE_0__["assert"])(thirdAxisInferred && (!thirdAxis || thirdAxis === thirdAxisInferred));
  var firstAxisVector;
  var secondAxisVector;
  var thirdAxisVector;
  var origin = scratchOrigin.copy(cartesianOrigin);
  var atPole = Object(math_gl__WEBPACK_IMPORTED_MODULE_0__["equals"])(origin.x, 0.0, EPSILON14) && Object(math_gl__WEBPACK_IMPORTED_MODULE_0__["equals"])(origin.y, 0.0, EPSILON14);

  if (atPole) {
    var sign = Math.sign(origin.z);
    firstAxisVector = scratchVector1.fromArray(degeneratePositionLocalFrame[firstAxis]);

    if (firstAxis !== 'east' && firstAxis !== 'west') {
      firstAxisVector.scale(sign);
    }

    secondAxisVector = scratchVector2.fromArray(degeneratePositionLocalFrame[secondAxis]);

    if (secondAxis !== 'east' && secondAxis !== 'west') {
      secondAxisVector.scale(sign);
    }

    thirdAxisVector = scratchVector3.fromArray(degeneratePositionLocalFrame[thirdAxis]);

    if (thirdAxis !== 'east' && thirdAxis !== 'west') {
      thirdAxisVector.scale(sign);
    }
  } else {
    var up = scratchAxisVectors.up,
        east = scratchAxisVectors.east,
        north = scratchAxisVectors.north;
    east.set(-origin.y, origin.x, 0.0).normalize();
    ellipsoid.geodeticSurfaceNormal(origin, up);
    north.copy(up).cross(east);
    var down = scratchAxisVectors.down,
        west = scratchAxisVectors.west,
        south = scratchAxisVectors.south;
    down.copy(up).scale(-1);
    west.copy(east).scale(-1);
    south.copy(north).scale(-1);
    firstAxisVector = scratchAxisVectors[firstAxis];
    secondAxisVector = scratchAxisVectors[secondAxis];
    thirdAxisVector = scratchAxisVectors[thirdAxis];
  }

  result[0] = firstAxisVector.x;
  result[1] = firstAxisVector.y;
  result[2] = firstAxisVector.z;
  result[3] = 0.0;
  result[4] = secondAxisVector.x;
  result[5] = secondAxisVector.y;
  result[6] = secondAxisVector.z;
  result[7] = 0.0;
  result[8] = thirdAxisVector.x;
  result[9] = thirdAxisVector.y;
  result[10] = thirdAxisVector.z;
  result[11] = 0.0;
  result[12] = origin.x;
  result[13] = origin.y;
  result[14] = origin.z;
  result[15] = 1.0;
  return result;
}
//# sourceMappingURL=ellipsoid-transform.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/geospatial/dist/esm/ellipsoid/helpers/scale-to-geodetic-surface.js":
/*!*********************************************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@math.gl/geospatial/dist/esm/ellipsoid/helpers/scale-to-geodetic-surface.js ***!
  \*********************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return scaleToGeodeticSurface; });
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");
/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix/vec3 */ "../../node_modules/gl-matrix/esm/vec3.js");


var scratchVector = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var scaleToGeodeticSurfaceIntersection = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var scaleToGeodeticSurfaceGradient = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
function scaleToGeodeticSurface(cartesian, ellipsoid) {
  var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
  var oneOverRadii = ellipsoid.oneOverRadii,
      oneOverRadiiSquared = ellipsoid.oneOverRadiiSquared,
      centerToleranceSquared = ellipsoid.centerToleranceSquared;
  scratchVector.from(cartesian);
  var positionX = cartesian.x;
  var positionY = cartesian.y;
  var positionZ = cartesian.z;
  var oneOverRadiiX = oneOverRadii.x;
  var oneOverRadiiY = oneOverRadii.y;
  var oneOverRadiiZ = oneOverRadii.z;
  var x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;
  var y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;
  var z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;
  var squaredNorm = x2 + y2 + z2;
  var ratio = Math.sqrt(1.0 / squaredNorm);

  if (!Number.isFinite(ratio)) {
    return undefined;
  }

  var intersection = scaleToGeodeticSurfaceIntersection;
  intersection.copy(cartesian).scale(ratio);

  if (squaredNorm < centerToleranceSquared) {
    return intersection.to(result);
  }

  var oneOverRadiiSquaredX = oneOverRadiiSquared.x;
  var oneOverRadiiSquaredY = oneOverRadiiSquared.y;
  var oneOverRadiiSquaredZ = oneOverRadiiSquared.z;
  var gradient = scaleToGeodeticSurfaceGradient;
  gradient.set(intersection.x * oneOverRadiiSquaredX * 2.0, intersection.y * oneOverRadiiSquaredY * 2.0, intersection.z * oneOverRadiiSquaredZ * 2.0);
  var lambda = (1.0 - ratio) * cartesian.len() / (0.5 * gradient.len());
  var correction = 0.0;
  var xMultiplier;
  var yMultiplier;
  var zMultiplier;
  var func;

  do {
    lambda -= correction;
    xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);
    yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);
    zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);
    var xMultiplier2 = xMultiplier * xMultiplier;
    var yMultiplier2 = yMultiplier * yMultiplier;
    var zMultiplier2 = zMultiplier * zMultiplier;
    var xMultiplier3 = xMultiplier2 * xMultiplier;
    var yMultiplier3 = yMultiplier2 * yMultiplier;
    var zMultiplier3 = zMultiplier2 * zMultiplier;
    func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;
    var denominator = x2 * xMultiplier3 * oneOverRadiiSquaredX + y2 * yMultiplier3 * oneOverRadiiSquaredY + z2 * zMultiplier3 * oneOverRadiiSquaredZ;
    var derivative = -2.0 * denominator;
    correction = func / derivative;
  } while (Math.abs(func) > math_gl__WEBPACK_IMPORTED_MODULE_0__["_MathUtils"].EPSILON12);

  return scratchVector.scale([xMultiplier, yMultiplier, zMultiplier]).to(result);
}
//# sourceMappingURL=scale-to-geodetic-surface.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/geospatial/dist/esm/index.js":
/*!*******************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@math.gl/geospatial/dist/esm/index.js ***!
  \*******************************************************************************************/
/*! exports provided: Ellipsoid, isWGS84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ellipsoid_ellipsoid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ellipsoid/ellipsoid */ "../../node_modules/@math.gl/geospatial/dist/esm/ellipsoid/ellipsoid.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Ellipsoid", function() { return _ellipsoid_ellipsoid__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _type_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./type-utils */ "../../node_modules/@math.gl/geospatial/dist/esm/type-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWGS84", function() { return _type_utils__WEBPACK_IMPORTED_MODULE_1__["isWGS84"]; });



//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/geospatial/dist/esm/type-utils.js":
/*!************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/@math.gl/geospatial/dist/esm/type-utils.js ***!
  \************************************************************************************************/
/*! exports provided: fromCartographic, fromCartographicToRadians, fromCartographicToDegrees, toCartographic, toCartographicFromRadians, toCartographicFromDegrees, isWGS84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromCartographic", function() { return fromCartographic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromCartographicToRadians", function() { return fromCartographicToRadians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromCartographicToDegrees", function() { return fromCartographicToDegrees; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toCartographic", function() { return toCartographic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toCartographicFromRadians", function() { return toCartographicFromRadians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toCartographicFromDegrees", function() { return toCartographicFromDegrees; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWGS84", function() { return isWGS84; });
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "../../node_modules/@math.gl/geospatial/dist/esm/constants.js");



var noop = function noop(x) {
  return x;
};

var scratchVector = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
function fromCartographic(cartographic, vector) {
  var map = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;

  if (Object(math_gl__WEBPACK_IMPORTED_MODULE_0__["isArray"])(cartographic)) {
    vector[0] = map(cartographic[0]);
    vector[1] = map(cartographic[1]);
    vector[2] = cartographic[2];
  } else if ('longitude' in cartographic) {
    vector[0] = map(cartographic.longitude);
    vector[1] = map(cartographic.latitude);
    vector[2] = cartographic.height;
  } else {
    vector[0] = map(cartographic.x);
    vector[1] = map(cartographic.y);
    vector[2] = cartographic.z;
  }

  return vector;
}
function fromCartographicToRadians(cartographic) {
  var vector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scratchVector;
  return fromCartographic(cartographic, vector, math_gl__WEBPACK_IMPORTED_MODULE_0__["config"].cartographicRadians ? noop : math_gl__WEBPACK_IMPORTED_MODULE_0__["toRadians"]);
}
function fromCartographicToDegrees(cartographic) {
  var vector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scratchVector;
  return fromCartographic(cartographic, vector, math_gl__WEBPACK_IMPORTED_MODULE_0__["config"].cartographicRadians ? math_gl__WEBPACK_IMPORTED_MODULE_0__["toDegrees"] : noop);
}
function toCartographic(vector, cartographic) {
  var map = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;

  if (Object(math_gl__WEBPACK_IMPORTED_MODULE_0__["isArray"])(cartographic)) {
    cartographic[0] = map(vector[0]);
    cartographic[1] = map(vector[1]);
    cartographic[2] = vector[2];
  } else if ('longitude' in cartographic) {
    cartographic.longitude = map(vector[0]);
    cartographic.latitude = map(vector[1]);
    cartographic.height = vector[2];
  } else {
    cartographic.x = map(vector[0]);
    cartographic.y = map(vector[1]);
    cartographic.z = vector[2];
  }

  return cartographic;
}
function toCartographicFromRadians(vector, cartographic) {
  return toCartographic(vector, cartographic, math_gl__WEBPACK_IMPORTED_MODULE_0__["config"].cartographicRadians ? noop : math_gl__WEBPACK_IMPORTED_MODULE_0__["toDegrees"]);
}
function toCartographicFromDegrees(vector, cartographic) {
  return toCartographic(vector, cartographic, math_gl__WEBPACK_IMPORTED_MODULE_0__["config"].cartographicRadians ? math_gl__WEBPACK_IMPORTED_MODULE_0__["toRadians"] : noop);
}
function isWGS84(vector) {
  if (!vector) {
    return false;
  }

  scratchVector.from(vector);
  var oneOverRadiiSquared = _constants__WEBPACK_IMPORTED_MODULE_1__["WGS84_CONSTANTS"].oneOverRadiiSquared,
      centerToleranceSquared = _constants__WEBPACK_IMPORTED_MODULE_1__["WGS84_CONSTANTS"].centerToleranceSquared;
  var x2 = vector[0] * vector[0] * oneOverRadiiSquared[0];
  var y2 = vector[1] * vector[1] * oneOverRadiiSquared[1];
  var z2 = vector[2] * vector[2] * oneOverRadiiSquared[2];
  return Math.abs(x2 + y2 + z2 - 1) < centerToleranceSquared;
}
//# sourceMappingURL=type-utils.js.map

/***/ }),

/***/ "../../node_modules/gl-matrix/esm/common.js":
/*!*****************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/gl-matrix/esm/common.js ***!
  \*****************************************************************************/
/*! exports provided: EPSILON, ARRAY_TYPE, RANDOM, setMatrixArrayType, toRadian, equals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON", function() { return EPSILON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARRAY_TYPE", function() { return ARRAY_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RANDOM", function() { return RANDOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setMatrixArrayType", function() { return setMatrixArrayType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toRadian", function() { return toRadian; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */

function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */

function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

/***/ }),

/***/ "../../node_modules/gl-matrix/esm/mat3.js":
/*!***************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/gl-matrix/esm/mat3.js ***!
  \***************************************************************************/
/*! exports provided: create, fromMat4, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, rotate, scale, fromTranslation, fromRotation, fromScaling, fromMat2d, fromQuat, normalFromMat4, projection, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat4", function() { return fromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat2d", function() { return fromMat2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat", function() { return fromQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalFromMat4", function() { return normalFromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "projection", function() { return projection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "../../node_modules/gl-matrix/esm/common.js");

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */

function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */

function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */

function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */

function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
;
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/

function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/

function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */

function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "../../node_modules/gl-matrix/esm/mat4.js":
/*!***************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/gl-matrix/esm/mat4.js ***!
  \***************************************************************************/
/*! exports provided: create, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, scale, rotate, rotateX, rotateY, rotateZ, fromTranslation, fromScaling, fromRotation, fromXRotation, fromYRotation, fromZRotation, fromRotationTranslation, fromQuat2, getTranslation, getScaling, getRotation, fromRotationTranslationScale, fromRotationTranslationScaleOrigin, fromQuat, frustum, perspective, perspectiveFromFieldOfView, ortho, lookAt, targetTo, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromXRotation", function() { return fromXRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromYRotation", function() { return fromYRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromZRotation", function() { return fromZRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslation", function() { return fromRotationTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat2", function() { return fromQuat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTranslation", function() { return getTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScaling", function() { return getScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRotation", function() { return getRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationScale", function() { return fromRotationTranslationScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationScaleOrigin", function() { return fromRotationTranslationScaleOrigin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat", function() { return fromQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frustum", function() { return frustum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perspective", function() { return perspective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perspectiveFromFieldOfView", function() { return perspectiveFromFieldOfView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ortho", function() { return ortho; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lookAt", function() { return lookAt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "targetTo", function() { return targetTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "../../node_modules/gl-matrix/esm/common.js");

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */

function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */

function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */

function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */

function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {quat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */

function fromQuat2(out, a) {
  var translation = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */

function getRotation(out, mat) {
  var scaling = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */

function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */

function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */

function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */

function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] && Math.abs(eyey - centery) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] && Math.abs(eyez - centerz) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */

function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
;
/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "../../node_modules/gl-matrix/esm/quat.js":
/*!***************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/gl-matrix/esm/quat.js ***!
  \***************************************************************************/
/*! exports provided: create, identity, setAxisAngle, getAxisAngle, getAngle, multiply, rotateX, rotateY, rotateZ, calculateW, exp, ln, pow, slerp, random, invert, conjugate, fromMat3, fromEuler, str, clone, fromValues, copy, set, add, mul, scale, dot, lerp, length, len, squaredLength, sqrLen, normalize, exactEquals, equals, rotationTo, sqlerp, setAxes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAxisAngle", function() { return setAxisAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAxisAngle", function() { return getAxisAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAngle", function() { return getAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateW", function() { return calculateW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exp", function() { return exp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ln", function() { return ln; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pow", function() { return pow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slerp", function() { return slerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conjugate", function() { return conjugate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat3", function() { return fromMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromEuler", function() { return fromEuler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotationTo", function() { return rotationTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqlerp", function() { return sqlerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAxes", function() { return setAxes; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "../../node_modules/gl-matrix/esm/common.js");
/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mat3.js */ "../../node_modules/gl-matrix/esm/mat3.js");
/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vec3.js */ "../../node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vec4.js */ "../../node_modules/gl-matrix/esm/vec4.js");




/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/

function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */

function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);

  if (s > _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }

  return rad;
}
/**
 * Gets the angular distance between two unit quaternions
 *
 * @param  {quat} a     Origin unit quaternion 
 * @param  {quat} b     Destination unit quaternion
 * @return {Number}     Angle, in radians, between the two quaternions
 */

function getAngle(a, b) {
  var dotproduct = dot(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */

function multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */

function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}
/**
 * Calculate the exponential of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function exp(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
/**
 * Calculate the natural logarithm of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function ln(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
/**
 * Calculate the scalar power of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate the exponential of
 * @param {Number} b amount to scale the quaternion by
 * @returns {quat} out
 */

function pow(out, a, b) {
  ln(out, a);
  scale(out, out, b);
  exp(out, out);
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Generates a random unit quaternion
 * 
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var u2 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var u3 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */

function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */

function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */

function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */

var clone = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["clone"];
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */

var fromValues = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["fromValues"];
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */

var copy = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["copy"];
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */

var set = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["set"];
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */

var add = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["add"];
/**
 * Alias for {@link quat.multiply}
 * @function
 */

var mul = multiply;
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */

var scale = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["scale"];
/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["dot"];
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */

var lerp = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["lerp"];
/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 */

var length = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["length"];
/**
 * Alias for {@link quat.length}
 * @function
 */

var len = length;
/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["squaredLength"];
/**
 * Alias for {@link quat.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

var normalize = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["normalize"];
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var exactEquals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["exactEquals"];
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var equals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["equals"];
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */

var rotationTo = function () {
  var tmpvec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["create"]();
  var xUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["fromValues"](1, 0, 0);
  var yUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["fromValues"](0, 1, 0);
  return function (out, a, b) {
    var dot = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["dot"](a, b);

    if (dot < -0.999999) {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, xUnitVec3, a);
      if (_vec3_js__WEBPACK_IMPORTED_MODULE_2__["len"](tmpvec3) < 0.000001) _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, yUnitVec3, a);
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["normalize"](tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */

var setAxes = function () {
  var matr = _mat3_js__WEBPACK_IMPORTED_MODULE_1__["create"]();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();

/***/ }),

/***/ "../../node_modules/gl-matrix/esm/vec2.js":
/*!***************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/gl-matrix/esm/vec2.js ***!
  \***************************************************************************/
/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat2, transformMat2d, transformMat3, transformMat4, rotate, angle, zero, str, exactEquals, equals, len, sub, mul, div, dist, sqrDist, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat2", function() { return transformMat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat2d", function() { return transformMat2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat3", function() { return transformMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angle", function() { return angle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "../../node_modules/gl-matrix/esm/common.js");

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {vec2} a The vec2 point to rotate
 * @param {vec2} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec2} out
 */

function rotate(out, a, b, c) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(c),
      cosC = Math.cos(c); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {vec2} a The first operand
 * @param {vec2} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1];
  var len1 = x1 * x1 + y1 * y1;

  if (len1 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len1 = 1 / Math.sqrt(len1);
  }

  var len2 = x2 * x2 + y2 * y2;

  if (len2 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len2 = 1 / Math.sqrt(len2);
  }

  var cosine = (x1 * x2 + y1 * y2) * len1 * len2;

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return 'vec2(' + a[0] + ', ' + a[1] + ')';
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
}();

/***/ }),

/***/ "../../node_modules/gl-matrix/esm/vec3.js":
/*!***************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/gl-matrix/esm/vec3.js ***!
  \***************************************************************************/
/*! exports provided: create, clone, length, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, squaredLength, negate, inverse, normalize, dot, cross, lerp, hermite, bezier, random, transformMat4, transformMat3, transformQuat, rotateX, rotateY, rotateZ, angle, zero, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hermite", function() { return hermite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bezier", function() { return bezier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat3", function() { return transformMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformQuat", function() { return transformQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angle", function() { return angle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "../../node_modules/gl-matrix/esm/common.js");

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 * Math.PI;
  var z = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateX(out, a, b, c) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
  r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateY(out, a, b, c) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateZ(out, a, b, c) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
  r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var tempA = fromValues(a[0], a[1], a[2]);
  var tempB = fromValues(b[0], b[1], b[2]);
  normalize(tempA, tempA);
  normalize(tempB, tempB);
  var cosine = dot(tempA, tempB);

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

/***/ }),

/***/ "../../node_modules/gl-matrix/esm/vec4.js":
/*!***************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/gl-matrix/esm/vec4.js ***!
  \***************************************************************************/
/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat4, transformQuat, zero, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformQuat", function() { return transformQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "../../node_modules/gl-matrix/esm/common.js");

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */

function fromValues(x, y, z, w) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */

function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {vec4} result the receiving vector
 * @param {vec4} U the first vector
 * @param {vec4} V the second vector
 * @param {vec4} W the third vector
 * @returns {vec4} result
 */

function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
      B = v[0] * w[2] - v[2] * w[0],
      C = v[0] * w[3] - v[3] * w[0],
      D = v[1] * w[2] - v[2] * w[1],
      E = v[1] * w[3] - v[3] * w[1],
      F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
;
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */

function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;

  do {
    v1 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    v2 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);

  do {
    v3 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    v4 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */

function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
}();

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/addons/polygon.js":
/*!****************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/math.gl/dist/esm/addons/polygon.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Polygon; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/common */ "../../node_modules/math.gl/dist/esm/lib/common.js");




var Polygon = function () {
  function Polygon(points) {
    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Polygon);

    this.points = points;
    this.isClosed = Object(_lib_common__WEBPACK_IMPORTED_MODULE_2__["equals"])(this.points[this.points.length - 1], this.points[0]);
    Object.freeze(this);
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Polygon, [{
    key: "getSignedArea",
    value: function getSignedArea() {
      var area = 0;
      this.forEachSegment(function (p1, p2) {
        area += (p1[0] + p2[0]) * (p1[1] - p2[1]);
      });
      return area / 2;
    }
  }, {
    key: "getArea",
    value: function getArea() {
      return Math.abs(this.getSignedArea());
    }
  }, {
    key: "getWindingDirection",
    value: function getWindingDirection() {
      return Math.sign(this.getSignedArea());
    }
  }, {
    key: "forEachSegment",
    value: function forEachSegment(visitor) {
      var length = this.points.length;

      for (var i = 0; i < length - 1; i++) {
        visitor(this.points[i], this.points[i + 1], i, i + 1);
      }

      if (!this.isClosed) {
        visitor(this.points[length - 1], this.points[0], length - 1, 0);
      }
    }
  }]);

  return Polygon;
}();


//# sourceMappingURL=polygon.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/classes/base/math-array.js":
/*!*************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/math.gl/dist/esm/classes/base/math-array.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MathArray; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "../../node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_esm_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/wrapNativeSuper */ "../../node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../lib/common */ "../../node_modules/math.gl/dist/esm/lib/common.js");








var MathArray = function (_Array) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__["default"])(MathArray, _Array);

  function MathArray() {
    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, MathArray);

    return Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__["default"])(this, Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__["default"])(MathArray).apply(this, arguments));
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(MathArray, [{
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "from",
    value: function from(arrayOrObject) {
      return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : this.fromObject(arrayOrObject);
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = array[i + offset];
      }

      return this.check();
    }
  }, {
    key: "to",
    value: function to(arrayOrObject) {
      if (arrayOrObject === this) {
        return this;
      }

      return Object(_lib_common__WEBPACK_IMPORTED_MODULE_6__["isArray"])(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
    }
  }, {
    key: "toTarget",
    value: function toTarget(target) {
      return target ? this.to(target) : this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      for (var i = 0; i < this.ELEMENTS; ++i) {
        array[offset + i] = this[i];
      }

      return array;
    }
  }, {
    key: "toFloat32Array",
    value: function toFloat32Array() {
      return new Float32Array(this);
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.formatString(_lib_common__WEBPACK_IMPORTED_MODULE_6__["config"]);
    }
  }, {
    key: "formatString",
    value: function formatString(opts) {
      var string = '';

      for (var i = 0; i < this.ELEMENTS; ++i) {
        string += (i > 0 ? ', ' : '') + Object(_lib_common__WEBPACK_IMPORTED_MODULE_6__["formatValue"])(this[i], opts);
      }

      return "".concat(opts.printTypes ? this.constructor.name : '', "[").concat(string, "]");
    }
  }, {
    key: "equals",
    value: function equals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }

      for (var i = 0; i < this.ELEMENTS; ++i) {
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_6__["equals"])(this[i], array[i])) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "exactEquals",
    value: function exactEquals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }

      for (var i = 0; i < this.ELEMENTS; ++i) {
        if (this[i] !== array[i]) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "negate",
    value: function negate() {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = -this[i];
      }

      return this.check();
    }
  }, {
    key: "lerp",
    value: function lerp(a, b, t) {
      if (t === undefined) {
        t = b;
        b = a;
        a = this;
      }

      for (var i = 0; i < this.ELEMENTS; ++i) {
        var ai = a[i];
        this[i] = ai + t * (b[i] - ai);
      }

      return this.check();
    }
  }, {
    key: "min",
    value: function min(vector) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.min(vector[i], this[i]);
      }

      return this.check();
    }
  }, {
    key: "max",
    value: function max(vector) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.max(vector[i], this[i]);
      }

      return this.check();
    }
  }, {
    key: "clamp",
    value: function clamp(minVector, maxVector) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.min(Math.max(this[i], minVector[i]), maxVector[i]);
      }

      return this.check();
    }
  }, {
    key: "add",
    value: function add() {
      for (var _len = arguments.length, vectors = new Array(_len), _key = 0; _key < _len; _key++) {
        vectors[_key] = arguments[_key];
      }

      for (var _i = 0, _vectors = vectors; _i < _vectors.length; _i++) {
        var vector = _vectors[_i];

        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] += vector[i];
        }
      }

      return this.check();
    }
  }, {
    key: "subtract",
    value: function subtract() {
      for (var _len2 = arguments.length, vectors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        vectors[_key2] = arguments[_key2];
      }

      for (var _i2 = 0, _vectors2 = vectors; _i2 < _vectors2.length; _i2++) {
        var vector = _vectors2[_i2];

        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] -= vector[i];
        }
      }

      return this.check();
    }
  }, {
    key: "scale",
    value: function scale(_scale) {
      if (Array.isArray(_scale)) {
        return this.multiply(_scale);
      }

      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] *= _scale;
      }

      return this.check();
    }
  }, {
    key: "sub",
    value: function sub(a) {
      return this.subtract(a);
    }
  }, {
    key: "setScalar",
    value: function setScalar(a) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = a;
      }

      return this.check();
    }
  }, {
    key: "addScalar",
    value: function addScalar(a) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] += a;
      }

      return this.check();
    }
  }, {
    key: "subScalar",
    value: function subScalar(a) {
      return this.addScalar(-a);
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(scalar) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] *= scalar;
      }

      return this.check();
    }
  }, {
    key: "divideScalar",
    value: function divideScalar(a) {
      return this.scale(1 / a);
    }
  }, {
    key: "clampScalar",
    value: function clampScalar(min, max) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.min(Math.max(this[i], min), max);
      }

      return this.check();
    }
  }, {
    key: "multiplyByScalar",
    value: function multiplyByScalar(scalar) {
      return this.scale(scalar);
    }
  }, {
    key: "check",
    value: function check() {
      if (_lib_common__WEBPACK_IMPORTED_MODULE_6__["config"].debug && !this.validate(this)) {
        throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
      }

      return this;
    }
  }, {
    key: "validate",
    value: function validate() {
      var valid = this.length === this.ELEMENTS;

      for (var i = 0; i < this.ELEMENTS; ++i) {
        valid = valid && Number.isFinite(this[i]);
      }

      return valid;
    }
  }, {
    key: "elements",
    get: function get() {
      return this;
    }
  }]);

  return MathArray;
}(Object(_babel_runtime_helpers_esm_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_5__["default"])(Array));


//# sourceMappingURL=math-array.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/classes/base/matrix.js":
/*!*********************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/math.gl/dist/esm/classes/base/matrix.js ***!
  \*********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Matrix; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "../../node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _math_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./math-array */ "../../node_modules/math.gl/dist/esm/classes/base/math-array.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../lib/validators */ "../../node_modules/math.gl/dist/esm/lib/validators.js");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../lib/common */ "../../node_modules/math.gl/dist/esm/lib/common.js");









var Matrix = function (_MathArray) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__["default"])(Matrix, _MathArray);

  function Matrix() {
    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Matrix);

    return Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__["default"])(this, Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__["default"])(Matrix).apply(this, arguments));
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Matrix, [{
    key: "toString",
    value: function toString() {
      var string = '[';

      if (_lib_common__WEBPACK_IMPORTED_MODULE_7__["config"].printRowMajor) {
        string += 'row-major:';

        for (var row = 0; row < this.RANK; ++row) {
          for (var col = 0; col < this.RANK; ++col) {
            string += " ".concat(this[col * this.RANK + row]);
          }
        }
      } else {
        string += 'column-major:';

        for (var i = 0; i < this.ELEMENTS; ++i) {
          string += " ".concat(this[i]);
        }
      }

      string += ']';
      return string;
    }
  }, {
    key: "getElementIndex",
    value: function getElementIndex(row, col) {
      return col * this.RANK + row;
    }
  }, {
    key: "getElement",
    value: function getElement(row, col) {
      return this[col * this.RANK + row];
    }
  }, {
    key: "setElement",
    value: function setElement(row, col, value) {
      this[col * this.RANK + row] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkNumber"])(value);
      return this;
    }
  }, {
    key: "getColumn",
    value: function getColumn(columnIndex) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Array(this.RANK).fill(-0);
      var firstIndex = columnIndex * this.RANK;

      for (var i = 0; i < this.RANK; ++i) {
        result[i] = this[firstIndex + i];
      }

      return result;
    }
  }, {
    key: "setColumn",
    value: function setColumn(columnIndex, columnVector) {
      var firstIndex = columnIndex * this.RANK;

      for (var i = 0; i < this.RANK; ++i) {
        this[firstIndex + i] = columnVector[i];
      }

      return this;
    }
  }]);

  return Matrix;
}(_math_array__WEBPACK_IMPORTED_MODULE_5__["default"]);


//# sourceMappingURL=matrix.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/classes/base/vector.js":
/*!*********************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/math.gl/dist/esm/classes/base/vector.js ***!
  \*********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Vector; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "../../node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _math_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./math-array */ "../../node_modules/math.gl/dist/esm/classes/base/math-array.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../lib/validators */ "../../node_modules/math.gl/dist/esm/lib/validators.js");
/* harmony import */ var _lib_assert__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../lib/assert */ "../../node_modules/math.gl/dist/esm/lib/assert.js");









var Vector = function (_MathArray) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__["default"])(Vector, _MathArray);

  function Vector() {
    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Vector);

    return Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__["default"])(this, Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__["default"])(Vector).apply(this, arguments));
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Vector, [{
    key: "len",
    value: function len() {
      return Math.sqrt(this.lengthSquared());
    }
  }, {
    key: "magnitude",
    value: function magnitude() {
      return this.len();
    }
  }, {
    key: "lengthSquared",
    value: function lengthSquared() {
      var length = 0;

      for (var i = 0; i < this.ELEMENTS; ++i) {
        length += this[i] * this[i];
      }

      return length;
    }
  }, {
    key: "magnitudeSquared",
    value: function magnitudeSquared() {
      return this.lengthSquared();
    }
  }, {
    key: "distance",
    value: function distance(mathArray) {
      return Math.sqrt(this.distanceSquared(mathArray));
    }
  }, {
    key: "distanceSquared",
    value: function distanceSquared(mathArray) {
      var length = 0;

      for (var i = 0; i < this.ELEMENTS; ++i) {
        var dist = this[i] - mathArray[i];
        length += dist * dist;
      }

      return Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkNumber"])(length);
    }
  }, {
    key: "dot",
    value: function dot(mathArray) {
      var product = 0;

      for (var i = 0; i < this.ELEMENTS; ++i) {
        product += this[i] * mathArray[i];
      }

      return Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkNumber"])(product);
    }
  }, {
    key: "normalize",
    value: function normalize() {
      var length = this.magnitude();

      if (length !== 0) {
        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] /= length;
        }
      }

      return this.check();
    }
  }, {
    key: "multiply",
    value: function multiply() {
      for (var _len = arguments.length, vectors = new Array(_len), _key = 0; _key < _len; _key++) {
        vectors[_key] = arguments[_key];
      }

      for (var _i = 0, _vectors = vectors; _i < _vectors.length; _i++) {
        var vector = _vectors[_i];

        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] *= vector[i];
        }
      }

      return this.check();
    }
  }, {
    key: "divide",
    value: function divide() {
      for (var _len2 = arguments.length, vectors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        vectors[_key2] = arguments[_key2];
      }

      for (var _i2 = 0, _vectors2 = vectors; _i2 < _vectors2.length; _i2++) {
        var vector = _vectors2[_i2];

        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] /= vector[i];
        }
      }

      return this.check();
    }
  }, {
    key: "lengthSq",
    value: function lengthSq() {
      return this.lengthSquared();
    }
  }, {
    key: "distanceTo",
    value: function distanceTo(vector) {
      return this.distance(vector);
    }
  }, {
    key: "distanceToSquared",
    value: function distanceToSquared(vector) {
      return this.distanceSquared(vector);
    }
  }, {
    key: "getComponent",
    value: function getComponent(i) {
      Object(_lib_assert__WEBPACK_IMPORTED_MODULE_7__["default"])(i >= 0 && i < this.ELEMENTS, 'index is out of range');
      return Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkNumber"])(this[i]);
    }
  }, {
    key: "setComponent",
    value: function setComponent(i, value) {
      Object(_lib_assert__WEBPACK_IMPORTED_MODULE_7__["default"])(i >= 0 && i < this.ELEMENTS, 'index is out of range');
      this[i] = value;
      return this.check();
    }
  }, {
    key: "addVectors",
    value: function addVectors(a, b) {
      return this.copy(a).add(b);
    }
  }, {
    key: "subVectors",
    value: function subVectors(a, b) {
      return this.copy(a).subtract(b);
    }
  }, {
    key: "multiplyVectors",
    value: function multiplyVectors(a, b) {
      return this.copy(a).multiply(b);
    }
  }, {
    key: "addScaledVector",
    value: function addScaledVector(a, b) {
      return this.add(new this.constructor(a).multiplyScalar(b));
    }
  }, {
    key: "x",
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkNumber"])(value);
    }
  }, {
    key: "y",
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkNumber"])(value);
    }
  }]);

  return Vector;
}(_math_array__WEBPACK_IMPORTED_MODULE_5__["default"]);


//# sourceMappingURL=vector.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/classes/euler.js":
/*!***************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/math.gl/dist/esm/classes/euler.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Euler; });
/* harmony import */ var _babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/slicedToArray */ "../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "../../node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _base_math_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./base/math-array */ "../../node_modules/math.gl/dist/esm/classes/base/math-array.js");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../lib/common */ "../../node_modules/math.gl/dist/esm/lib/common.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../lib/validators */ "../../node_modules/math.gl/dist/esm/lib/validators.js");
/* harmony import */ var _quaternion__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./quaternion */ "../../node_modules/math.gl/dist/esm/classes/quaternion.js");










var ERR_UNKNOWN_ORDER = 'Unknown Euler angle order';
var ALMOST_ONE = 0.99999;

function validateOrder(value) {
  return value >= 0 && value < 6;
}

function checkOrder(value) {
  if (value < 0 && value >= 6) {
    throw new Error(ERR_UNKNOWN_ORDER);
  }

  return value;
}

var Euler = function (_MathArray) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_5__["default"])(Euler, _MathArray);

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__["default"])(Euler, [{
    key: "ELEMENTS",
    get: function get() {
      return 4;
    }
  }], [{
    key: "rotationOrder",
    value: function rotationOrder(order) {
      return Euler.RotationOrders[order];
    }
  }, {
    key: "ZYX",
    get: function get() {
      return 0;
    }
  }, {
    key: "YXZ",
    get: function get() {
      return 1;
    }
  }, {
    key: "XZY",
    get: function get() {
      return 2;
    }
  }, {
    key: "ZXY",
    get: function get() {
      return 3;
    }
  }, {
    key: "YZX",
    get: function get() {
      return 4;
    }
  }, {
    key: "XYZ",
    get: function get() {
      return 5;
    }
  }, {
    key: "RollPitchYaw",
    get: function get() {
      return 0;
    }
  }, {
    key: "DefaultOrder",
    get: function get() {
      return Euler.ZYX;
    }
  }, {
    key: "RotationOrders",
    get: function get() {
      return ['ZYX', 'YXZ', 'XZY', 'ZXY', 'YZX', 'XYZ'];
    }
  }]);

  function Euler() {
    var _this;

    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var order = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Euler.DefaultOrder;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__["default"])(this, Euler);

    _this = Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__["default"])(this, Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__["default"])(Euler).call(this, -0, -0, -0, -0));

    if (arguments.length > 0 && Array.isArray(arguments[0])) {
      var _this2;

      (_this2 = _this).fromVector3.apply(_this2, arguments);
    } else {
      _this.set(x, y, z, order);
    }

    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__["default"])(Euler, [{
    key: "fromQuaternion",
    value: function fromQuaternion(quaternion) {
      var _quaternion = Object(_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(quaternion, 4),
          x = _quaternion[0],
          y = _quaternion[1],
          z = _quaternion[2],
          w = _quaternion[3];

      var ysqr = y * y;
      var t0 = -2.0 * (ysqr + z * z) + 1.0;
      var t1 = +2.0 * (x * y + w * z);
      var t2 = -2.0 * (x * z - w * y);
      var t3 = +2.0 * (y * z + w * x);
      var t4 = -2.0 * (x * x + ysqr) + 1.0;
      t2 = t2 > 1.0 ? 1.0 : t2;
      t2 = t2 < -1.0 ? -1.0 : t2;
      var roll = Math.atan2(t3, t4);
      var pitch = Math.asin(t2);
      var yaw = Math.atan2(t1, t0);
      return new Euler(roll, pitch, yaw, Euler.RollPitchYaw);
    }
  }, {
    key: "copy",
    value: function copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = Number.isFinite(array[3]) || this.order;
      return this.check();
    }
  }, {
    key: "set",
    value: function set() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var order = arguments.length > 3 ? arguments[3] : undefined;
      this[0] = x;
      this[1] = y;
      this[2] = z;
      this[3] = Number.isFinite(order) ? order : this[3];
      return this.check();
    }
  }, {
    key: "validate",
    value: function validate() {
      return validateOrder(this[3]) && Number.isFinite(this[0]) && Number.isFinite(this[1]) && Number.isFinite(this[2]);
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      array[offset] = this[0];
      array[offset + 1] = this[1];
      array[offset + 2] = this[2];
      return array;
    }
  }, {
    key: "toArray4",
    value: function toArray4() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      array[offset] = this[0];
      array[offset + 1] = this[1];
      array[offset + 2] = this[2];
      array[offset + 3] = this[3];
      return array;
    }
  }, {
    key: "toVector3",
    value: function toVector3() {
      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [-0, -0, -0];
      result[0] = this[0];
      result[1] = this[1];
      result[2] = this[2];
      return result;
    }
  }, {
    key: "fromVector3",
    value: function fromVector3(v, order) {
      return this.set(v[0], v[1], v[2], Number.isFinite(order) ? order : this[3]);
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this[0] = array[0 + offset];
      this[1] = array[1 + offset];
      this[2] = array[2 + offset];

      if (array[3] !== undefined) {
        this[3] = array[3];
      }

      return this.check();
    }
  }, {
    key: "fromRollPitchYaw",
    value: function fromRollPitchYaw(roll, pitch, yaw) {
      return this.set(roll, pitch, yaw, Euler.ZYX);
    }
  }, {
    key: "fromRotationMatrix",
    value: function fromRotationMatrix(m) {
      var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Euler.DefaultOrder;

      this._fromRotationMatrix(m, order);

      return this.check();
    }
  }, {
    key: "getRotationMatrix",
    value: function getRotationMatrix(m) {
      return this._getRotationMatrix(m);
    }
  }, {
    key: "getQuaternion",
    value: function getQuaternion() {
      var q = new _quaternion__WEBPACK_IMPORTED_MODULE_9__["default"]();

      switch (this[4]) {
        case Euler.XYZ:
          return q.rotateX(this[0]).rotateY(this[1]).rotateZ(this[2]);

        case Euler.YXZ:
          return q.rotateY(this[0]).rotateX(this[1]).rotateZ(this[2]);

        case Euler.ZXY:
          return q.rotateZ(this[0]).rotateX(this[1]).rotateY(this[2]);

        case Euler.ZYX:
          return q.rotateZ(this[0]).rotateY(this[1]).rotateX(this[2]);

        case Euler.YZX:
          return q.rotateY(this[0]).rotateZ(this[1]).rotateX(this[2]);

        case Euler.XZY:
          return q.rotateX(this[0]).rotateZ(this[1]).rotateY(this[2]);

        default:
          throw new Error(ERR_UNKNOWN_ORDER);
      }
    }
  }, {
    key: "_fromRotationMatrix",
    value: function _fromRotationMatrix(m) {
      var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Euler.DefaultOrder;
      var te = m.elements;
      var m11 = te[0],
          m12 = te[4],
          m13 = te[8];
      var m21 = te[1],
          m22 = te[5],
          m23 = te[9];
      var m31 = te[2],
          m32 = te[6],
          m33 = te[10];
      order = order || this[3];

      switch (order) {
        case Euler.XYZ:
          this[1] = Math.asin(Object(_lib_common__WEBPACK_IMPORTED_MODULE_7__["clamp"])(m13, -1, 1));

          if (Math.abs(m13) < ALMOST_ONE) {
            this[0] = Math.atan2(-m23, m33);
            this[2] = Math.atan2(-m12, m11);
          } else {
            this[0] = Math.atan2(m32, m22);
            this[2] = 0;
          }

          break;

        case Euler.YXZ:
          this[0] = Math.asin(-Object(_lib_common__WEBPACK_IMPORTED_MODULE_7__["clamp"])(m23, -1, 1));

          if (Math.abs(m23) < ALMOST_ONE) {
            this[1] = Math.atan2(m13, m33);
            this[2] = Math.atan2(m21, m22);
          } else {
            this[1] = Math.atan2(-m31, m11);
            this[2] = 0;
          }

          break;

        case Euler.ZXY:
          this[0] = Math.asin(Object(_lib_common__WEBPACK_IMPORTED_MODULE_7__["clamp"])(m32, -1, 1));

          if (Math.abs(m32) < ALMOST_ONE) {
            this[1] = Math.atan2(-m31, m33);
            this[2] = Math.atan2(-m12, m22);
          } else {
            this[1] = 0;
            this[2] = Math.atan2(m21, m11);
          }

          break;

        case Euler.ZYX:
          this[1] = Math.asin(-Object(_lib_common__WEBPACK_IMPORTED_MODULE_7__["clamp"])(m31, -1, 1));

          if (Math.abs(m31) < ALMOST_ONE) {
            this[0] = Math.atan2(m32, m33);
            this[2] = Math.atan2(m21, m11);
          } else {
            this[0] = 0;
            this[2] = Math.atan2(-m12, m22);
          }

          break;

        case Euler.YZX:
          this[2] = Math.asin(Object(_lib_common__WEBPACK_IMPORTED_MODULE_7__["clamp"])(m21, -1, 1));

          if (Math.abs(m21) < ALMOST_ONE) {
            this[0] = Math.atan2(-m23, m22);
            this[1] = Math.atan2(-m31, m11);
          } else {
            this[0] = 0;
            this[1] = Math.atan2(m13, m33);
          }

          break;

        case Euler.XZY:
          this[2] = Math.asin(-Object(_lib_common__WEBPACK_IMPORTED_MODULE_7__["clamp"])(m12, -1, 1));

          if (Math.abs(m12) < ALMOST_ONE) {
            this[0] = Math.atan2(m32, m22);
            this[1] = Math.atan2(m13, m11);
          } else {
            this[0] = Math.atan2(-m23, m33);
            this[1] = 0;
          }

          break;

        default:
          throw new Error(ERR_UNKNOWN_ORDER);
      }

      this[3] = order;
      return this;
    }
  }, {
    key: "_getRotationMatrix",
    value: function _getRotationMatrix(result) {
      var te = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
      var x = this.x,
          y = this.y,
          z = this.z;
      var a = Math.cos(x);
      var c = Math.cos(y);
      var e = Math.cos(z);
      var b = Math.sin(x);
      var d = Math.sin(y);
      var f = Math.sin(z);

      switch (this[3]) {
        case Euler.XYZ:
          {
            var ae = a * e,
                af = a * f,
                be = b * e,
                bf = b * f;
            te[0] = c * e;
            te[4] = -c * f;
            te[8] = d;
            te[1] = af + be * d;
            te[5] = ae - bf * d;
            te[9] = -b * c;
            te[2] = bf - ae * d;
            te[6] = be + af * d;
            te[10] = a * c;
            break;
          }

        case Euler.YXZ:
          {
            var ce = c * e,
                cf = c * f,
                de = d * e,
                df = d * f;
            te[0] = ce + df * b;
            te[4] = de * b - cf;
            te[8] = a * d;
            te[1] = a * f;
            te[5] = a * e;
            te[9] = -b;
            te[2] = cf * b - de;
            te[6] = df + ce * b;
            te[10] = a * c;
            break;
          }

        case Euler.ZXY:
          {
            var _ce = c * e,
                _cf = c * f,
                _de = d * e,
                _df = d * f;

            te[0] = _ce - _df * b;
            te[4] = -a * f;
            te[8] = _de + _cf * b;
            te[1] = _cf + _de * b;
            te[5] = a * e;
            te[9] = _df - _ce * b;
            te[2] = -a * d;
            te[6] = b;
            te[10] = a * c;
            break;
          }

        case Euler.ZYX:
          {
            var _ae = a * e,
                _af = a * f,
                _be = b * e,
                _bf = b * f;

            te[0] = c * e;
            te[4] = _be * d - _af;
            te[8] = _ae * d + _bf;
            te[1] = c * f;
            te[5] = _bf * d + _ae;
            te[9] = _af * d - _be;
            te[2] = -d;
            te[6] = b * c;
            te[10] = a * c;
            break;
          }

        case Euler.YZX:
          {
            var ac = a * c,
                ad = a * d,
                bc = b * c,
                bd = b * d;
            te[0] = c * e;
            te[4] = bd - ac * f;
            te[8] = bc * f + ad;
            te[1] = f;
            te[5] = a * e;
            te[9] = -b * e;
            te[2] = -d * e;
            te[6] = ad * f + bc;
            te[10] = ac - bd * f;
            break;
          }

        case Euler.XZY:
          {
            var _ac = a * c,
                _ad = a * d,
                _bc = b * c,
                _bd = b * d;

            te[0] = c * e;
            te[4] = -f;
            te[8] = d * e;
            te[1] = _ac * f + _bd;
            te[5] = a * e;
            te[9] = _ad * f - _bc;
            te[2] = _bc * f - _ad;
            te[6] = b * e;
            te[10] = _bd * f + _ac;
            break;
          }

        default:
          throw new Error(ERR_UNKNOWN_ORDER);
      }

      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return te;
    }
  }, {
    key: "toQuaternion",
    value: function toQuaternion() {
      var cy = Math.cos(this.yaw * 0.5);
      var sy = Math.sin(this.yaw * 0.5);
      var cr = Math.cos(this.roll * 0.5);
      var sr = Math.sin(this.roll * 0.5);
      var cp = Math.cos(this.pitch * 0.5);
      var sp = Math.sin(this.pitch * 0.5);
      var w = cy * cr * cp + sy * sr * sp;
      var x = cy * sr * cp - sy * cr * sp;
      var y = cy * cr * sp + sy * sr * cp;
      var z = sy * cr * cp - cy * sr * sp;
      return new _quaternion__WEBPACK_IMPORTED_MODULE_9__["default"](x, y, z, w);
    }
  }, {
    key: "x",
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_8__["checkNumber"])(value);
    }
  }, {
    key: "y",
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_8__["checkNumber"])(value);
    }
  }, {
    key: "z",
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_8__["checkNumber"])(value);
    }
  }, {
    key: "alpha",
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_8__["checkNumber"])(value);
    }
  }, {
    key: "beta",
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_8__["checkNumber"])(value);
    }
  }, {
    key: "gamma",
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_8__["checkNumber"])(value);
    }
  }, {
    key: "phi",
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_8__["checkNumber"])(value);
    }
  }, {
    key: "theta",
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_8__["checkNumber"])(value);
    }
  }, {
    key: "psi",
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_8__["checkNumber"])(value);
    }
  }, {
    key: "roll",
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_8__["checkNumber"])(value);
    }
  }, {
    key: "pitch",
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_8__["checkNumber"])(value);
    }
  }, {
    key: "yaw",
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_8__["checkNumber"])(value);
    }
  }, {
    key: "order",
    get: function get() {
      return this[3];
    },
    set: function set(value) {
      return this[3] = checkOrder(value);
    }
  }]);

  return Euler;
}(_base_math_array__WEBPACK_IMPORTED_MODULE_6__["default"]);


//# sourceMappingURL=euler.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/classes/matrix3.js":
/*!*****************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/math.gl/dist/esm/classes/matrix3.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Matrix3; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "../../node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _base_matrix__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./base/matrix */ "../../node_modules/math.gl/dist/esm/classes/base/matrix.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib/validators */ "../../node_modules/math.gl/dist/esm/lib/validators.js");
/* harmony import */ var _lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../lib/gl-matrix-extras */ "../../node_modules/math.gl/dist/esm/lib/gl-matrix-extras.js");
/* harmony import */ var gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! gl-matrix/mat3 */ "../../node_modules/gl-matrix/esm/mat3.js");
/* harmony import */ var gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! gl-matrix/vec2 */ "../../node_modules/gl-matrix/esm/vec2.js");
/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! gl-matrix/vec3 */ "../../node_modules/gl-matrix/esm/vec3.js");











var IDENTITY = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
var ZERO = Object.freeze([0, 0, 0, 0, 0, 0, 0, 0, 0]);
var INDICES = Object.freeze({
  COL0ROW0: 0,
  COL0ROW1: 1,
  COL0ROW2: 2,
  COL1ROW0: 3,
  COL1ROW1: 4,
  COL1ROW2: 5,
  COL2ROW0: 6,
  COL2ROW1: 7,
  COL2ROW2: 8
});
var constants = {};

var Matrix3 = function (_Matrix) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__["default"])(Matrix3, _Matrix);

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__["default"])(Matrix3, [{
    key: "ELEMENTS",
    get: function get() {
      return 9;
    }
  }, {
    key: "RANK",
    get: function get() {
      return 3;
    }
  }, {
    key: "INDICES",
    get: function get() {
      return INDICES;
    }
  }], [{
    key: "IDENTITY",
    get: function get() {
      constants.IDENTITY = constants.IDENTITY || Object.freeze(new Matrix3(IDENTITY));
      return constants.IDENTITY;
    }
  }, {
    key: "ZERO",
    get: function get() {
      constants.ZERO = constants.ZERO || Object.freeze(new Matrix3(ZERO));
      return constants.ZERO;
    }
  }]);

  function Matrix3(array) {
    var _this;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Matrix3);

    _this = Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_1__["default"])(this, Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_2__["default"])(Matrix3).call(this, -0, -0, -0, -0, -0, -0, -0, -0, -0));

    if (arguments.length === 1 && Array.isArray(array)) {
      _this.copy(array);
    } else {
      _this.identity();
    }

    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__["default"])(Matrix3, [{
    key: "copy",
    value: function copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      this[4] = array[4];
      this[5] = array[5];
      this[6] = array[6];
      this[7] = array[7];
      this[8] = array[8];
      return this.check();
    }
  }, {
    key: "set",
    value: function set(m00, m10, m20, m01, m11, m21, m02, m12, m22) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m01;
      this[4] = m11;
      this[5] = m21;
      this[6] = m02;
      this[7] = m12;
      this[8] = m22;
      return this.check();
    }
  }, {
    key: "setRowMajor",
    value: function setRowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m01;
      this[4] = m11;
      this[5] = m21;
      this[6] = m02;
      this[7] = m12;
      this[8] = m22;
      return this.check();
    }
  }, {
    key: "determinant",
    value: function determinant() {
      return gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_8__["determinant"](this);
    }
  }, {
    key: "identity",
    value: function identity() {
      return this.copy(IDENTITY);
    }
  }, {
    key: "fromQuaternion",
    value: function fromQuaternion(q) {
      gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_8__["fromQuat"](this, q);
      return this.check();
    }
  }, {
    key: "transpose",
    value: function transpose() {
      gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_8__["transpose"](this, this);
      return this.check();
    }
  }, {
    key: "invert",
    value: function invert() {
      gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_8__["invert"](this, this);
      return this.check();
    }
  }, {
    key: "multiplyLeft",
    value: function multiplyLeft(a) {
      gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_8__["multiply"](this, a, this);
      return this.check();
    }
  }, {
    key: "multiplyRight",
    value: function multiplyRight(a) {
      gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_8__["multiply"](this, this, a);
      return this.check();
    }
  }, {
    key: "rotate",
    value: function rotate(radians) {
      gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_8__["rotate"](this, this, radians);
      return this.check();
    }
  }, {
    key: "scale",
    value: function scale(factor) {
      if (Array.isArray(factor)) {
        gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_8__["scale"](this, this, factor);
      } else {
        gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_8__["scale"](this, this, [factor, factor, factor]);
      }

      return this.check();
    }
  }, {
    key: "translate",
    value: function translate(vec) {
      gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_8__["translate"](this, this, vec);
      return this.check();
    }
  }, {
    key: "transform",
    value: function transform(vector, result) {
      switch (vector.length) {
        case 2:
          result = gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_9__["transformMat3"](result || [-0, -0], vector, this);
          break;

        case 3:
          result = gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_10__["transformMat3"](result || [-0, -0, -0], vector, this);
          break;

        case 4:
          result = Object(_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_7__["vec4_transformMat3"])(result || [-0, -0, -0, -0], vector, this);
          break;

        default:
          throw new Error('Illegal vector');
      }

      Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkVector"])(result, vector.length);
      return result;
    }
  }, {
    key: "transformVector",
    value: function transformVector(vector, result) {
      Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["deprecated"])('Matrix3.transformVector');
      return this.transform(vector, result);
    }
  }, {
    key: "transformVector2",
    value: function transformVector2(vector, result) {
      Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["deprecated"])('Matrix3.transformVector');
      return this.transform(vector, result);
    }
  }, {
    key: "transformVector3",
    value: function transformVector3(vector, result) {
      Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["deprecated"])('Matrix3.transformVector');
      return this.transform(vector, result);
    }
  }]);

  return Matrix3;
}(_base_matrix__WEBPACK_IMPORTED_MODULE_5__["default"]);


//# sourceMappingURL=matrix3.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/classes/matrix4.js":
/*!*****************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/math.gl/dist/esm/classes/matrix4.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Matrix4; });
/* harmony import */ var _babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/slicedToArray */ "../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "../../node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib/validators */ "../../node_modules/math.gl/dist/esm/lib/validators.js");
/* harmony import */ var _base_matrix__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./base/matrix */ "../../node_modules/math.gl/dist/esm/classes/base/matrix.js");
/* harmony import */ var _lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../lib/gl-matrix-extras */ "../../node_modules/math.gl/dist/esm/lib/gl-matrix-extras.js");
/* harmony import */ var gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! gl-matrix/mat4 */ "../../node_modules/gl-matrix/esm/mat4.js");
/* harmony import */ var gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! gl-matrix/vec2 */ "../../node_modules/gl-matrix/esm/vec2.js");
/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! gl-matrix/vec3 */ "../../node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var gl_matrix_vec4__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! gl-matrix/vec4 */ "../../node_modules/gl-matrix/esm/vec4.js");













var IDENTITY = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
var ZERO = Object.freeze([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
var INDICES = Object.freeze({
  COL0ROW0: 0,
  COL0ROW1: 1,
  COL0ROW2: 2,
  COL0ROW3: 3,
  COL1ROW0: 4,
  COL1ROW1: 5,
  COL1ROW2: 6,
  COL1ROW3: 7,
  COL2ROW0: 8,
  COL2ROW1: 9,
  COL2ROW2: 10,
  COL2ROW3: 11,
  COL3ROW0: 12,
  COL3ROW1: 13,
  COL3ROW2: 14,
  COL3ROW3: 15
});
var constants = {};

var Matrix4 = function (_Matrix) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_5__["default"])(Matrix4, _Matrix);

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__["default"])(Matrix4, [{
    key: "INDICES",
    get: function get() {
      return INDICES;
    }
  }, {
    key: "ELEMENTS",
    get: function get() {
      return 16;
    }
  }, {
    key: "RANK",
    get: function get() {
      return 4;
    }
  }], [{
    key: "IDENTITY",
    get: function get() {
      constants.IDENTITY = constants.IDENTITY || Object.freeze(new Matrix4(IDENTITY));
      return constants.IDENTITY;
    }
  }, {
    key: "ZERO",
    get: function get() {
      constants.ZERO = constants.ZERO || Object.freeze(new Matrix4(ZERO));
      return constants.ZERO;
    }
  }]);

  function Matrix4(array) {
    var _this;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__["default"])(this, Matrix4);

    _this = Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__["default"])(this, Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__["default"])(Matrix4).call(this, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0));

    if (arguments.length === 1 && Array.isArray(array)) {
      _this.copy(array);
    } else {
      _this.identity();
    }

    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__["default"])(Matrix4, [{
    key: "copy",
    value: function copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      this[4] = array[4];
      this[5] = array[5];
      this[6] = array[6];
      this[7] = array[7];
      this[8] = array[8];
      this[9] = array[9];
      this[10] = array[10];
      this[11] = array[11];
      this[12] = array[12];
      this[13] = array[13];
      this[14] = array[14];
      this[15] = array[15];
      return this.check();
    }
  }, {
    key: "set",
    value: function set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
  }, {
    key: "setRowMajor",
    value: function setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
  }, {
    key: "toRowMajor",
    value: function toRowMajor(result) {
      result[0] = this[0];
      result[1] = this[4];
      result[2] = this[8];
      result[3] = this[12];
      result[4] = this[1];
      result[5] = this[5];
      result[6] = this[9];
      result[7] = this[13];
      result[8] = this[2];
      result[9] = this[6];
      result[10] = this[10];
      result[11] = this[14];
      result[12] = this[3];
      result[13] = this[7];
      result[14] = this[11];
      result[15] = this[15];
      return result;
    }
  }, {
    key: "identity",
    value: function identity() {
      return this.copy(IDENTITY);
    }
  }, {
    key: "fromQuaternion",
    value: function fromQuaternion(q) {
      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["fromQuat"](this, q);
      return this.check();
    }
  }, {
    key: "frustum",
    value: function frustum(_ref) {
      var left = _ref.left,
          right = _ref.right,
          bottom = _ref.bottom,
          top = _ref.top,
          near = _ref.near,
          far = _ref.far;

      if (far === Infinity) {
        Matrix4._computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);
      } else {
        gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["frustum"](this, left, right, bottom, top, near, far);
      }

      return this.check();
    }
  }, {
    key: "lookAt",
    value: function lookAt(eye, center, up) {
      if (arguments.length === 1) {
        var _eye = eye;
        eye = _eye.eye;
        center = _eye.center;
        up = _eye.up;
      }

      center = center || [0, 0, 0];
      up = up || [0, 1, 0];
      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["lookAt"](this, eye, center, up);
      return this.check();
    }
  }, {
    key: "ortho",
    value: function ortho(_ref2) {
      var left = _ref2.left,
          right = _ref2.right,
          bottom = _ref2.bottom,
          top = _ref2.top,
          _ref2$near = _ref2.near,
          near = _ref2$near === void 0 ? 0.1 : _ref2$near,
          _ref2$far = _ref2.far,
          far = _ref2$far === void 0 ? 500 : _ref2$far;
      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["ortho"](this, left, right, bottom, top, near, far);
      return this.check();
    }
  }, {
    key: "orthographic",
    value: function orthographic(_ref3) {
      var _ref3$fovy = _ref3.fovy,
          fovy = _ref3$fovy === void 0 ? 45 * Math.PI / 180 : _ref3$fovy,
          _ref3$aspect = _ref3.aspect,
          aspect = _ref3$aspect === void 0 ? 1 : _ref3$aspect,
          _ref3$focalDistance = _ref3.focalDistance,
          focalDistance = _ref3$focalDistance === void 0 ? 1 : _ref3$focalDistance,
          _ref3$near = _ref3.near,
          near = _ref3$near === void 0 ? 0.1 : _ref3$near,
          _ref3$far = _ref3.far,
          far = _ref3$far === void 0 ? 500 : _ref3$far;

      if (fovy > Math.PI * 2) {
        throw Error('radians');
      }

      var halfY = fovy / 2;
      var top = focalDistance * Math.tan(halfY);
      var right = top * aspect;
      return new Matrix4().ortho({
        left: -right,
        right: right,
        bottom: -top,
        top: top,
        near: near,
        far: far
      });
    }
  }, {
    key: "perspective",
    value: function perspective() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          fovy = _ref4.fovy,
          _ref4$fov = _ref4.fov,
          fov = _ref4$fov === void 0 ? 45 * Math.PI / 180 : _ref4$fov,
          _ref4$aspect = _ref4.aspect,
          aspect = _ref4$aspect === void 0 ? 1 : _ref4$aspect,
          _ref4$near = _ref4.near,
          near = _ref4$near === void 0 ? 0.1 : _ref4$near,
          _ref4$far = _ref4.far,
          far = _ref4$far === void 0 ? 500 : _ref4$far;

      fovy = fovy || fov;

      if (fovy > Math.PI * 2) {
        throw Error('radians');
      }

      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["perspective"](this, fovy, aspect, near, far);
      return this.check();
    }
  }, {
    key: "determinant",
    value: function determinant() {
      return gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["determinant"](this);
    }
  }, {
    key: "getScale",
    value: function getScale() {
      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [-0, -0, -0];
      result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
      result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
      result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
      return result;
    }
  }, {
    key: "getTranslation",
    value: function getTranslation() {
      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [-0, -0, -0];
      result[0] = this[12];
      result[1] = this[13];
      result[2] = this[14];
      return result;
    }
  }, {
    key: "getRotation",
    value: function getRotation() {
      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
      var scaleResult = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var scale = this.getScale(scaleResult || [-0, -0, -0]);
      var inverseScale0 = 1 / scale[0];
      var inverseScale1 = 1 / scale[1];
      var inverseScale2 = 1 / scale[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = 0;
      result[4] = this[4] * inverseScale0;
      result[5] = this[5] * inverseScale1;
      result[6] = this[6] * inverseScale2;
      result[7] = 0;
      result[8] = this[8] * inverseScale0;
      result[9] = this[9] * inverseScale1;
      result[10] = this[10] * inverseScale2;
      result[11] = 0;
      result[12] = 0;
      result[13] = 0;
      result[14] = 0;
      result[15] = 1;
      return result;
    }
  }, {
    key: "getRotationMatrix3",
    value: function getRotationMatrix3() {
      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [-0, -0, -0, -0, -0, -0, -0, -0, -0];
      var scaleResult = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var scale = this.getScale(scaleResult || [-0, -0, -0]);
      var inverseScale0 = 1 / scale[0];
      var inverseScale1 = 1 / scale[1];
      var inverseScale2 = 1 / scale[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = this[4] * inverseScale0;
      result[4] = this[5] * inverseScale1;
      result[5] = this[6] * inverseScale2;
      result[6] = this[8] * inverseScale0;
      result[7] = this[9] * inverseScale1;
      result[8] = this[10] * inverseScale2;
      return result;
    }
  }, {
    key: "transpose",
    value: function transpose() {
      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["transpose"](this, this);
      return this.check();
    }
  }, {
    key: "invert",
    value: function invert() {
      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["invert"](this, this);
      return this.check();
    }
  }, {
    key: "multiplyLeft",
    value: function multiplyLeft(a) {
      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["multiply"](this, a, this);
      return this.check();
    }
  }, {
    key: "multiplyRight",
    value: function multiplyRight(a) {
      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["multiply"](this, this, a);
      return this.check();
    }
  }, {
    key: "rotateX",
    value: function rotateX(radians) {
      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["rotateX"](this, this, radians);
      return this.check();
    }
  }, {
    key: "rotateY",
    value: function rotateY(radians) {
      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["rotateY"](this, this, radians);
      return this.check();
    }
  }, {
    key: "rotateZ",
    value: function rotateZ(radians) {
      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["rotateZ"](this, this, radians);
      return this.check();
    }
  }, {
    key: "rotateXYZ",
    value: function rotateXYZ(_ref5) {
      var _ref6 = Object(_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(_ref5, 3),
          rx = _ref6[0],
          ry = _ref6[1],
          rz = _ref6[2];

      return this.rotateX(rx).rotateY(ry).rotateZ(rz);
    }
  }, {
    key: "rotateAxis",
    value: function rotateAxis(radians, axis) {
      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["rotate"](this, this, radians, axis);
      return this.check();
    }
  }, {
    key: "scale",
    value: function scale(factor) {
      if (Array.isArray(factor)) {
        gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["scale"](this, this, factor);
      } else {
        gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["scale"](this, this, [factor, factor, factor]);
      }

      return this.check();
    }
  }, {
    key: "translate",
    value: function translate(vec) {
      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["translate"](this, this, vec);
      return this.check();
    }
  }, {
    key: "transform",
    value: function transform(vector, result) {
      if (vector.length === 4) {
        result = gl_matrix_vec4__WEBPACK_IMPORTED_MODULE_12__["transformMat4"](result || [-0, -0, -0, -0], vector, this);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkVector"])(result, 4);
        return result;
      }

      return this.transformAsPoint(vector, result);
    }
  }, {
    key: "transformAsPoint",
    value: function transformAsPoint(vector, result) {
      var length = vector.length;

      switch (length) {
        case 2:
          result = gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_10__["transformMat4"](result || [-0, -0], vector, this);
          break;

        case 3:
          result = gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_11__["transformMat4"](result || [-0, -0, -0], vector, this);
          break;

        default:
          throw new Error('Illegal vector');
      }

      Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkVector"])(result, vector.length);
      return result;
    }
  }, {
    key: "transformAsVector",
    value: function transformAsVector(vector, result) {
      switch (vector.length) {
        case 2:
          result = Object(_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_8__["vec2_transformMat4AsVector"])(result || [-0, -0], vector, this);
          break;

        case 3:
          result = Object(_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_8__["vec3_transformMat4AsVector"])(result || [-0, -0, -0], vector, this);
          break;

        default:
          throw new Error('Illegal vector');
      }

      Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkVector"])(result, vector.length);
      return result;
    }
  }, {
    key: "makeRotationX",
    value: function makeRotationX(radians) {
      return this.identity().rotateX(radians);
    }
  }, {
    key: "makeTranslation",
    value: function makeTranslation(x, y, z) {
      return this.identity().translate([x, y, z]);
    }
  }, {
    key: "transformPoint",
    value: function transformPoint(vector, result) {
      Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["deprecated"])('Matrix4.transformPoint', '3.0');
      return this.transformAsPoint(vector, result);
    }
  }, {
    key: "transformVector",
    value: function transformVector(vector, result) {
      Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["deprecated"])('Matrix4.transformVector', '3.0');
      return this.transformAsPoint(vector, result);
    }
  }, {
    key: "transformDirection",
    value: function transformDirection(vector, result) {
      Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["deprecated"])('Matrix4.transformDirection', '3.0');
      return this.transformAsVector(vector, result);
    }
  }], [{
    key: "_computeInfinitePerspectiveOffCenter",
    value: function _computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {
      var column0Row0 = 2.0 * near / (right - left);
      var column1Row1 = 2.0 * near / (top - bottom);
      var column2Row0 = (right + left) / (right - left);
      var column2Row1 = (top + bottom) / (top - bottom);
      var column2Row2 = -1.0;
      var column2Row3 = -1.0;
      var column3Row2 = -2.0 * near;
      result[0] = column0Row0;
      result[1] = 0.0;
      result[2] = 0.0;
      result[3] = 0.0;
      result[4] = 0.0;
      result[5] = column1Row1;
      result[6] = 0.0;
      result[7] = 0.0;
      result[8] = column2Row0;
      result[9] = column2Row1;
      result[10] = column2Row2;
      result[11] = column2Row3;
      result[12] = 0.0;
      result[13] = 0.0;
      result[14] = column3Row2;
      result[15] = 0.0;
      return result;
    }
  }]);

  return Matrix4;
}(_base_matrix__WEBPACK_IMPORTED_MODULE_7__["default"]);


//# sourceMappingURL=matrix4.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/classes/pose.js":
/*!**************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/math.gl/dist/esm/classes/pose.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Pose; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _matrix4__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./matrix4 */ "../../node_modules/math.gl/dist/esm/classes/matrix4.js");
/* harmony import */ var _vector3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vector3 */ "../../node_modules/math.gl/dist/esm/classes/vector3.js");
/* harmony import */ var _euler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./euler */ "../../node_modules/math.gl/dist/esm/classes/euler.js");






var Pose = function () {
  function Pose() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$x = _ref.x,
        x = _ref$x === void 0 ? 0 : _ref$x,
        _ref$y = _ref.y,
        y = _ref$y === void 0 ? 0 : _ref$y,
        _ref$z = _ref.z,
        z = _ref$z === void 0 ? 0 : _ref$z,
        _ref$roll = _ref.roll,
        roll = _ref$roll === void 0 ? 0 : _ref$roll,
        _ref$pitch = _ref.pitch,
        pitch = _ref$pitch === void 0 ? 0 : _ref$pitch,
        _ref$yaw = _ref.yaw,
        yaw = _ref$yaw === void 0 ? 0 : _ref$yaw,
        position = _ref.position,
        orientation = _ref.orientation;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Pose);

    if (Array.isArray(position) && position.length === 3) {
      this.position = new _vector3__WEBPACK_IMPORTED_MODULE_3__["default"](position);
    } else {
      this.position = new _vector3__WEBPACK_IMPORTED_MODULE_3__["default"](x, y, z);
    }

    if (Array.isArray(orientation) && orientation.length === 4) {
      this.orientation = new _euler__WEBPACK_IMPORTED_MODULE_4__["default"](orientation, orientation[3]);
    } else {
      this.orientation = new _euler__WEBPACK_IMPORTED_MODULE_4__["default"](roll, pitch, yaw, _euler__WEBPACK_IMPORTED_MODULE_4__["default"].RollPitchYaw);
    }
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Pose, [{
    key: "getPosition",
    value: function getPosition() {
      return this.position;
    }
  }, {
    key: "getOrientation",
    value: function getOrientation() {
      return this.orientation;
    }
  }, {
    key: "equals",
    value: function equals(pose) {
      if (!pose) {
        return false;
      }

      return this.position.equals(pose.position) && this.orientation.equals(pose.orientation);
    }
  }, {
    key: "exactEquals",
    value: function exactEquals(pose) {
      if (!pose) {
        return false;
      }

      return this.position.exactEquals(pose.position) && this.orientation.exactEquals(pose.orientation);
    }
  }, {
    key: "getTransformationMatrix",
    value: function getTransformationMatrix() {
      var sr = Math.sin(this.roll);
      var sp = Math.sin(this.pitch);
      var sw = Math.sin(this.yaw);
      var cr = Math.cos(this.roll);
      var cp = Math.cos(this.pitch);
      var cw = Math.cos(this.yaw);
      var matrix = new _matrix4__WEBPACK_IMPORTED_MODULE_2__["default"]().setRowMajor(cw * cp, -sw * cr + cw * sp * sr, sw * sr + cw * sp * cr, this.x, sw * cp, cw * cr + sw * sp * sr, -cw * sr + sw * sp * cr, this.y, -sp, cp * sr, cp * cr, this.z, 0, 0, 0, 1);
      return matrix;
    }
  }, {
    key: "getTransformationMatrixFromPose",
    value: function getTransformationMatrixFromPose(pose) {
      return new _matrix4__WEBPACK_IMPORTED_MODULE_2__["default"]().multiplyRight(this.getTransformationMatrix()).multiplyRight(pose.getTransformationMatrix().invert());
    }
  }, {
    key: "getTransformationMatrixToPose",
    value: function getTransformationMatrixToPose(pose) {
      return new _matrix4__WEBPACK_IMPORTED_MODULE_2__["default"]().multiplyRight(pose.getTransformationMatrix()).multiplyRight(this.getTransformationMatrix().invert());
    }
  }, {
    key: "x",
    get: function get() {
      return this.position.x;
    },
    set: function set(value) {
      return this.position.x = value;
    }
  }, {
    key: "y",
    get: function get() {
      return this.position.y;
    },
    set: function set(value) {
      return this.position.y = value;
    }
  }, {
    key: "z",
    get: function get() {
      return this.position.z;
    },
    set: function set(value) {
      return this.position.z = value;
    }
  }, {
    key: "roll",
    get: function get() {
      return this.orientation.roll;
    },
    set: function set(value) {
      return this.orientation.roll = value;
    }
  }, {
    key: "pitch",
    get: function get() {
      return this.orientation.pitch;
    },
    set: function set(value) {
      return this.orientation.pitch = value;
    }
  }, {
    key: "yaw",
    get: function get() {
      return this.orientation.yaw;
    },
    set: function set(value) {
      return this.orientation.yaw = value;
    }
  }]);

  return Pose;
}();


//# sourceMappingURL=pose.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/classes/quaternion.js":
/*!********************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/math.gl/dist/esm/classes/quaternion.js ***!
  \********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Quaternion; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "../../node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _base_math_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./base/math-array */ "../../node_modules/math.gl/dist/esm/classes/base/math-array.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib/validators */ "../../node_modules/math.gl/dist/esm/lib/validators.js");
/* harmony import */ var _lib_assert__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../lib/assert */ "../../node_modules/math.gl/dist/esm/lib/assert.js");
/* harmony import */ var gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! gl-matrix/quat */ "../../node_modules/gl-matrix/esm/quat.js");
/* harmony import */ var gl_matrix_vec4__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! gl-matrix/vec4 */ "../../node_modules/gl-matrix/esm/vec4.js");










var IDENTITY_QUATERNION = [0, 0, 0, 1];

var Quaternion = function (_MathArray) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__["default"])(Quaternion, _MathArray);

  function Quaternion() {
    var _this;

    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Quaternion);

    _this = Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__["default"])(this, Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__["default"])(Quaternion).call(this, -0, -0, -0, -0));

    if (Array.isArray(x) && arguments.length === 1) {
      _this.copy(x);
    } else {
      _this.set(x, y, z, w);
    }

    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Quaternion, [{
    key: "copy",
    value: function copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      return this.check();
    }
  }, {
    key: "set",
    value: function set(x, y, z, w) {
      this[0] = x;
      this[1] = y;
      this[2] = z;
      this[3] = w;
      return this.check();
    }
  }, {
    key: "fromMatrix3",
    value: function fromMatrix3(m) {
      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["fromMat3"](this, m);
      return this.check();
    }
  }, {
    key: "identity",
    value: function identity() {
      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["identity"](this);
      return this.check();
    }
  }, {
    key: "fromAxisRotation",
    value: function fromAxisRotation(axis, rad) {
      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["setAxisAngle"](this, axis, rad);
      return this.check();
    }
  }, {
    key: "setAxisAngle",
    value: function setAxisAngle(axis, rad) {
      return this.fromAxisRotation(axis, rad);
    }
  }, {
    key: "len",
    value: function len() {
      return gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["length"](this);
    }
  }, {
    key: "lengthSquared",
    value: function lengthSquared(a) {
      return gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["squaredLength"](this);
    }
  }, {
    key: "dot",
    value: function dot(a, b) {
      if (b !== undefined) {
        throw new Error('Quaternion.dot only takes one argument');
      }

      return gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["dot"](this, a);
    }
  }, {
    key: "rotationTo",
    value: function rotationTo(vectorA, vectorB) {
      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["rotationTo"](this, vectorA, vectorB);
      return this.check();
    }
  }, {
    key: "add",
    value: function add(a, b) {
      if (b !== undefined) {
        throw new Error('Quaternion.add only takes one argument');
      }

      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["add"](this, this, a);
      return this.check();
    }
  }, {
    key: "calculateW",
    value: function calculateW() {
      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["calculateW"](this, this);
      return this.check();
    }
  }, {
    key: "conjugate",
    value: function conjugate() {
      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["conjugate"](this, this);
      return this.check();
    }
  }, {
    key: "invert",
    value: function invert() {
      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["invert"](this, this);
      return this.check();
    }
  }, {
    key: "lerp",
    value: function lerp(a, b, t) {
      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["lerp"](this, a, b, t);
      return this.check();
    }
  }, {
    key: "multiplyRight",
    value: function multiplyRight(a, b) {
      Object(_lib_assert__WEBPACK_IMPORTED_MODULE_7__["default"])(!b);
      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["multiply"](this, this, a);
      return this.check();
    }
  }, {
    key: "multiplyLeft",
    value: function multiplyLeft(a, b) {
      Object(_lib_assert__WEBPACK_IMPORTED_MODULE_7__["default"])(!b);
      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["multiply"](this, a, this);
      return this.check();
    }
  }, {
    key: "normalize",
    value: function normalize() {
      var length = this.len();
      var l = length > 0 ? 1 / length : 0;
      this[0] = this[0] * l;
      this[1] = this[1] * l;
      this[2] = this[2] * l;
      this[3] = this[3] * l;

      if (length === 0) {
        this[3] = 1;
      }

      return this.check();
    }
  }, {
    key: "rotateX",
    value: function rotateX(rad) {
      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["rotateX"](this, this, rad);
      return this.check();
    }
  }, {
    key: "rotateY",
    value: function rotateY(rad) {
      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["rotateY"](this, this, rad);
      return this.check();
    }
  }, {
    key: "rotateZ",
    value: function rotateZ(rad) {
      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["rotateZ"](this, this, rad);
      return this.check();
    }
  }, {
    key: "scale",
    value: function scale(b) {
      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["scale"](this, this, b);
      return this.check();
    }
  }, {
    key: "slerp",
    value: function slerp(start, target, ratio) {
      switch (arguments.length) {
        case 1:
          var _arguments$ = arguments[0];
          var _arguments$$start = _arguments$.start;
          start = _arguments$$start === void 0 ? IDENTITY_QUATERNION : _arguments$$start;
          target = _arguments$.target;
          ratio = _arguments$.ratio;
          break;

        case 2:
          var _arguments = Array.prototype.slice.call(arguments);

          target = _arguments[0];
          ratio = _arguments[1];
          start = this;
          break;

        default:
      }

      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["slerp"](this, start, target, ratio);
      return this.check();
    }
  }, {
    key: "transformVector4",
    value: function transformVector4(vector) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : vector;
      gl_matrix_vec4__WEBPACK_IMPORTED_MODULE_9__["transformQuat"](result, vector, this);
      return Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkVector"])(result, 4);
    }
  }, {
    key: "lengthSq",
    value: function lengthSq() {
      return this.lengthSquared();
    }
  }, {
    key: "setFromAxisAngle",
    value: function setFromAxisAngle(axis, rad) {
      return this.setAxisAngle(axis, rad);
    }
  }, {
    key: "premultiply",
    value: function premultiply(a, b) {
      return this.multiplyLeft(a, b);
    }
  }, {
    key: "multiply",
    value: function multiply(a, b) {
      return this.multiplyRight(a, b);
    }
  }, {
    key: "ELEMENTS",
    get: function get() {
      return 4;
    }
  }, {
    key: "x",
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkNumber"])(value);
    }
  }, {
    key: "y",
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkNumber"])(value);
    }
  }, {
    key: "z",
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkNumber"])(value);
    }
  }, {
    key: "w",
    get: function get() {
      return this[3];
    },
    set: function set(value) {
      return this[3] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkNumber"])(value);
    }
  }]);

  return Quaternion;
}(_base_math_array__WEBPACK_IMPORTED_MODULE_5__["default"]);


//# sourceMappingURL=quaternion.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/classes/spherical-coordinates.js":
/*!*******************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/math.gl/dist/esm/classes/spherical-coordinates.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SphericalCoordinates; });
/* harmony import */ var _babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/slicedToArray */ "../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/common */ "../../node_modules/math.gl/dist/esm/lib/common.js");
/* harmony import */ var _vector3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./vector3 */ "../../node_modules/math.gl/dist/esm/classes/vector3.js");
/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! gl-matrix/vec3 */ "../../node_modules/gl-matrix/esm/vec3.js");







var EPSILON = 0.000001;
var EARTH_RADIUS_METERS = 6.371e6;

var SphericalCoordinates = function () {
  function SphericalCoordinates() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        phi = _ref.phi,
        theta = _ref.theta,
        radius = _ref.radius,
        bearing = _ref.bearing,
        pitch = _ref.pitch,
        altitude = _ref.altitude,
        _ref$radiusScale = _ref.radiusScale,
        radiusScale = _ref$radiusScale === void 0 ? EARTH_RADIUS_METERS : _ref$radiusScale;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__["default"])(this, SphericalCoordinates);

    if (arguments.length === 0) {
      this.phi = 0;
      this.theta = 0;
      this.radius = 1;
    } else if (Number.isFinite(phi) || Number.isFinite(theta)) {
      this.phi = phi || 0;
      this.theta = theta || 0;
    } else if (Number.isFinite(bearing) || Number.isFinite(pitch)) {
      this.bearing = bearing || 0;
      this.pitch = pitch || 0;
    }

    this.radius = radius || 1;
    this.radiusScale = radiusScale || 1;
    this.check();
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__["default"])(SphericalCoordinates, [{
    key: "toString",
    value: function toString() {
      return this.formatString(_lib_common__WEBPACK_IMPORTED_MODULE_3__["config"]);
    }
  }, {
    key: "formatString",
    value: function formatString(_ref2) {
      var printTypes = _ref2.printTypes,
          printDegrees = _ref2.printDegrees;
      var f = _lib_common__WEBPACK_IMPORTED_MODULE_3__["formatValue"];
      return "".concat(printTypes ? 'Spherical' : '', "[rho:").concat(f(this.radius), ",theta:").concat(f(this.theta), ",phi:").concat(f(this.phi), "]");
    }
  }, {
    key: "equals",
    value: function equals(other) {
      return Object(_lib_common__WEBPACK_IMPORTED_MODULE_3__["equals"])(this.radius, other.radius) && Object(_lib_common__WEBPACK_IMPORTED_MODULE_3__["equals"])(this.theta, other.theta) && Object(_lib_common__WEBPACK_IMPORTED_MODULE_3__["equals"])(this.phi, other.phi);
    }
  }, {
    key: "exactEquals",
    value: function exactEquals(other) {
      return this.radius === other.radius && this.theta === other.theta && this.phi === other.phi;
    }
  }, {
    key: "set",
    value: function set(radius, phi, theta) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      return this.check();
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(other) {
      this.radius = other.radius;
      this.phi = other.phi;
      this.theta = other.theta;
      return this.check();
    }
  }, {
    key: "fromLngLatZ",
    value: function fromLngLatZ(_ref3) {
      var _ref4 = Object(_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(_ref3, 3),
          lng = _ref4[0],
          lat = _ref4[1],
          z = _ref4[2];

      this.radius = 1 + z / this.radiusScale;
      this.phi = Object(_lib_common__WEBPACK_IMPORTED_MODULE_3__["radians"])(lat);
      this.theta = Object(_lib_common__WEBPACK_IMPORTED_MODULE_3__["radians"])(lng);
    }
  }, {
    key: "fromVector3",
    value: function fromVector3(v) {
      this.radius = gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_5__["length"](v);

      if (this.radius > 0) {
        this.theta = Math.atan2(v[0], v[1]);
        this.phi = Math.acos(Object(_lib_common__WEBPACK_IMPORTED_MODULE_3__["clamp"])(v[2] / this.radius, -1, 1));
      }

      return this.check();
    }
  }, {
    key: "toVector3",
    value: function toVector3() {
      return new _vector3__WEBPACK_IMPORTED_MODULE_4__["default"](0, 0, this.radius).rotateX({
        radians: this.theta
      }).rotateZ({
        radians: this.phi
      });
    }
  }, {
    key: "makeSafe",
    value: function makeSafe() {
      this.phi = Math.max(EPSILON, Math.min(Math.PI - EPSILON, this.phi));
    }
  }, {
    key: "check",
    value: function check() {
      if (!Number.isFinite(this.phi) || !Number.isFinite(this.theta) || !(this.radius > 0)) {
        throw new Error('SphericalCoordinates: some fields set to invalid numbers');
      }

      return this;
    }
  }, {
    key: "bearing",
    get: function get() {
      return 180 - Object(_lib_common__WEBPACK_IMPORTED_MODULE_3__["degrees"])(this.phi);
    },
    set: function set(v) {
      this.phi = Math.PI - Object(_lib_common__WEBPACK_IMPORTED_MODULE_3__["radians"])(v);
    }
  }, {
    key: "pitch",
    get: function get() {
      return Object(_lib_common__WEBPACK_IMPORTED_MODULE_3__["degrees"])(this.theta);
    },
    set: function set(v) {
      this.theta = Object(_lib_common__WEBPACK_IMPORTED_MODULE_3__["radians"])(v);
    }
  }, {
    key: "longitude",
    get: function get() {
      return Object(_lib_common__WEBPACK_IMPORTED_MODULE_3__["degrees"])(this.phi);
    }
  }, {
    key: "latitude",
    get: function get() {
      return Object(_lib_common__WEBPACK_IMPORTED_MODULE_3__["degrees"])(this.theta);
    }
  }, {
    key: "lng",
    get: function get() {
      return Object(_lib_common__WEBPACK_IMPORTED_MODULE_3__["degrees"])(this.phi);
    }
  }, {
    key: "lat",
    get: function get() {
      return Object(_lib_common__WEBPACK_IMPORTED_MODULE_3__["degrees"])(this.theta);
    }
  }, {
    key: "z",
    get: function get() {
      return (this.radius - 1) * this.radiusScale;
    }
  }]);

  return SphericalCoordinates;
}();


//# sourceMappingURL=spherical-coordinates.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/classes/vector2.js":
/*!*****************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/math.gl/dist/esm/classes/vector2.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Vector2; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "../../node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _base_vector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./base/vector */ "../../node_modules/math.gl/dist/esm/classes/base/vector.js");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib/common */ "../../node_modules/math.gl/dist/esm/lib/common.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../lib/validators */ "../../node_modules/math.gl/dist/esm/lib/validators.js");
/* harmony import */ var gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! gl-matrix/vec2 */ "../../node_modules/gl-matrix/esm/vec2.js");
/* harmony import */ var _lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../lib/gl-matrix-extras */ "../../node_modules/math.gl/dist/esm/lib/gl-matrix-extras.js");











var Vector2 = function (_Vector) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__["default"])(Vector2, _Vector);

  function Vector2() {
    var _this;

    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Vector2);

    _this = Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__["default"])(this, Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__["default"])(Vector2).call(this, 2));

    if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_6__["isArray"])(x) && arguments.length === 1) {
      _this.copy(x);
    } else {
      if (_lib_common__WEBPACK_IMPORTED_MODULE_6__["config"].debug) {
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(x);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(y);
      }

      _this[0] = x;
      _this[1] = y;
    }

    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Vector2, [{
    key: "set",
    value: function set(x, y, z) {
      this[0] = x;
      this[1] = y;
      return this.check();
    }
  }, {
    key: "copy",
    value: function copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      return this.check();
    }
  }, {
    key: "fromObject",
    value: function fromObject(object) {
      if (_lib_common__WEBPACK_IMPORTED_MODULE_6__["config"].debug) {
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(object.x);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(object.y);
      }

      this[0] = object.x;
      this[1] = object.y;
      return this.check();
    }
  }, {
    key: "toObject",
    value: function toObject(object) {
      object.x = this[0];
      object.y = this[1];
      return object;
    }
  }, {
    key: "horizontalAngle",
    value: function horizontalAngle() {
      return Math.atan2(this.y, this.x);
    }
  }, {
    key: "verticalAngle",
    value: function verticalAngle() {
      return Math.atan2(this.x, this.y);
    }
  }, {
    key: "transform",
    value: function transform(matrix4) {
      return this.transformAsPoint(matrix4);
    }
  }, {
    key: "transformAsPoint",
    value: function transformAsPoint(matrix4) {
      gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_8__["transformMat4"](this, this, matrix4);
      return this.check();
    }
  }, {
    key: "transformAsVector",
    value: function transformAsVector(matrix4) {
      Object(_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_9__["vec2_transformMat4AsVector"])(this, this, matrix4);
      return this.check();
    }
  }, {
    key: "transformByMatrix3",
    value: function transformByMatrix3(matrix3) {
      gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_8__["transformMat3"](this, this, matrix3);
      return this.check();
    }
  }, {
    key: "transformByMatrix2x3",
    value: function transformByMatrix2x3(matrix2x3) {
      gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_8__["transformMat2d"](this, this, matrix2x3);
      return this.check();
    }
  }, {
    key: "transformByMatrix2",
    value: function transformByMatrix2(matrix2) {
      gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_8__["transformMat2"](this, this, matrix2);
      return this.check();
    }
  }, {
    key: "ELEMENTS",
    get: function get() {
      return 2;
    }
  }]);

  return Vector2;
}(_base_vector__WEBPACK_IMPORTED_MODULE_5__["default"]);


//# sourceMappingURL=vector2.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/classes/vector3.js":
/*!*****************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/math.gl/dist/esm/classes/vector3.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Vector3; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "../../node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _base_vector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./base/vector */ "../../node_modules/math.gl/dist/esm/classes/base/vector.js");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib/common */ "../../node_modules/math.gl/dist/esm/lib/common.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../lib/validators */ "../../node_modules/math.gl/dist/esm/lib/validators.js");
/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! gl-matrix/vec3 */ "../../node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var _lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../lib/gl-matrix-extras */ "../../node_modules/math.gl/dist/esm/lib/gl-matrix-extras.js");










var ORIGIN = [0, 0, 0];

var Vector3 = function (_Vector) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__["default"])(Vector3, _Vector);

  function Vector3() {
    var _this;

    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Vector3);

    _this = Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__["default"])(this, Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__["default"])(Vector3).call(this, -0, -0, -0));

    if (arguments.length === 1 && Object(_lib_common__WEBPACK_IMPORTED_MODULE_6__["isArray"])(x)) {
      _this.copy(x);
    } else {
      if (_lib_common__WEBPACK_IMPORTED_MODULE_6__["config"].debug) {
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(x);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(y);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(z);
      }

      _this[0] = x;
      _this[1] = y;
      _this[2] = z;
    }

    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Vector3, [{
    key: "set",
    value: function set(x, y, z) {
      this[0] = x;
      this[1] = y;
      this[2] = z;
      return this.check();
    }
  }, {
    key: "copy",
    value: function copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      return this.check();
    }
  }, {
    key: "fromObject",
    value: function fromObject(object) {
      if (_lib_common__WEBPACK_IMPORTED_MODULE_6__["config"].debug) {
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(object.x);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(object.y);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(object.z);
      }

      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      return this.check();
    }
  }, {
    key: "toObject",
    value: function toObject(object) {
      object.x = this[0];
      object.y = this[1];
      object.z = this[2];
      return object;
    }
  }, {
    key: "angle",
    value: function angle(vector) {
      return gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_8__["angle"](this, vector);
    }
  }, {
    key: "cross",
    value: function cross(vector) {
      gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_8__["cross"](this, this, vector);
      return this.check();
    }
  }, {
    key: "rotateX",
    value: function rotateX(_ref) {
      var radians = _ref.radians,
          _ref$origin = _ref.origin,
          origin = _ref$origin === void 0 ? ORIGIN : _ref$origin;
      gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_8__["rotateX"](this, this, origin, radians);
      return this.check();
    }
  }, {
    key: "rotateY",
    value: function rotateY(_ref2) {
      var radians = _ref2.radians,
          _ref2$origin = _ref2.origin,
          origin = _ref2$origin === void 0 ? ORIGIN : _ref2$origin;
      gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_8__["rotateY"](this, this, origin, radians);
      return this.check();
    }
  }, {
    key: "rotateZ",
    value: function rotateZ(_ref3) {
      var radians = _ref3.radians,
          _ref3$origin = _ref3.origin,
          origin = _ref3$origin === void 0 ? ORIGIN : _ref3$origin;
      gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_8__["rotateZ"](this, this, origin, radians);
      return this.check();
    }
  }, {
    key: "transform",
    value: function transform(matrix4) {
      return this.transformAsPoint(matrix4);
    }
  }, {
    key: "transformAsPoint",
    value: function transformAsPoint(matrix4) {
      gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_8__["transformMat4"](this, this, matrix4);
      return this.check();
    }
  }, {
    key: "transformAsVector",
    value: function transformAsVector(matrix4) {
      Object(_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_9__["vec3_transformMat4AsVector"])(this, this, matrix4);
      return this.check();
    }
  }, {
    key: "transformByMatrix3",
    value: function transformByMatrix3(matrix3) {
      gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_8__["transformMat3"](this, this, matrix3);
      return this.check();
    }
  }, {
    key: "transformByMatrix2",
    value: function transformByMatrix2(matrix2) {
      Object(_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_9__["vec3_transformMat2"])(this, this, matrix2);
      return this.check();
    }
  }, {
    key: "transformByQuaternion",
    value: function transformByQuaternion(quaternion) {
      gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_8__["transformQuat"](this, this, quaternion);
      return this.check();
    }
  }, {
    key: "ELEMENTS",
    get: function get() {
      return 3;
    }
  }, {
    key: "z",
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(value);
    }
  }]);

  return Vector3;
}(_base_vector__WEBPACK_IMPORTED_MODULE_5__["default"]);


//# sourceMappingURL=vector3.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/classes/vector4.js":
/*!*****************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/math.gl/dist/esm/classes/vector4.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Vector4; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "../../node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _base_vector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./base/vector */ "../../node_modules/math.gl/dist/esm/classes/base/vector.js");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib/common */ "../../node_modules/math.gl/dist/esm/lib/common.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../lib/validators */ "../../node_modules/math.gl/dist/esm/lib/validators.js");
/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! gl-matrix/vec3 */ "../../node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var _lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../lib/gl-matrix-extras */ "../../node_modules/math.gl/dist/esm/lib/gl-matrix-extras.js");











var Vector4 = function (_Vector) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__["default"])(Vector4, _Vector);

  function Vector4() {
    var _this;

    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Vector4);

    _this = Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__["default"])(this, Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__["default"])(Vector4).call(this, -0, -0, -0, -0));

    if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_6__["isArray"])(x) && arguments.length === 1) {
      _this.copy(x);
    } else {
      if (_lib_common__WEBPACK_IMPORTED_MODULE_6__["config"].debug) {
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(x);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(y);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(z);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(w);
      }

      _this[0] = x;
      _this[1] = y;
      _this[2] = z;
      _this[3] = w;
    }

    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Vector4, [{
    key: "set",
    value: function set(x, y, z, w) {
      this[0] = x;
      this[1] = y;
      this[2] = z;
      this[3] = w;
      return this.check();
    }
  }, {
    key: "copy",
    value: function copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      return this.check();
    }
  }, {
    key: "fromObject",
    value: function fromObject(object) {
      if (_lib_common__WEBPACK_IMPORTED_MODULE_6__["config"].debug) {
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(object.x);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(object.y);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(object.z);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(object.w);
      }

      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      this[3] = object.w;
      return this;
    }
  }, {
    key: "toObject",
    value: function toObject(object) {
      object.x = this[0];
      object.y = this[1];
      object.z = this[2];
      object.w = this[3];
      return object;
    }
  }, {
    key: "transform",
    value: function transform(matrix4) {
      gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_8__["transformMat4"](this, this, matrix4);
      return this.check();
    }
  }, {
    key: "transformByMatrix3",
    value: function transformByMatrix3(matrix3) {
      Object(_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_9__["vec4_transformMat3"])(this, this, matrix3);
      return this.check();
    }
  }, {
    key: "transformByMatrix2",
    value: function transformByMatrix2(matrix2) {
      Object(_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_9__["vec4_transformMat2"])(this, this, matrix2);
      return this.check();
    }
  }, {
    key: "transformByQuaternion",
    value: function transformByQuaternion(quaternion) {
      gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_8__["transformQuat"](this, this, quaternion);
      return this.check();
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(m) {
      m.transform(this, this);
      return this;
    }
  }, {
    key: "ELEMENTS",
    get: function get() {
      return 4;
    }
  }, {
    key: "z",
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(value);
    }
  }, {
    key: "w",
    get: function get() {
      return this[3];
    },
    set: function set(value) {
      return this[3] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(value);
    }
  }]);

  return Vector4;
}(_base_vector__WEBPACK_IMPORTED_MODULE_5__["default"]);


//# sourceMappingURL=vector4.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/index.js":
/*!*******************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/math.gl/dist/esm/index.js ***!
  \*******************************************************************************/
/*! exports provided: Vector2, Vector3, Vector4, Matrix3, Matrix4, Quaternion, config, configure, formatValue, isArray, clone, equals, exactEquals, toRadians, toDegrees, radians, degrees, sin, cos, tan, asin, acos, atan, clamp, lerp, _withEpsilon, checkNumber, _MathUtils, _SphericalCoordinates, _Pose, _Euler, _Polygon, assert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");
/* harmony import */ var _classes_vector2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classes/vector2 */ "../../node_modules/math.gl/dist/esm/classes/vector2.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Vector2", function() { return _classes_vector2__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _classes_vector3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./classes/vector3 */ "../../node_modules/math.gl/dist/esm/classes/vector3.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Vector3", function() { return _classes_vector3__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _classes_vector4__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./classes/vector4 */ "../../node_modules/math.gl/dist/esm/classes/vector4.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Vector4", function() { return _classes_vector4__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _classes_matrix3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./classes/matrix3 */ "../../node_modules/math.gl/dist/esm/classes/matrix3.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Matrix3", function() { return _classes_matrix3__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _classes_matrix4__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./classes/matrix4 */ "../../node_modules/math.gl/dist/esm/classes/matrix4.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Matrix4", function() { return _classes_matrix4__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _classes_quaternion__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./classes/quaternion */ "../../node_modules/math.gl/dist/esm/classes/quaternion.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Quaternion", function() { return _classes_quaternion__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/common */ "../../node_modules/math.gl/dist/esm/lib/common.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "config", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["config"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "configure", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["configure"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "formatValue", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["formatValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isArray", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["isArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["clone"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["equals"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["exactEquals"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toRadians", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["toRadians"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toDegrees", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["toDegrees"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "radians", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["radians"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "degrees", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["degrees"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["sin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["cos"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tan", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["tan"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "asin", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["asin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "acos", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["acos"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "atan", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["atan"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["clamp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["lerp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_withEpsilon", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["withEpsilon"]; });

/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/validators */ "../../node_modules/math.gl/dist/esm/lib/validators.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "checkNumber", function() { return _lib_validators__WEBPACK_IMPORTED_MODULE_8__["checkNumber"]; });

/* harmony import */ var _lib_math_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/math-utils */ "../../node_modules/math.gl/dist/esm/lib/math-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_MathUtils", function() { return _lib_math_utils__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _classes_spherical_coordinates__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./classes/spherical-coordinates */ "../../node_modules/math.gl/dist/esm/classes/spherical-coordinates.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_SphericalCoordinates", function() { return _classes_spherical_coordinates__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _classes_pose__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./classes/pose */ "../../node_modules/math.gl/dist/esm/classes/pose.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_Pose", function() { return _classes_pose__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _classes_euler__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./classes/euler */ "../../node_modules/math.gl/dist/esm/classes/euler.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_Euler", function() { return _classes_euler__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _addons_polygon__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./addons/polygon */ "../../node_modules/math.gl/dist/esm/addons/polygon.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_Polygon", function() { return _addons_polygon__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _lib_assert__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./lib/assert */ "../../node_modules/math.gl/dist/esm/lib/assert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return _lib_assert__WEBPACK_IMPORTED_MODULE_14__["default"]; });
















var globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global
};
var global_ = globals.global || globals.self || globals.window;
global_.mathgl = {
  config: math_gl__WEBPACK_IMPORTED_MODULE_0__["config"]
};
//# sourceMappingURL=index.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/lib/assert.js":
/*!************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/math.gl/dist/esm/lib/assert.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
function assert(condition, message) {
  if (!condition) {
    throw new Error("math.gl assertion ".concat(message));
  }
}
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/lib/common.js":
/*!************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/math.gl/dist/esm/lib/common.js ***!
  \************************************************************************************/
/*! exports provided: config, configure, formatValue, isArray, clone, toRadians, toDegrees, radians, degrees, sin, cos, tan, asin, acos, atan, clamp, lerp, equals, exactEquals, withEpsilon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "config", function() { return config; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "configure", function() { return configure; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatValue", function() { return formatValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArray", function() { return isArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toRadians", function() { return toRadians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toDegrees", function() { return toDegrees; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "radians", function() { return radians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degrees", function() { return degrees; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return sin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return cos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tan", function() { return tan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asin", function() { return asin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "acos", function() { return acos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan", function() { return atan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return clamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withEpsilon", function() { return withEpsilon; });
/* harmony import */ var _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/typeof */ "../../node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _babel_runtime_helpers_esm_construct__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/construct */ "../../node_modules/@babel/runtime/helpers/esm/construct.js");
/* harmony import */ var _babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/toConsumableArray */ "../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./assert */ "../../node_modules/math.gl/dist/esm/lib/assert.js");




var RADIANS_TO_DEGREES = 1 / Math.PI * 180;
var DEGREES_TO_RADIANS = 1 / 180 * Math.PI;
var config = {};
config.EPSILON = 1e-12;
config.debug = false;
config.precision = 4;
config.printTypes = false;
config.printDegrees = false;
config.printRowMajor = true;

function configure() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var key in options) {
    Object(_assert__WEBPACK_IMPORTED_MODULE_3__["default"])(key in config);
    config[key] = options[key];
  }

  return config;
}

function round(value) {
  return Math.round(value / config.EPSILON) * config.EPSILON;
}

function formatValue(value) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$precision = _ref.precision,
      precision = _ref$precision === void 0 ? config.precision || 4 : _ref$precision;

  value = round(value);
  return "".concat(parseFloat(value.toPrecision(precision)));
}
function isArray(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value) && value.length !== undefined;
}

function duplicateArray(array) {
  return array.clone ? array.clone() : new Array(array.length);
}

function clone(array) {
  return array.clone ? array.clone() : Object(_babel_runtime_helpers_esm_construct__WEBPACK_IMPORTED_MODULE_1__["default"])(Array, Object(_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_2__["default"])(array));
}

function map(value, func, result) {
  if (isArray(value)) {
    result = result || duplicateArray(value);

    for (var i = 0; i < result.length && i < value.length; ++i) {
      result[i] = func(value[i], i, result);
    }

    return result;
  }

  return func(value);
}

function toRadians(degrees) {
  return radians(degrees);
}
function toDegrees(radians) {
  return degrees(radians);
}
function radians(degrees, result) {
  return map(degrees, function (degrees) {
    return degrees * DEGREES_TO_RADIANS;
  }, result);
}
function degrees(radians, result) {
  return map(radians, function (radians) {
    return radians * RADIANS_TO_DEGREES;
  }, result);
}
function sin(radians) {
  return map(radians, function (angle) {
    return Math.sin(angle);
  });
}
function cos(radians) {
  return map(radians, function (angle) {
    return Math.cos(angle);
  });
}
function tan(radians) {
  return map(radians, function (angle) {
    return Math.tan(angle);
  });
}
function asin(radians) {
  return map(radians, function (angle) {
    return Math.asin(angle);
  });
}
function acos(radians) {
  return map(radians, function (angle) {
    return Math.acos(angle);
  });
}
function atan(radians) {
  return map(radians, function (angle) {
    return Math.atan(angle);
  });
}
function clamp(value, min, max) {
  return map(value, function (value) {
    return Math.max(min, Math.min(max, value));
  });
}
function lerp(a, b, t) {
  if (isArray(a)) {
    return a.map(function (ai, i) {
      return lerp(ai, b[i], t);
    });
  }

  return t * b + (1 - t) * a;
}
function equals(a, b, epsilon) {
  var oldEpsilon = config.EPSILON;

  if (epsilon) {
    config.EPSILON = epsilon;
  }

  try {
    if (a === b) {
      return true;
    }

    if (isArray(a) && isArray(b)) {
      if (a.length !== b.length) {
        return false;
      }

      for (var i = 0; i < a.length; ++i) {
        if (!equals(a[i], b[i])) {
          return false;
        }
      }

      return true;
    }

    if (a && Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(a) === 'object' && a.equals) {
      return a.equals(b);
    }

    if (b && Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(b) === 'object' && b.equals) {
      return b.equals(a);
    }

    return Math.abs(a - b) <= config.EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
  } finally {
    config.EPSILON = oldEpsilon;
  }
}
function exactEquals(a, b) {
  if (a === b) {
    return true;
  }

  if (a && Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(a) === 'object' && b && Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(b) === 'object') {
    if (a.constructor !== b.constructor) {
      return false;
    }

    if (a.exactEquals) {
      return a.exactEquals(b);
    }
  }

  if (isArray(a) && isArray(b)) {
    if (a.length !== b.length) {
      return false;
    }

    for (var i = 0; i < a.length; ++i) {
      if (!exactEquals(a[i], b[i])) {
        return false;
      }
    }

    return true;
  }

  return false;
}
function withEpsilon(EPSILON, func) {
  var oldPrecision = config.EPSILON;
  config.EPSILON = EPSILON;
  var value;

  try {
    value = func();
  } finally {
    config.EPSILON = oldPrecision;
  }

  return value;
}
//# sourceMappingURL=common.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/lib/gl-matrix-extras.js":
/*!**********************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/math.gl/dist/esm/lib/gl-matrix-extras.js ***!
  \**********************************************************************************************/
/*! exports provided: vec2_transformMat4AsVector, vec3_transformMat4AsVector, vec3_transformMat2, vec4_transformMat2, vec4_transformMat3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec2_transformMat4AsVector", function() { return vec2_transformMat4AsVector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec3_transformMat4AsVector", function() { return vec3_transformMat4AsVector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec3_transformMat2", function() { return vec3_transformMat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec4_transformMat2", function() { return vec4_transformMat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec4_transformMat3", function() { return vec4_transformMat3; });
function vec2_transformMat4AsVector(out, a, m) {
  var x = a[0];
  var y = a[1];
  var w = m[3] * x + m[7] * y || 1.0;
  out[0] = (m[0] * x + m[4] * y) / w;
  out[1] = (m[1] * x + m[5] * y) / w;
  return out;
}
function vec3_transformMat4AsVector(out, a, m) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;
  return out;
}
function vec3_transformMat2(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  out[2] = a[2];
  return out;
}
function vec4_transformMat2(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function vec4_transformMat3(out, a, m) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  out[0] = m[0] * x + m[3] * y + m[6] * z;
  out[1] = m[1] * x + m[4] * y + m[7] * z;
  out[2] = m[2] * x + m[5] * y + m[8] * z;
  out[3] = a[3];
  return out;
}
//# sourceMappingURL=gl-matrix-extras.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/lib/math-utils.js":
/*!****************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/math.gl/dist/esm/lib/math-utils.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({
  EPSILON1: 1e-1,
  EPSILON2: 1e-2,
  EPSILON3: 1e-3,
  EPSILON4: 1e-4,
  EPSILON5: 1e-5,
  EPSILON6: 1e-6,
  EPSILON7: 1e-7,
  EPSILON8: 1e-8,
  EPSILON9: 1e-9,
  EPSILON10: 1e-10,
  EPSILON11: 1e-11,
  EPSILON12: 1e-12,
  EPSILON13: 1e-13,
  EPSILON14: 1e-14,
  EPSILON15: 1e-15,
  EPSILON16: 1e-16,
  EPSILON17: 1e-17,
  EPSILON18: 1e-18,
  EPSILON19: 1e-19,
  EPSILON20: 1e-20,
  PI_OVER_TWO: Math.PI / 2,
  PI_OVER_FOUR: Math.PI / 4,
  PI_OVER_SIX: Math.PI / 6,
  TWO_PI: Math.PI * 2
});
//# sourceMappingURL=math-utils.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/lib/validators.js":
/*!****************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/math.gl/dist/esm/lib/validators.js ***!
  \****************************************************************************************/
/*! exports provided: validateVector, checkNumber, checkVector, deprecated */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateVector", function() { return validateVector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkNumber", function() { return checkNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkVector", function() { return checkVector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deprecated", function() { return deprecated; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "../../node_modules/math.gl/dist/esm/lib/common.js");

function validateVector(v, length) {
  if (v.length !== length) {
    return false;
  }

  for (var i = 0; i < v.length; ++i) {
    if (!Number.isFinite(v[i])) {
      return false;
    }
  }

  return true;
}
function checkNumber(value) {
  if (!Number.isFinite(value)) {
    throw new Error("Invalid number ".concat(value));
  }

  return value;
}
function checkVector(v, length, callerName) {
  if (_common__WEBPACK_IMPORTED_MODULE_0__["config"].debug && !validateVector(v, length)) {
    throw new Error("math.gl: ".concat(callerName | '', " some fields set to invalid numbers'"));
  }

  return v;
}
var map = {};
function deprecated(method, version) {
  if (!map[method]) {
    map[method] = true;
    console.warn("".concat(method, " has been removed in version ").concat(version, ", see upgrade guide for more information"));
  }
}
//# sourceMappingURL=validators.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/env/get-browser.js":
/*!******************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/probe.gl/dist/esm/env/get-browser.js ***!
  \******************************************************************************************/
/*! exports provided: isMobile, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isMobile", function() { return isMobile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getBrowser; });
/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals */ "../../node_modules/probe.gl/dist/esm/env/globals.js");
/* harmony import */ var _is_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is-browser */ "../../node_modules/probe.gl/dist/esm/env/is-browser.js");
/* harmony import */ var _is_electron__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./is-electron */ "../../node_modules/probe.gl/dist/esm/env/is-electron.js");



function isMobile() {
  return typeof _globals__WEBPACK_IMPORTED_MODULE_0__["window"].orientation !== 'undefined';
}
function getBrowser(mockUserAgent) {
  if (!mockUserAgent && !Object(_is_browser__WEBPACK_IMPORTED_MODULE_1__["default"])()) {
    return 'Node';
  }

  if (Object(_is_electron__WEBPACK_IMPORTED_MODULE_2__["default"])(mockUserAgent)) {
    return 'Electron';
  }

  var navigator_ = typeof navigator !== 'undefined' ? navigator : {};
  var userAgent = mockUserAgent || navigator_.userAgent || '';

  if (userAgent.indexOf('Edge') > -1) {
    return 'Edge';
  }

  var isMSIE = userAgent.indexOf('MSIE ') !== -1;
  var isTrident = userAgent.indexOf('Trident/') !== -1;

  if (isMSIE || isTrident) {
    return 'IE';
  }

  if (_globals__WEBPACK_IMPORTED_MODULE_0__["window"].chrome) {
    return 'Chrome';
  }

  if (_globals__WEBPACK_IMPORTED_MODULE_0__["window"].safari) {
    return 'Safari';
  }

  if (_globals__WEBPACK_IMPORTED_MODULE_0__["window"].mozInnerScreenX) {
    return 'Firefox';
  }

  return 'Unknown';
}
//# sourceMappingURL=get-browser.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/env/globals.js":
/*!**************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/probe.gl/dist/esm/env/globals.js ***!
  \**************************************************************************************/
/*! exports provided: self, window, global, document, process, console */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "self", function() { return self_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "window", function() { return window_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "global", function() { return global_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "document", function() { return document_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "process", function() { return process_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "console", function() { return console_; });
/* harmony import */ var _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/typeof */ "../../node_modules/@babel/runtime/helpers/esm/typeof.js");

var globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document,
  process: (typeof process === "undefined" ? "undefined" : Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(process)) === 'object' && process
};
var self_ = globals.self || globals.window || globals.global;
var window_ = globals.window || globals.self || globals.global;
var global_ = globals.global || globals.self || globals.window;
var document_ = globals.document || {};
var process_ = globals.process || {};
var console_ = console;

//# sourceMappingURL=globals.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../../process/browser.js */ "../../node_modules/process/browser.js")))

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/env/is-browser.js":
/*!*****************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/probe.gl/dist/esm/env/is-browser.js ***!
  \*****************************************************************************************/
/*! exports provided: default, isBrowserMainThread */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isBrowser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowserMainThread", function() { return isBrowserMainThread; });
/* harmony import */ var _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/typeof */ "../../node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _is_electron__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is-electron */ "../../node_modules/probe.gl/dist/esm/env/is-electron.js");


function isBrowser() {
  var isNode = (typeof process === "undefined" ? "undefined" : Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(process)) === 'object' && String(process) === '[object process]' && !process.browser;
  return !isNode || Object(_is_electron__WEBPACK_IMPORTED_MODULE_1__["default"])();
}
function isBrowserMainThread() {
  return isBrowser() && typeof document !== 'undefined';
}
//# sourceMappingURL=is-browser.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../process/browser.js */ "../../node_modules/process/browser.js")))

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/env/is-electron.js":
/*!******************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/probe.gl/dist/esm/env/is-electron.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isElectron; });
/* harmony import */ var _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/typeof */ "../../node_modules/@babel/runtime/helpers/esm/typeof.js");

function isElectron(mockUserAgent) {
  if (typeof window !== 'undefined' && Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(window.process) === 'object' && window.process.type === 'renderer') {
    return true;
  }

  if (typeof process !== 'undefined' && Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(process.versions) === 'object' && Boolean(process.versions.electron)) {
    return true;
  }

  var realUserAgent = (typeof navigator === "undefined" ? "undefined" : Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(navigator)) === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent;
  var userAgent = mockUserAgent || realUserAgent;

  if (userAgent && userAgent.indexOf('Electron') >= 0) {
    return true;
  }

  return false;
}
//# sourceMappingURL=is-electron.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../process/browser.js */ "../../node_modules/process/browser.js")))

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/index.js":
/*!********************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/probe.gl/dist/esm/index.js ***!
  \********************************************************************************/
/*! exports provided: VERSION, self, window, global, document, process, console, isBrowser, isBrowserMainThread, getBrowser, isMobile, isElectron, assert, Stats, Stat, Log, COLOR, default, addColor, leftPad, rightPad, autobind, LocalStorage, getHiResTimestamp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./init */ "../../node_modules/probe.gl/dist/esm/init.js");
/* harmony import */ var _lib_log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/log */ "../../node_modules/probe.gl/dist/esm/lib/log.js");
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/globals */ "../../node_modules/probe.gl/dist/esm/utils/globals.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_2__["VERSION"]; });

/* harmony import */ var _env_globals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./env/globals */ "../../node_modules/probe.gl/dist/esm/env/globals.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "self", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_3__["self"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_3__["window"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "global", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_3__["global"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "document", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_3__["document"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "process", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_3__["process"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "console", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_3__["console"]; });

/* harmony import */ var _env_is_browser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./env/is-browser */ "../../node_modules/probe.gl/dist/esm/env/is-browser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return _env_is_browser__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBrowserMainThread", function() { return _env_is_browser__WEBPACK_IMPORTED_MODULE_4__["isBrowserMainThread"]; });

/* harmony import */ var _env_get_browser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./env/get-browser */ "../../node_modules/probe.gl/dist/esm/env/get-browser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getBrowser", function() { return _env_get_browser__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isMobile", function() { return _env_get_browser__WEBPACK_IMPORTED_MODULE_5__["isMobile"]; });

/* harmony import */ var _env_is_electron__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./env/is-electron */ "../../node_modules/probe.gl/dist/esm/env/is-electron.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isElectron", function() { return _env_is_electron__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/assert */ "../../node_modules/probe.gl/dist/esm/utils/assert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return _utils_assert__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _lib_stats__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/stats */ "../../node_modules/probe.gl/dist/esm/lib/stats.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Stats", function() { return _lib_stats__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _lib_stat__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/stat */ "../../node_modules/probe.gl/dist/esm/lib/stat.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Stat", function() { return _lib_stat__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Log", function() { return _lib_log__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _utils_color__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/color */ "../../node_modules/probe.gl/dist/esm/utils/color.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "COLOR", function() { return _utils_color__WEBPACK_IMPORTED_MODULE_10__["COLOR"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addColor", function() { return _utils_color__WEBPACK_IMPORTED_MODULE_10__["addColor"]; });

/* harmony import */ var _utils_formatters__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/formatters */ "../../node_modules/probe.gl/dist/esm/utils/formatters.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "leftPad", function() { return _utils_formatters__WEBPACK_IMPORTED_MODULE_11__["leftPad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rightPad", function() { return _utils_formatters__WEBPACK_IMPORTED_MODULE_11__["rightPad"]; });

/* harmony import */ var _utils_autobind__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/autobind */ "../../node_modules/probe.gl/dist/esm/utils/autobind.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "autobind", function() { return _utils_autobind__WEBPACK_IMPORTED_MODULE_12__["autobind"]; });

/* harmony import */ var _utils_local_storage__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/local-storage */ "../../node_modules/probe.gl/dist/esm/utils/local-storage.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LocalStorage", function() { return _utils_local_storage__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./utils/hi-res-timestamp */ "../../node_modules/probe.gl/dist/esm/utils/hi-res-timestamp.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getHiResTimestamp", function() { return _utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_14__["default"]; });













/* harmony default export */ __webpack_exports__["default"] = (new _lib_log__WEBPACK_IMPORTED_MODULE_1__["default"]({
  id: 'probe.gl'
}));





//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/init.js":
/*!*******************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/probe.gl/dist/esm/init.js ***!
  \*******************************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/globals */ "../../node_modules/probe.gl/dist/esm/utils/globals.js");

_utils_globals__WEBPACK_IMPORTED_MODULE_0__["global"].probe = {};
//# sourceMappingURL=init.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/lib/log.js":
/*!**********************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/probe.gl/dist/esm/lib/log.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Log; });
/* harmony import */ var _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/typeof */ "../../node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/toConsumableArray */ "../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/globals */ "../../node_modules/probe.gl/dist/esm/utils/globals.js");
/* harmony import */ var _utils_local_storage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/local-storage */ "../../node_modules/probe.gl/dist/esm/utils/local-storage.js");
/* harmony import */ var _utils_formatters__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/formatters */ "../../node_modules/probe.gl/dist/esm/utils/formatters.js");
/* harmony import */ var _utils_color__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/color */ "../../node_modules/probe.gl/dist/esm/utils/color.js");
/* harmony import */ var _utils_autobind__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/autobind */ "../../node_modules/probe.gl/dist/esm/utils/autobind.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/assert */ "../../node_modules/probe.gl/dist/esm/utils/assert.js");
/* harmony import */ var _utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../utils/hi-res-timestamp */ "../../node_modules/probe.gl/dist/esm/utils/hi-res-timestamp.js");












var originalConsole = {
  debug: _utils_globals__WEBPACK_IMPORTED_MODULE_5__["isBrowser"] ? console.debug || console.log : console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
};
var DEFAULT_SETTINGS = {
  enabled: false,
  priority: 0
};

function noop() {}

var cache = {};

function getTableHeader(table) {
  for (var key in table) {
    for (var title in table[key]) {
      return title || 'untitled';
    }
  }

  return 'empty';
}

var Log = function () {
  function Log() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        id = _ref.id;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__["default"])(this, Log);

    this.id = id;
    this.VERSION = _utils_globals__WEBPACK_IMPORTED_MODULE_5__["VERSION"];
    this._startTs = Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_11__["default"])();
    this._deltaTs = Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_11__["default"])();
    this.LOG_THROTTLE_TIMEOUT = 0;
    this._storage = new _utils_local_storage__WEBPACK_IMPORTED_MODULE_6__["default"]("__probe-".concat(this.id, "__"), DEFAULT_SETTINGS);
    this.userData = {};
    this.timeStamp("".concat(this.id, " started"));
    Object(_utils_autobind__WEBPACK_IMPORTED_MODULE_9__["autobind"])(this);
    Object.seal(this);
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__["default"])(Log, [{
    key: "isEnabled",
    value: function isEnabled() {
      return this._storage.config.enabled;
    }
  }, {
    key: "getPriority",
    value: function getPriority() {
      return this._storage.config.priority;
    }
  }, {
    key: "getLevel",
    value: function getLevel() {
      return this._storage.config.priority;
    }
  }, {
    key: "getTotal",
    value: function getTotal() {
      return Number((Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_11__["default"])() - this._startTs).toPrecision(10));
    }
  }, {
    key: "getDelta",
    value: function getDelta() {
      return Number((Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_11__["default"])() - this._deltaTs).toPrecision(10));
    }
  }, {
    key: "enable",
    value: function enable() {
      var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this._storage.updateConfiguration({
        enabled: enabled
      });

      return this;
    }
  }, {
    key: "setLevel",
    value: function setLevel(level) {
      this._storage.updateConfiguration({
        priority: level
      });

      return this;
    }
  }, {
    key: "assert",
    value: function assert(condition, message) {
      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_10__["default"])(condition, message);
    }
  }, {
    key: "warn",
    value: function warn(message) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return this._getLogFunction({
        message: message,
        args: args,
        method: originalConsole.warn,
        once: true
      });
    }
  }, {
    key: "error",
    value: function error(message) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return this._getLogFunction({
        message: message,
        args: args,
        method: originalConsole.error
      });
    }
  }, {
    key: "deprecated",
    value: function deprecated(oldUsage, newUsage) {
      return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
    }
  }, {
    key: "removed",
    value: function removed(oldUsage, newUsage) {
      return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
    }
  }, {
    key: "probe",
    value: function probe(priority, message) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
        args[_key3 - 2] = arguments[_key3];
      }

      return this._getLogFunction({
        priority: priority,
        message: message,
        args: args,
        method: originalConsole.log,
        time: true,
        once: true
      });
    }
  }, {
    key: "log",
    value: function log(priority, message) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
        args[_key4 - 2] = arguments[_key4];
      }

      return this._getLogFunction({
        priority: priority,
        message: message,
        args: args,
        method: originalConsole.debug
      });
    }
  }, {
    key: "info",
    value: function info(priority, message) {
      for (var _len5 = arguments.length, args = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {
        args[_key5 - 2] = arguments[_key5];
      }

      return this._getLogFunction({
        priority: priority,
        message: message,
        args: args,
        method: console.info
      });
    }
  }, {
    key: "once",
    value: function once(priority, message) {
      for (var _len6 = arguments.length, args = new Array(_len6 > 2 ? _len6 - 2 : 0), _key6 = 2; _key6 < _len6; _key6++) {
        args[_key6 - 2] = arguments[_key6];
      }

      return this._getLogFunction({
        priority: priority,
        message: message,
        args: args,
        method: originalConsole.debug || originalConsole.info,
        once: true
      });
    }
  }, {
    key: "table",
    value: function table(priority, _table, columns) {
      if (_table) {
        var tag = getTableHeader(_table);
        return this._getLogFunction({
          priority: priority,
          message: _table,
          args: columns && [columns],
          tag: tag,
          method: console.table || noop
        });
      }

      return noop;
    }
  }, {
    key: "image",
    value: function image(_ref2) {
      var priority = _ref2.priority,
          _image = _ref2.image,
          _ref2$message = _ref2.message,
          message = _ref2$message === void 0 ? '' : _ref2$message,
          _ref2$scale = _ref2.scale,
          scale = _ref2$scale === void 0 ? 1 : _ref2$scale;

      if (priority > this.getPriority()) {
        return noop;
      }

      return _utils_globals__WEBPACK_IMPORTED_MODULE_5__["isBrowser"] ? this._logImageInBrowser({
        image: _image,
        message: message,
        scale: scale
      }) : this._logImageInNode({
        image: _image,
        message: message,
        scale: scale
      });
    }
  }, {
    key: "settings",
    value: function settings() {
      if (console.table) {
        console.table(this._storage.config);
      } else {
        console.log(this._storage.config);
      }
    }
  }, {
    key: "get",
    value: function get(setting) {
      return this._storage.config[setting];
    }
  }, {
    key: "set",
    value: function set(setting, value) {
      this._storage.updateConfiguration(Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__["default"])({}, setting, value));
    }
  }, {
    key: "_logImageInNode",
    value: function _logImageInNode(_ref3) {
      var image = _ref3.image,
          _ref3$message = _ref3.message,
          message = _ref3$message === void 0 ? '' : _ref3$message,
          _ref3$scale = _ref3.scale,
          scale = _ref3$scale === void 0 ? 1 : _ref3$scale;
      var asciify = null;

      try {
        asciify = __webpack_require__(/*! asciify-image */ 0);
      } catch (error) {}

      if (asciify) {
        return function () {
          return asciify(image, {
            fit: 'box',
            width: "".concat(Math.round(80 * scale), "%")
          }).then(function (data) {
            return console.log(data);
          });
        };
      }

      return noop;
    }
  }, {
    key: "_logImageInBrowser",
    value: function _logImageInBrowser(_ref4) {
      var image = _ref4.image,
          _ref4$message = _ref4.message,
          message = _ref4$message === void 0 ? '' : _ref4$message,
          _ref4$scale = _ref4.scale,
          scale = _ref4$scale === void 0 ? 1 : _ref4$scale;

      if (typeof image === 'string') {
        var img = new Image();

        img.onload = function () {
          var _console;

          var args = Object(_utils_formatters__WEBPACK_IMPORTED_MODULE_7__["formatImage"])(img, message, scale);

          (_console = console).log.apply(_console, Object(_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__["default"])(args));
        };

        img.src = image;
        return noop;
      }

      var element = image.nodeName || '';

      if (element.toLowerCase() === 'img') {
        var _console2;

        (_console2 = console).log.apply(_console2, Object(_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_utils_formatters__WEBPACK_IMPORTED_MODULE_7__["formatImage"])(image, message, scale)));

        return noop;
      }

      if (element.toLowerCase() === 'canvas') {
        var _img = new Image();

        _img.onload = function () {
          var _console3;

          return (_console3 = console).log.apply(_console3, Object(_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_utils_formatters__WEBPACK_IMPORTED_MODULE_7__["formatImage"])(_img, message, scale)));
        };

        _img.src = image.toDataURL();
        return noop;
      }

      return noop;
    }
  }, {
    key: "time",
    value: function time(priority, message) {
      return this._getLogFunction({
        priority: priority,
        message: message,
        method: console.time ? console.time : console.info
      });
    }
  }, {
    key: "timeEnd",
    value: function timeEnd(priority, message) {
      return this._getLogFunction({
        priority: priority,
        message: message,
        method: console.timeEnd ? console.timeEnd : console.info
      });
    }
  }, {
    key: "timeStamp",
    value: function timeStamp(priority, message) {
      return this._getLogFunction({
        priority: priority,
        message: message,
        method: console.timeStamp || noop
      });
    }
  }, {
    key: "group",
    value: function group(priority, message) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        collapsed: false
      };
      opts = this._normalizeArguments({
        priority: priority,
        message: message,
        opts: opts
      });
      var _opts = opts,
          collapsed = _opts.collapsed;
      return this._getLogFunction({
        priority: priority,
        message: message,
        opts: opts,
        method: (collapsed ? console.groupCollapsed : console.group) || console.info
      });
    }
  }, {
    key: "groupCollapsed",
    value: function groupCollapsed(priority, message) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this.group(priority, message, Object.assign({}, opts, {
        collapsed: true
      }));
    }
  }, {
    key: "groupEnd",
    value: function groupEnd(priority) {
      return this._getLogFunction({
        priority: priority,
        message: '',
        method: console.groupEnd || noop
      });
    }
  }, {
    key: "withGroup",
    value: function withGroup(priority, message, func) {
      var opts = this._normalizeArguments({
        priority: priority,
        message: message
      });

      this.group(opts);

      try {
        func();
      } finally {
        this.groupEnd(opts.message);
      }
    }
  }, {
    key: "trace",
    value: function trace() {
      if (console.trace) {
        console.trace();
      }
    }
  }, {
    key: "_shouldLog",
    value: function _shouldLog(priority) {
      priority = this._normalizePriority(priority);
      return priority === 0 || this.isEnabled() && this.getPriority() >= priority;
    }
  }, {
    key: "_getElapsedTime",
    value: function _getElapsedTime() {
      var total = this.getTotal();
      var delta = this.getDelta();
      this._deltaTs = Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_11__["default"])();
      return {
        total: total,
        delta: delta
      };
    }
  }, {
    key: "_getLogFunction",
    value: function _getLogFunction(opts) {
      if (this._shouldLog(opts.priority)) {
        var _opts2 = opts,
            method = _opts2.method;
        opts = this._parseArguments(opts);

        Object(_utils_assert__WEBPACK_IMPORTED_MODULE_10__["default"])(method);

        var _opts3 = opts,
            message = _opts3.message;
        var tag = opts.tag || opts.message;

        if (opts.once) {
          if (!cache[tag]) {
            cache[tag] = Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_11__["default"])();
          } else {
            return noop;
          }
        }

        message = this._decorateMessage(message, opts);
        return method.bind.apply(method, [console, message].concat(Object(_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__["default"])(opts.args)));
      }

      return noop;
    }
  }, {
    key: "_parseArguments",
    value: function _parseArguments(options) {
      var normOpts = this._normalizeArguments(options);

      var _this$_getElapsedTime = this._getElapsedTime(),
          delta = _this$_getElapsedTime.delta,
          total = _this$_getElapsedTime.total;

      return Object.assign(options, normOpts, {
        delta: delta,
        total: total
      });
    }
  }, {
    key: "_normalizePriority",
    value: function _normalizePriority(priority) {
      var resolvedPriority;

      switch (Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(priority)) {
        case 'number':
          resolvedPriority = priority;
          break;

        case 'object':
          resolvedPriority = priority.priority || 0;
          break;

        default:
          resolvedPriority = 0;
      }

      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_10__["default"])(Number.isFinite(resolvedPriority) && resolvedPriority >= 0);

      return resolvedPriority;
    }
  }, {
    key: "_normalizeArguments",
    value: function _normalizeArguments(_ref5) {
      var priority = _ref5.priority,
          message = _ref5.message,
          _ref5$args = _ref5.args,
          args = _ref5$args === void 0 ? [] : _ref5$args,
          opts = _ref5.opts;
      var newOpts = {
        priority: this._normalizePriority(priority),
        message: message,
        args: args
      };

      switch (Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(priority)) {
        case 'string':
        case 'function':
          if (message !== undefined) {
            args.unshift(message);
          }

          Object.assign(newOpts, {
            message: priority
          });
          break;

        case 'object':
          Object.assign(newOpts, priority);
          break;

        default:
      }

      if (typeof newOpts.message === 'function') {
        newOpts.message = this._shouldLog(newOpts.priority) ? newOpts.message() : '';
      }

      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_10__["default"])(typeof newOpts.message === 'string' || Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(newOpts.message) === 'object');

      return Object.assign(newOpts, opts);
    }
  }, {
    key: "_decorateMessage",
    value: function _decorateMessage(message, opts) {
      if (typeof message === 'string') {
        var time = '';

        if (opts.time) {
          var _this$_getElapsedTime2 = this._getElapsedTime(),
              total = _this$_getElapsedTime2.total;

          time = Object(_utils_formatters__WEBPACK_IMPORTED_MODULE_7__["leftPad"])(Object(_utils_formatters__WEBPACK_IMPORTED_MODULE_7__["formatTime"])(total));
        }

        message = opts.time ? "".concat(this.id, ": ").concat(time, "  ").concat(message) : "".concat(this.id, ": ").concat(message);
        message = Object(_utils_color__WEBPACK_IMPORTED_MODULE_8__["addColor"])(message, opts.color, opts.background);
      }

      return message;
    }
  }, {
    key: "priority",
    set: function set(newPriority) {
      this._storage.updateConfiguration({
        priority: newPriority
      });

      return this;
    },
    get: function get() {
      return this._storage.config.priority;
    }
  }]);

  return Log;
}();


Log.VERSION = _utils_globals__WEBPACK_IMPORTED_MODULE_5__["VERSION"];
//# sourceMappingURL=log.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/lib/stat.js":
/*!***********************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/probe.gl/dist/esm/lib/stat.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Stat; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/hi-res-timestamp */ "../../node_modules/probe.gl/dist/esm/utils/hi-res-timestamp.js");




var Stat = function () {
  function Stat(name, type) {
    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Stat);

    this.name = name;
    this.type = type;
    this.sampleSize = 1;
    this.reset();
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Stat, [{
    key: "setSampleSize",
    value: function setSampleSize(samples) {
      this.sampleSize = samples;
      return this;
    }
  }, {
    key: "incrementCount",
    value: function incrementCount() {
      this.addCount(1);
      return this;
    }
  }, {
    key: "decrementCount",
    value: function decrementCount() {
      this.subtractCount(1);
      return this;
    }
  }, {
    key: "addCount",
    value: function addCount(value) {
      this._count += value;
      this._samples++;

      this._checkSampling();

      return this;
    }
  }, {
    key: "subtractCount",
    value: function subtractCount(value) {
      this._count -= value;
      this._samples++;

      this._checkSampling();

      return this;
    }
  }, {
    key: "addTime",
    value: function addTime(time) {
      this._time += time;
      this._lastTiming = time;
      this._samples++;

      this._checkSampling();

      return this;
    }
  }, {
    key: "timeStart",
    value: function timeStart() {
      this._startTime = Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_2__["default"])();
      this._timerPending = true;
      return this;
    }
  }, {
    key: "timeEnd",
    value: function timeEnd() {
      if (!this._timerPending) {
        return this;
      }

      this.addTime(Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_2__["default"])() - this._startTime);
      this._timerPending = false;

      this._checkSampling();

      return this;
    }
  }, {
    key: "getSampleAverageCount",
    value: function getSampleAverageCount() {
      return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
    }
  }, {
    key: "getSampleAverageTime",
    value: function getSampleAverageTime() {
      return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
    }
  }, {
    key: "getSampleHz",
    value: function getSampleHz() {
      return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1000) : 0;
    }
  }, {
    key: "getAverageCount",
    value: function getAverageCount() {
      return this.samples > 0 ? this.count / this.samples : 0;
    }
  }, {
    key: "getAverageTime",
    value: function getAverageTime() {
      return this.samples > 0 ? this.time / this.samples : 0;
    }
  }, {
    key: "getHz",
    value: function getHz() {
      return this.time > 0 ? this.samples / (this.time / 1000) : 0;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.time = 0;
      this.count = 0;
      this.samples = 0;
      this.lastTiming = 0;
      this.lastSampleTime = 0;
      this.lastSampleCount = 0;
      this._count = 0;
      this._time = 0;
      this._samples = 0;
      this._startTime = 0;
      this._timerPending = false;
      return this;
    }
  }, {
    key: "_checkSampling",
    value: function _checkSampling() {
      if (this._samples === this.sampleSize) {
        this.lastSampleTime = this._time;
        this.lastSampleCount = this._count;
        this.count += this._count;
        this.time += this._time;
        this.samples += this._samples;
        this._time = 0;
        this._count = 0;
        this._samples = 0;
      }
    }
  }]);

  return Stat;
}();


//# sourceMappingURL=stat.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/lib/stats.js":
/*!************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/probe.gl/dist/esm/lib/stats.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Stats; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _stat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stat */ "../../node_modules/probe.gl/dist/esm/lib/stat.js");




var Stats = function () {
  function Stats(_ref) {
    var id = _ref.id,
        stats = _ref.stats;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Stats);

    this.id = id;
    this.stats = {};

    this._initializeStats(stats);

    Object.seal(this);
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Stats, [{
    key: "get",
    value: function get(name) {
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'count';
      return this._getOrCreate({
        name: name,
        type: type
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      for (var key in this.stats) {
        this.stats[key].reset();
      }

      return this;
    }
  }, {
    key: "forEach",
    value: function forEach(fn) {
      for (var key in this.stats) {
        fn(this.stats[key]);
      }
    }
  }, {
    key: "getTable",
    value: function getTable() {
      var table = {};
      this.forEach(function (stat) {
        table[stat.name] = {
          time: stat.time || 0,
          count: stat.count || 0,
          average: stat.getAverageTime() || 0,
          hz: stat.getHz() || 0
        };
      });
      return table;
    }
  }, {
    key: "_initializeStats",
    value: function _initializeStats() {
      var _this = this;

      var stats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      stats.forEach(function (stat) {
        return _this._getOrCreate(stat);
      });
    }
  }, {
    key: "_getOrCreate",
    value: function _getOrCreate(stat) {
      if (!stat || !stat.name) {
        return null;
      }

      var name = stat.name,
          type = stat.type;

      if (!this.stats[name]) {
        if (stat instanceof _stat__WEBPACK_IMPORTED_MODULE_2__["default"]) {
          this.stats[name] = stat;
        } else {
          this.stats[name] = new _stat__WEBPACK_IMPORTED_MODULE_2__["default"](name, type);
        }
      }

      return this.stats[name];
    }
  }, {
    key: "size",
    get: function get() {
      return Object.keys(this.stats).length;
    }
  }]);

  return Stats;
}();


//# sourceMappingURL=stats.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/utils/assert.js":
/*!***************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/probe.gl/dist/esm/utils/assert.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'Assertion failed');
  }
}
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/utils/autobind.js":
/*!*****************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/probe.gl/dist/esm/utils/autobind.js ***!
  \*****************************************************************************************/
/*! exports provided: autobind */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "autobind", function() { return autobind; });
function autobind(obj) {
  var predefined = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['constructor'];
  var proto = Object.getPrototypeOf(obj);
  var propNames = Object.getOwnPropertyNames(proto);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    var _loop = function _loop() {
      var key = _step.value;

      if (typeof obj[key] === 'function') {
        if (!predefined.find(function (name) {
          return key === name;
        })) {
          obj[key] = obj[key].bind(obj);
        }
      }
    };

    for (var _iterator = propNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      _loop();
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}
//# sourceMappingURL=autobind.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/utils/color.js":
/*!**************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/probe.gl/dist/esm/utils/color.js ***!
  \**************************************************************************************/
/*! exports provided: COLOR, addColor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLOR", function() { return COLOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addColor", function() { return addColor; });
/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals */ "../../node_modules/probe.gl/dist/esm/utils/globals.js");

var COLOR = {
  BLACK: 30,
  RED: 31,
  GREEN: 32,
  YELLOW: 33,
  BLUE: 34,
  MAGENTA: 35,
  CYAN: 36,
  WHITE: 37,
  BRIGHT_BLACK: 90,
  BRIGHT_RED: 91,
  BRIGHT_GREEN: 92,
  BRIGHT_YELLOW: 93,
  BRIGHT_BLUE: 94,
  BRIGHT_MAGENTA: 95,
  BRIGHT_CYAN: 96,
  BRIGHT_WHITE: 97
};

function getColor(color) {
  return typeof color === 'string' ? COLOR[color.toUpperCase()] || COLOR.WHITE : color;
}

function addColor(string, color, background) {
  if (!_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"] && typeof string === 'string') {
    if (color) {
      color = getColor(color);
      string = "\x1B[".concat(color, "m").concat(string, "\x1B[39m");
    }

    if (background) {
      color = getColor(background);
      string = "\x1B[".concat(background + 10, "m").concat(string, "\x1B[49m");
    }
  }

  return string;
}
//# sourceMappingURL=color.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/utils/formatters.js":
/*!*******************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/probe.gl/dist/esm/utils/formatters.js ***!
  \*******************************************************************************************/
/*! exports provided: formatTime, leftPad, rightPad, formatValue, formatImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatTime", function() { return formatTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "leftPad", function() { return leftPad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rightPad", function() { return rightPad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatValue", function() { return formatValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatImage", function() { return formatImage; });
function formatTime(ms) {
  var formatted;

  if (ms < 10) {
    formatted = "".concat(ms.toFixed(2), "ms");
  } else if (ms < 100) {
    formatted = "".concat(ms.toFixed(1), "ms");
  } else if (ms < 1000) {
    formatted = "".concat(ms.toFixed(0), "ms");
  } else {
    formatted = "".concat((ms / 1000).toFixed(2), "s");
  }

  return formatted;
}
function leftPad(string) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  var padLength = Math.max(length - string.length, 0);
  return "".concat(' '.repeat(padLength)).concat(string);
}
function rightPad(string) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  var padLength = Math.max(length - string.length, 0);
  return "".concat(string).concat(' '.repeat(padLength));
}
function formatValue(v) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var EPSILON = 1e-16;
  var _opts$isInteger = opts.isInteger,
      isInteger = _opts$isInteger === void 0 ? false : _opts$isInteger;

  if (Array.isArray(v) || ArrayBuffer.isView(v)) {
    return formatArrayValue(v, opts);
  }

  if (!Number.isFinite(v)) {
    return String(v);
  }

  if (Math.abs(v) < EPSILON) {
    return isInteger ? '0' : '0.';
  }

  if (isInteger) {
    return v.toFixed(0);
  }

  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {
    return v.toFixed(0);
  }

  var string = v.toPrecision(2);
  var decimal = string.indexOf('.0');
  return decimal === string.length - 2 ? string.slice(0, -1) : string;
}

function formatArrayValue(v, opts) {
  var _opts$maxElts = opts.maxElts,
      maxElts = _opts$maxElts === void 0 ? 16 : _opts$maxElts,
      _opts$size = opts.size,
      size = _opts$size === void 0 ? 1 : _opts$size;
  var string = '[';

  for (var i = 0; i < v.length && i < maxElts; ++i) {
    if (i > 0) {
      string += ",".concat(i % size === 0 ? ' ' : '');
    }

    string += formatValue(v[i], opts);
  }

  var terminator = v.length > maxElts ? '...' : ']';
  return "".concat(string).concat(terminator);
}

function formatImage(image, message, scale) {
  var maxWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 600;
  var imageUrl = image.src.replace(/\(/g, '%28').replace(/\)/g, '%29');

  if (image.width > maxWidth) {
    scale = Math.min(scale, maxWidth / image.width);
  }

  var width = image.width * scale;
  var height = image.height * scale;
  var style = ['font-size:1px;', "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"), "line-height:".concat(height, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width, "px ").concat(height, "px;"), 'color:transparent;'].join('');
  return ["".concat(message, " %c+"), style];
}
//# sourceMappingURL=formatters.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/utils/globals.js":
/*!****************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/probe.gl/dist/esm/utils/globals.js ***!
  \****************************************************************************************/
/*! exports provided: self, window, global, document, process, console, VERSION, isBrowser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return VERSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return isBrowser; });
/* harmony import */ var _env_is_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env/is-browser */ "../../node_modules/probe.gl/dist/esm/env/is-browser.js");
/* harmony import */ var _env_globals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../env/globals */ "../../node_modules/probe.gl/dist/esm/env/globals.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "self", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_1__["self"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_1__["window"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "global", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_1__["global"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "document", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_1__["document"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "process", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_1__["process"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "console", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_1__["console"]; });



var VERSION =  true ? "1.3.4" : undefined;
var isBrowser = Object(_env_is_browser__WEBPACK_IMPORTED_MODULE_0__["default"])();
//# sourceMappingURL=globals.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/utils/hi-res-timestamp.js":
/*!*************************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/probe.gl/dist/esm/utils/hi-res-timestamp.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getHiResTimestamp; });
/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals */ "../../node_modules/probe.gl/dist/esm/utils/globals.js");

function getHiResTimestamp() {
  var timestamp;

  if (_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"] && _globals__WEBPACK_IMPORTED_MODULE_0__["window"].performance) {
    timestamp = _globals__WEBPACK_IMPORTED_MODULE_0__["window"].performance.now();
  } else if (_globals__WEBPACK_IMPORTED_MODULE_0__["process"].hrtime) {
    var timeParts = _globals__WEBPACK_IMPORTED_MODULE_0__["process"].hrtime();
    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }

  return timestamp;
}
//# sourceMappingURL=hi-res-timestamp.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/utils/local-storage.js":
/*!**********************************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/probe.gl/dist/esm/utils/local-storage.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LocalStorage; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");



function getStorage(type) {
  try {
    var storage = window[type];
    var x = '__storage_test__';
    storage.setItem(x, x);
    storage.removeItem(x);
    return storage;
  } catch (e) {
    return null;
  }
}

var LocalStorage = function () {
  function LocalStorage(id, defaultSettings) {
    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'sessionStorage';

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, LocalStorage);

    this.storage = getStorage(type);
    this.id = id;
    this.config = {};
    Object.assign(this.config, defaultSettings);

    this._loadConfiguration();
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(LocalStorage, [{
    key: "getConfiguration",
    value: function getConfiguration() {
      return this.config;
    }
  }, {
    key: "setConfiguration",
    value: function setConfiguration(configuration) {
      this.config = {};
      return this.updateConfiguration(configuration);
    }
  }, {
    key: "updateConfiguration",
    value: function updateConfiguration(configuration) {
      Object.assign(this.config, configuration);

      if (this.storage) {
        var serialized = JSON.stringify(this.config);
        this.storage.setItem(this.id, serialized);
      }

      return this;
    }
  }, {
    key: "_loadConfiguration",
    value: function _loadConfiguration() {
      var configuration = {};

      if (this.storage) {
        var serializedConfiguration = this.storage.getItem(this.id);
        configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
      }

      Object.assign(this.config, configuration);
      return this;
    }
  }]);

  return LocalStorage;
}();


//# sourceMappingURL=local-storage.js.map

/***/ }),

/***/ "../../node_modules/process/browser.js":
/*!************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/process/browser.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "../../node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../core/src/index.js":
/*!****************************!*\
  !*** ../core/src/index.js ***!
  \****************************/
/*! exports provided: path, setPathPrefix, getPathPrefix, resolvePath, fetchFile, readFileSync, writeFile, writeFileSync, _getErrorMessageFromResponseSync, _getErrorMessageFromResponse, registerLoaders, parse, parseSync, parseInBatches, parseInBatchesSync, load, loadInBatches, encode, encodeSync, encodeInBatches, save, saveSync, isPromise, isIterable, isAsyncIterable, isIterator, isFetchResponse, isReadableStream, isWritableStream, toArrayBuffer, getStreamIterator, forEach, concatenateAsyncIterator, lineAsyncIterator, textDecoderAsyncIterator, numberedLineAsyncIterator, isBrowser, self, window, global, document, assert, _selectLoader, _WorkerThread, _WorkerFarm, _WorkerPool, _fetchProgress, _unregisterLoaders, TextEncoder, TextDecoder, createReadStream, parseFile, parseFileSync, loadFile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextEncoder", function() { return TextEncoder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextDecoder", function() { return TextDecoder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createReadStream", function() { return createReadStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseFile", function() { return parseFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseFileSync", function() { return parseFileSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadFile", function() { return loadFile; });
/* harmony import */ var _lib_parse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/parse */ "../core/src/lib/parse.js");
/* harmony import */ var _lib_parse_sync__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/parse-sync */ "../core/src/lib/parse-sync.js");
/* harmony import */ var _lib_fetch_fetch_file__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/fetch/fetch-file */ "../core/src/lib/fetch/fetch-file.js");
/* harmony import */ var _lib_load__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/load */ "../core/src/lib/load.js");
/* harmony import */ var _lib_fetch_file_aliases__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/fetch/file-aliases */ "../core/src/lib/fetch/file-aliases.js");
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/globals */ "../core/src/utils/globals.js");
/* harmony import */ var _lib_path_path__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/path/path */ "../core/src/lib/path/path.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "path", function() { return _lib_path_path__WEBPACK_IMPORTED_MODULE_6__; });
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setPathPrefix", function() { return _lib_fetch_file_aliases__WEBPACK_IMPORTED_MODULE_4__["setPathPrefix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getPathPrefix", function() { return _lib_fetch_file_aliases__WEBPACK_IMPORTED_MODULE_4__["getPathPrefix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resolvePath", function() { return _lib_fetch_file_aliases__WEBPACK_IMPORTED_MODULE_4__["resolvePath"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fetchFile", function() { return _lib_fetch_fetch_file__WEBPACK_IMPORTED_MODULE_2__["fetchFile"]; });

/* harmony import */ var _lib_fetch_read_file__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/fetch/read-file */ "../core/src/lib/fetch/read-file.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "readFileSync", function() { return _lib_fetch_read_file__WEBPACK_IMPORTED_MODULE_7__["readFileSync"]; });

/* harmony import */ var _lib_fetch_write_file__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/fetch/write-file */ "../core/src/lib/fetch/write-file.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "writeFile", function() { return _lib_fetch_write_file__WEBPACK_IMPORTED_MODULE_8__["writeFile"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "writeFileSync", function() { return _lib_fetch_write_file__WEBPACK_IMPORTED_MODULE_8__["writeFileSync"]; });

/* harmony import */ var _lib_fetch_fetch_error_message__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/fetch/fetch-error-message */ "../core/src/lib/fetch/fetch-error-message.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_getErrorMessageFromResponseSync", function() { return _lib_fetch_fetch_error_message__WEBPACK_IMPORTED_MODULE_9__["getErrorMessageFromResponseSync"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_getErrorMessageFromResponse", function() { return _lib_fetch_fetch_error_message__WEBPACK_IMPORTED_MODULE_9__["getErrorMessageFromResponse"]; });

/* harmony import */ var _lib_register_loaders__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/register-loaders */ "../core/src/lib/register-loaders.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "registerLoaders", function() { return _lib_register_loaders__WEBPACK_IMPORTED_MODULE_10__["registerLoaders"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return _lib_parse__WEBPACK_IMPORTED_MODULE_0__["parse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseSync", function() { return _lib_parse_sync__WEBPACK_IMPORTED_MODULE_1__["parseSync"]; });

/* harmony import */ var _lib_parse_in_batches__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/parse-in-batches */ "../core/src/lib/parse-in-batches.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseInBatches", function() { return _lib_parse_in_batches__WEBPACK_IMPORTED_MODULE_11__["parseInBatches"]; });

/* harmony import */ var _lib_parse_in_batches_sync__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./lib/parse-in-batches-sync */ "../core/src/lib/parse-in-batches-sync.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseInBatchesSync", function() { return _lib_parse_in_batches_sync__WEBPACK_IMPORTED_MODULE_12__["parseInBatchesSync"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "load", function() { return _lib_load__WEBPACK_IMPORTED_MODULE_3__["load"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadInBatches", function() { return _lib_load__WEBPACK_IMPORTED_MODULE_3__["loadInBatches"]; });

/* harmony import */ var _lib_encode__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./lib/encode */ "../core/src/lib/encode.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "encode", function() { return _lib_encode__WEBPACK_IMPORTED_MODULE_13__["encode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "encodeSync", function() { return _lib_encode__WEBPACK_IMPORTED_MODULE_13__["encodeSync"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "encodeInBatches", function() { return _lib_encode__WEBPACK_IMPORTED_MODULE_13__["encodeInBatches"]; });

/* harmony import */ var _lib_save__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./lib/save */ "../core/src/lib/save.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "save", function() { return _lib_save__WEBPACK_IMPORTED_MODULE_14__["save"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "saveSync", function() { return _lib_save__WEBPACK_IMPORTED_MODULE_14__["saveSync"]; });

/* harmony import */ var _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./javascript-utils/is-type */ "../core/src/javascript-utils/is-type.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isPromise", function() { return _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_15__["isPromise"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isIterable", function() { return _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_15__["isIterable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isAsyncIterable", function() { return _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_15__["isAsyncIterable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isIterator", function() { return _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_15__["isIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isFetchResponse", function() { return _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_15__["isFetchResponse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isReadableStream", function() { return _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_15__["isReadableStream"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWritableStream", function() { return _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_15__["isWritableStream"]; });

/* harmony import */ var _javascript_utils_binary_utils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./javascript-utils/binary-utils */ "../core/src/javascript-utils/binary-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toArrayBuffer", function() { return _javascript_utils_binary_utils__WEBPACK_IMPORTED_MODULE_16__["toArrayBuffer"]; });

/* harmony import */ var _javascript_utils_stream_utils__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./javascript-utils/stream-utils */ "../core/src/javascript-utils/stream-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getStreamIterator", function() { return _javascript_utils_stream_utils__WEBPACK_IMPORTED_MODULE_17__["getStreamIterator"]; });

/* harmony import */ var _javascript_utils_async_iterator_utils__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./javascript-utils/async-iterator-utils */ "../core/src/javascript-utils/async-iterator-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return _javascript_utils_async_iterator_utils__WEBPACK_IMPORTED_MODULE_18__["forEach"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concatenateAsyncIterator", function() { return _javascript_utils_async_iterator_utils__WEBPACK_IMPORTED_MODULE_18__["concatenateAsyncIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lineAsyncIterator", function() { return _javascript_utils_async_iterator_utils__WEBPACK_IMPORTED_MODULE_18__["lineAsyncIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "textDecoderAsyncIterator", function() { return _javascript_utils_async_iterator_utils__WEBPACK_IMPORTED_MODULE_18__["textDecoderAsyncIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "numberedLineAsyncIterator", function() { return _javascript_utils_async_iterator_utils__WEBPACK_IMPORTED_MODULE_18__["numberedLineAsyncIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_5__["isBrowser"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "self", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_5__["self"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_5__["window"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "global", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_5__["global"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "document", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_5__["document"]; });

/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./utils/assert */ "../core/src/utils/assert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return _utils_assert__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _lib_select_loader__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./lib/select-loader */ "../core/src/lib/select-loader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_selectLoader", function() { return _lib_select_loader__WEBPACK_IMPORTED_MODULE_20__["selectLoader"]; });

/* harmony import */ var _worker_utils_worker_thread__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./worker-utils/worker-thread */ "../core/src/worker-utils/worker-thread.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_WorkerThread", function() { return _worker_utils_worker_thread__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony import */ var _worker_utils_worker_farm__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./worker-utils/worker-farm */ "../core/src/worker-utils/worker-farm.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_WorkerFarm", function() { return _worker_utils_worker_farm__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony import */ var _worker_utils_worker_pool__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./worker-utils/worker-pool */ "../core/src/worker-utils/worker-pool.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_WorkerPool", function() { return _worker_utils_worker_pool__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony import */ var _lib_progress_fetch_progress__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./lib/progress/fetch-progress */ "../core/src/lib/progress/fetch-progress.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_fetchProgress", function() { return _lib_progress_fetch_progress__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_unregisterLoaders", function() { return _lib_register_loaders__WEBPACK_IMPORTED_MODULE_10__["_unregisterLoaders"]; });









// PATH



// FILE READING AND WRITING






// FILE PARSING AND ENCODING


// LOADING (READING + PARSING)






// ENCODING AND SAVING



// "JAVASCRIPT" UTILS




// ITERATOR UTILS




// CORE UTILS



// EXPERIMENTAL








// FOR TESTING


// DEPRECATED

// Use @loaders.gl/polyfills and global symbols instead
const TextEncoder = _utils_globals__WEBPACK_IMPORTED_MODULE_5__["global"].TextEncoder;
const TextDecoder = _utils_globals__WEBPACK_IMPORTED_MODULE_5__["global"].TextDecoder;

// Returns a promise that resolves to a readable stream
async function createReadStream(url, options) {
  // eslint-disable-next-line
  console.warn('createReadStream() deprecated, use fetch().then(resp => resp.body)');
  url = Object(_lib_fetch_file_aliases__WEBPACK_IMPORTED_MODULE_4__["resolvePath"])(url);
  const response = await Object(_lib_fetch_fetch_file__WEBPACK_IMPORTED_MODULE_2__["fetchFile"])(url, options);
  return response.body;
}

function parseFile(...args) {
  console.warn('parse() deprecated, use parse()'); // eslint-disable-line
  return Object(_lib_parse__WEBPACK_IMPORTED_MODULE_0__["parse"])(...args);
}

function parseFileSync(...args) {
  console.warn('parseSync() deprecated, use parseSync()'); // eslint-disable-line
  return Object(_lib_parse_sync__WEBPACK_IMPORTED_MODULE_1__["parseSync"])(...args);
}

function loadFile(...args) {
  console.warn('loadFile() deprecated, use load()'); // eslint-disable-line
  return Object(_lib_load__WEBPACK_IMPORTED_MODULE_3__["load"])(...args);
}


/***/ }),

/***/ "../core/src/javascript-utils/async-iterator-utils.js":
/*!************************************************************!*\
  !*** ../core/src/javascript-utils/async-iterator-utils.js ***!
  \************************************************************/
/*! exports provided: forEach, concatenateAsyncIterator, textDecoderAsyncIterator, textEncoderAsyncIterator, lineAsyncIterator, numberedLineAsyncIterator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concatenateAsyncIterator", function() { return concatenateAsyncIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "textDecoderAsyncIterator", function() { return textDecoderAsyncIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "textEncoderAsyncIterator", function() { return textEncoderAsyncIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineAsyncIterator", function() { return lineAsyncIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numberedLineAsyncIterator", function() { return numberedLineAsyncIterator; });
/* harmony import */ var _javascript_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../javascript-utils/memory-copy-utils */ "../core/src/javascript-utils/memory-copy-utils.js");
/* global TextDecoder, TextEncoder */


// GENERAL UTILITIES

// Iterate over async iterator, without resetting iterator if end is not reached
// - forEach does not reset iterator if exiting loop prematurely
//   so that iteration can continue in a second loop
// - It is recommended to use a standard for await as last loop to ensure
//   iterator gets properly reset
// TODO - optimize using sync iteration if argument is an Iterable?
async function forEach(iterator, visitor) {
  // eslint-disable-next-line
  while (true) {
    const {done, value} = await iterator.next();
    if (done) {
      iterator.return();
      return;
    }
    const cancel = visitor(value);
    if (cancel) {
      return;
    }
  }
}

// Concatenates all data chunks yielded by an async iterator
async function concatenateAsyncIterator(asyncIterator) {
  let arrayBuffer = new ArrayBuffer();
  let string = '';
  for await (const chunk of asyncIterator) {
    if (typeof chunk === 'string') {
      string += chunk;
    } else {
      arrayBuffer = Object(_javascript_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_0__["concatenateArrayBuffers"])(arrayBuffer, chunk);
    }
  }
  return string || arrayBuffer;
}

// ITERATOR GENERATORS

// TextDecoder iterators
// TextDecoder will keep any partial undecoded bytes between calls to `decode`

async function* textDecoderAsyncIterator(arrayBufferIterator, options) {
  const textDecoder = new TextDecoder(options);
  for await (const arrayBuffer of arrayBufferIterator) {
    yield typeof arrayBuffer === 'string'
      ? arrayBuffer
      : textDecoder.decode(arrayBuffer, {stream: true});
  }
}

// TextEncoder iterator
// TODO - this is not useful unless min chunk size is given
// TextEncoder will keep any partial undecoded bytes between calls to `encode`
// If iterator does not yield strings, assume arrayBuffer and return unencoded

async function* textEncoderAsyncIterator(textIterator, options) {
  const textEncoder = new TextEncoder();
  for await (const text of textIterator) {
    yield typeof text === 'string' ? textEncoder.encode(text) : text;
  }
}

// Input: async iterable over strings
// Returns: an async iterable over lines
// See http://2ality.com/2018/04/async-iter-nodejs.html

async function* lineAsyncIterator(textIterator) {
  let previous = '';
  for await (const textChunk of textIterator) {
    previous += textChunk;
    let eolIndex;
    while ((eolIndex = previous.indexOf('\n')) >= 0) {
      // line includes the EOL
      const line = previous.slice(0, eolIndex + 1);
      previous = previous.slice(eolIndex + 1);
      yield line;
    }
  }

  if (previous.length > 0) {
    yield previous;
  }
}

/**
 * Parameter: async iterable of lines
 * Result: async iterable of numbered lines
 */
// See http://2ality.com/2018/04/async-iter-nodejs.html
// eslint-disable-next-line no-shadow
async function* numberedLineAsyncIterator(lineIterator) {
  let counter = 1;
  for await (const line of lineIterator) {
    yield {counter, line};
    counter++;
  }
}


/***/ }),

/***/ "../core/src/javascript-utils/binary-utils.js":
/*!****************************************************!*\
  !*** ../core/src/javascript-utils/binary-utils.js ***!
  \****************************************************/
/*! exports provided: toArrayBuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toArrayBuffer", function() { return toArrayBuffer; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "../core/src/utils/assert.js");
/* harmony import */ var _node_utils_to_array_buffer_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node/utils/to-array-buffer.node */ 1);
/* harmony import */ var _node_utils_to_array_buffer_node__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_utils_to_array_buffer_node__WEBPACK_IMPORTED_MODULE_1__);
/* global ArrayBuffer, TextEncoder */



function toArrayBuffer(data) {
  if (_node_utils_to_array_buffer_node__WEBPACK_IMPORTED_MODULE_1__["toArrayBuffer"]) {
    // TODO - per docs we should just be able to call buffer.buffer, but there are issues
    data = Object(_node_utils_to_array_buffer_node__WEBPACK_IMPORTED_MODULE_1__["toArrayBuffer"])(data);
  }

  if (data instanceof ArrayBuffer) {
    return data;
  }

  // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)
  if (ArrayBuffer.isView(data)) {
    return data.buffer;
  }

  if (typeof data === 'string') {
    const text = data;
    const uint8Array = new TextEncoder().encode(text);
    return uint8Array.buffer;
  }

  return Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(false);
}

// export function blobToArrayBuffer(blob) {
//   return new Promise((resolve, reject) => {
//     let arrayBuffer;
//     const fileReader = new FileReader();
//     fileReader.onload = event => {
//       arrayBuffer = event.target.result;
//     };
//     fileReader.onloadend = event => resolve(arrayBuffer);
//     fileReader.onerror = reject;
//     fileReader.readAsArrayBuffer(blob);
//   });
// }


/***/ }),

/***/ "../core/src/javascript-utils/is-type.js":
/*!***********************************************!*\
  !*** ../core/src/javascript-utils/is-type.js ***!
  \***********************************************/
/*! exports provided: isPromise, isIterable, isAsyncIterable, isIterator, isFetchResponse, isFile, isBlob, isFileReadable, isWritableDOMStream, isReadableDOMStream, isWritableNodeStream, isReadableNodeStream, isReadableStream, isWritableStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPromise", function() { return isPromise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIterable", function() { return isIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAsyncIterable", function() { return isAsyncIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIterator", function() { return isIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFetchResponse", function() { return isFetchResponse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFile", function() { return isFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBlob", function() { return isBlob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFileReadable", function() { return isFileReadable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWritableDOMStream", function() { return isWritableDOMStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isReadableDOMStream", function() { return isReadableDOMStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWritableNodeStream", function() { return isWritableNodeStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isReadableNodeStream", function() { return isReadableNodeStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isReadableStream", function() { return isReadableStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWritableStream", function() { return isWritableStream; });
/* global File, Blob, Response */

const isBoolean = x => typeof x === 'boolean';
const isFunction = x => typeof x === 'function';
const isObject = x => x !== null && typeof x === 'object';

const isPromise = x => isObject(x) && isFunction(x.then);

const isIterable = x => x && typeof x[Symbol.iterator] === 'function';

const isAsyncIterable = x => x && typeof x[Symbol.asyncIterator] === 'function';

const isIterator = x => x && isFunction(x.next);

const isFetchResponse = x =>
  (typeof Response !== 'undefined' && x instanceof Response) || (x.arrayBuffer && x.text && x.json);

const isFile = x => typeof File !== 'undefined' && x instanceof File;
const isBlob = x => typeof Blob !== 'undefined' && x instanceof Blob;
const isFileReadable = x => isFile(x) || isBlob(x); // Blob & File are FileReader compatible

const isWritableDOMStream = x => {
  return isObject(x) && isFunction(x.abort) && isFunction(x.getWriter);
};

const isReadableDOMStream = x => {
  return (
    isObject(x) &&
    isFunction(x.tee) &&
    isFunction(x.cancel) &&
    isFunction(x.pipeTo) &&
    isFunction(x.getReader)
  );
};

const isWritableNodeStream = x => {
  return isObject(x) && isFunction(x.end) && isFunction(x.write) && isBoolean(x.writable);
};

const isReadableNodeStream = x => {
  return isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);
};

const isReadableStream = x => isReadableDOMStream(x) || isReadableNodeStream(x);

const isWritableStream = x => isWritableDOMStream(x) || isWritableNodeStream(x);


/***/ }),

/***/ "../core/src/javascript-utils/memory-copy-utils.js":
/*!*********************************************************!*\
  !*** ../core/src/javascript-utils/memory-copy-utils.js ***!
  \*********************************************************/
/*! exports provided: concatenateArrayBuffers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concatenateArrayBuffers", function() { return concatenateArrayBuffers; });
function concatenateArrayBuffers(source1, source2) {
  const sourceArray1 = source1 instanceof ArrayBuffer ? new Uint8Array(source1) : source1;
  const sourceArray2 = source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2;
  const temp = new Uint8Array(sourceArray1.byteLength + sourceArray2.byteLength);
  temp.set(sourceArray1, 0);
  temp.set(sourceArray2, sourceArray1.byteLength);
  return temp;
}


/***/ }),

/***/ "../core/src/javascript-utils/stream-utils.js":
/*!****************************************************!*\
  !*** ../core/src/javascript-utils/stream-utils.js ***!
  \****************************************************/
/*! exports provided: getStreamIterator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStreamIterator", function() { return getStreamIterator; });
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/globals */ "../core/src/utils/globals.js");


function getStreamIterator(stream) {
  // Hacky test for node version to ensure we don't call bad polyfills
  if (_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"] || _utils_globals__WEBPACK_IMPORTED_MODULE_0__["nodeVersion"] >= 10) {
    // NODE 10+: stream is an asyncIterator
    if (typeof stream[Symbol.asyncIterator] === 'function') {
      return stream;
    }

    // WhatWG: stream is supposed to have a `getIterator` method
    if (typeof stream.getIterator === 'function') {
      return stream.getIterator();
    }
  }

  return _utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"] ? makeBrowserStreamIterator(stream) : makeNodeStreamIterator(stream);
}

// BROWSER IMPLEMENTATION
// See https://jakearchibald.com/2017/async-iterators-and-generators/#making-streams-iterate

async function* makeBrowserStreamIterator(stream) {
  // In the brower, we first need to get a lock on the stream
  const reader = stream.getReader();

  try {
    // eslint-disable-next-line no-constant-condition
    while (true) {
      // Read from the stream
      const {done, value} = await reader.read();
      // Exit if we're done
      if (done) {
        return;
      }
      // Else yield the chunk
      yield value;
    }
  } catch (error) {
    // TODO - examples makes it look like this should always be called,
    // but that generates exceptions so only call it if we do not reach the end
    reader.releaseLock();
  }
}

// NODE <10 IMPLEMENTATION
// See https://github.com/bustle/streaming-iterables, MIT license

async function* makeNodeStreamIterator(stream) {
  // Node createStream will return promises to handle http requests
  stream = await stream;

  // eslint-disable-next-line no-constant-condition
  while (true) {
    const data = stream.read();
    if (data !== null) {
      yield data;
      // eslint-disable-next-line no-continue
      continue;
    }
    if (stream._readableState.ended) {
      return;
    }
    await onceReadable(stream);
  }
}

async function onceReadable(stream) {
  return new Promise(resolve => {
    stream.once('readable', resolve);
  });
}

// TODO - we could add our own polyfill
// const {Readable} = require('stream');
// if (typeof Readable !== 'undefined' && !Readable.prototype[Symbol.asyncIterator]) {
//   Readable.prototype[Symbol.asyncIterator] = function () {
//     return makeNodeStreamIterator(this);
//   }
// }


/***/ }),

/***/ "../core/src/lib/encode.js":
/*!*********************************!*\
  !*** ../core/src/lib/encode.js ***!
  \*********************************/
/*! exports provided: encode, encodeSync, encodeInBatches */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encode", function() { return encode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeSync", function() { return encodeSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeInBatches", function() { return encodeInBatches; });
function encode(data, writer, options, url) {
  if (writer.encode) {
    return writer.encode(data, options);
  }
  if (writer.encodeSync) {
    return Promise.resolve(writer.encodeSync(data, options));
  }
  // TODO - Use encodeToBatches?
  throw new Error('Writer could not encode data');
}

function encodeSync(data, writer, options, url) {
  if (writer.encodeSync) {
    return writer.encodeSync(data, options);
  }
  throw new Error('Writer could not synchronously encode data');
}

function encodeInBatches(data, writer, options, url) {
  if (writer.encodeInBatches) {
    return writer.encodeInBatches(data, options);
  }
  // TODO -fall back to atomic encode?
  throw new Error('Writer could not encode data in batches');
}


/***/ }),

/***/ "../core/src/lib/fetch/fetch-error-message.js":
/*!****************************************************!*\
  !*** ../core/src/lib/fetch/fetch-error-message.js ***!
  \****************************************************/
/*! exports provided: getErrorMessageFromResponseSync, getErrorMessageFromResponse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getErrorMessageFromResponseSync", function() { return getErrorMessageFromResponseSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getErrorMessageFromResponse", function() { return getErrorMessageFromResponse; });
function getErrorMessageFromResponseSync(response) {
  return `Failed to fetch resource ${response.url}(${response.status}): ${response.statusText} `;
}

async function getErrorMessageFromResponse(response) {
  let message = `Failed to fetch resource ${response.url} (${response.status}): `;
  try {
    const contentType = response.headers.get('Content-Type');
    if (contentType.includes('application/json')) {
      message += await response.text();
    } else {
      message += response.statusText;
    }
  } catch (error) {
    // eslint forbids return in finally statement
    return message;
  }
  return message;
}


/***/ }),

/***/ "../core/src/lib/fetch/fetch-file.browser.js":
/*!***************************************************!*\
  !*** ../core/src/lib/fetch/fetch-file.browser.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return fetchFileReadable; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/assert */ "../core/src/utils/assert.js");
/* global FileReader, Headers */


// File reader fetch "polyfill" for the browser
class FileReadableResponse {
  constructor(fileOrBlob) {
    this._fileOrBlob = fileOrBlob;
    this.bodyUsed = false;
  }

  get headers() {
    return new Headers({
      'Content-Length': this._fileOrBlob.size,
      'Content-Type': this._fileOrBlob.type
    });
  }

  get ok() {
    return true; // Blob & File objects are already in memory
  }

  get status() {
    return 200; // Blob & File objects are already in memory
  }

  url() {
    // Note: This is just the file name without path information
    // Note: File has `name` field but the Blob baseclass does not
    return this._fileOrBlob.name || '';
  }

  async arrayBuffer() {
    const {reader, promise} = this._getFileReader();
    reader.readAsArrayBuffer(this._fileOrBlob);
    return promise;
  }

  async text() {
    const {reader, promise} = this._getFileReader();
    reader.readAsText(this._fileOrBlob);
    return promise;
  }

  async json() {
    const text = await this.text();
    return JSON.parse(text);
  }

  // TODO - body, how to support stream?
  // Can this be portable?
  // eslint-disable-next-line
  // https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams#Creating_your_own_custom_readable_stream
  // get body() {
  //   assert(false);
  // }

  // PRIVATE

  _getFileReader() {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(!this.bodyUsed);
    this.bodyUsed = true;

    let reader;
    const promise = new Promise((resolve, reject) => {
      try {
        reader = new FileReader();
        reader.onerror = error => reject(new Error(error));
        reader.onabort = () => reject(new Error('Read aborted.'));
        reader.onload = () => resolve(reader.result);
      } catch (error) {
        reject(error);
      }
    });
    return {reader, promise};
  }
}

// @param {File|Blob} file  HTML File or Blob object to read as string
// @returns {Promise.string}  Resolves to a string containing file contents
function fetchFileReadable(fileOrBlob, options) {
  return Promise.resolve(new FileReadableResponse(fileOrBlob, options));
}


/***/ }),

/***/ "../core/src/lib/fetch/fetch-file.js":
/*!*******************************************!*\
  !*** ../core/src/lib/fetch/fetch-file.js ***!
  \*******************************************/
/*! exports provided: fetchFile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchFile", function() { return fetchFile; });
/* harmony import */ var _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../javascript-utils/is-type */ "../core/src/javascript-utils/is-type.js");
/* harmony import */ var _file_aliases__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./file-aliases */ "../core/src/lib/fetch/file-aliases.js");
/* harmony import */ var _fetch_file_browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fetch-file.browser */ "../core/src/lib/fetch/fetch-file.browser.js");
/* global fetch */




// As fetch but respects pathPrefix and file aliases
// Reads file data from:
// * data urls
// * http/http urls
// * File/Blob objects
async function fetchFile(url, options) {
  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isFileReadable"])(url)) {
    return Object(_fetch_file_browser__WEBPACK_IMPORTED_MODULE_2__["default"])(url, options);
  }
  url = Object(_file_aliases__WEBPACK_IMPORTED_MODULE_1__["resolvePath"])(url);
  // TODO - SUPPORT reading from `File` objects
  return fetch(url, options);
}


/***/ }),

/***/ "../core/src/lib/fetch/file-aliases.js":
/*!*********************************************!*\
  !*** ../core/src/lib/fetch/file-aliases.js ***!
  \*********************************************/
/*! exports provided: setPathPrefix, getPathPrefix, addAliases, resolvePath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setPathPrefix", function() { return setPathPrefix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPathPrefix", function() { return getPathPrefix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addAliases", function() { return addAliases; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolvePath", function() { return resolvePath; });
// Simple file alias mechanisms for tests.

let pathPrefix = '';
const fileAliases = {};

/*
 * Set a relative path prefix
 */
function setPathPrefix(prefix) {
  pathPrefix = prefix;
}

function getPathPrefix() {
  return pathPrefix;
}

// Note: addAliases are not exported at the moment, they are only for loaders.gl testing
function addAliases(aliases) {
  Object.assign(fileAliases, aliases);
}

function resolvePath(filename) {
  for (const alias in fileAliases) {
    if (filename.startsWith(alias)) {
      const replacement = fileAliases[alias];
      return filename.replace(alias, replacement);
    }
  }
  filename += pathPrefix;
  return filename;
}


/***/ }),

/***/ "../core/src/lib/fetch/read-file.browser.js":
/*!**************************************************!*\
  !*** ../core/src/lib/fetch/read-file.browser.js ***!
  \**************************************************/
/*! exports provided: readFileSyncBrowser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readFileSyncBrowser", function() { return readFileSyncBrowser; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/assert */ "../core/src/utils/assert.js");
// TODO - this file is not tested


const DEFAULT_OPTIONS = {
  dataType: 'arraybuffer',
  // TODO - this was mostly set to true to make test cases work
  nothrow: true
};

const isDataURL = url => url.startsWith('data:');

// In a few cases (data URIs, files under Node) "files" can be read synchronously
function readFileSyncBrowser(uri, options) {
  options = getReadFileOptions(options);

  if (isDataURL(uri)) {
    // TODO - removed until decodeDataUri does not depend on Node.js Buffer
    //   return decodeDataUri(uri);
  }

  if (!options.nothrow) {
    // throw new Error('Cant load URI synchronously');
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(false);
  }

  return null;
}

// HELPER FUNCTIONS

function getReadFileOptions(options = {}) {
  options = Object.assign({}, DEFAULT_OPTIONS, options);
  options.responseType = options.responseType || options.dataType;
  return options;
}


/***/ }),

/***/ "../core/src/lib/fetch/read-file.js":
/*!******************************************!*\
  !*** ../core/src/lib/fetch/read-file.js ***!
  \******************************************/
/*! exports provided: readFileSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readFileSync", function() { return readFileSync; });
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/globals */ "../core/src/utils/globals.js");
/* harmony import */ var _node_read_file_sync_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node/read-file-sync.node */ 2);
/* harmony import */ var _node_read_file_sync_node__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_read_file_sync_node__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _file_aliases__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./file-aliases */ "../core/src/lib/fetch/file-aliases.js");
/* harmony import */ var _read_file_browser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./read-file.browser */ "../core/src/lib/fetch/read-file.browser.js");





// In a few cases (data URIs, node.js) "files" can be read synchronously
function readFileSync(url, options = {}) {
  url = Object(_file_aliases__WEBPACK_IMPORTED_MODULE_2__["resolvePath"])(url);
  if (!_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"] && _node_read_file_sync_node__WEBPACK_IMPORTED_MODULE_1__["readFileSync"]) {
    return _node_read_file_sync_node__WEBPACK_IMPORTED_MODULE_1__["readFileSync"](url, options);
  }
  return Object(_read_file_browser__WEBPACK_IMPORTED_MODULE_3__["readFileSyncBrowser"])(url, options);
}


/***/ }),

/***/ "../core/src/lib/fetch/write-file.js":
/*!*******************************************!*\
  !*** ../core/src/lib/fetch/write-file.js ***!
  \*******************************************/
/*! exports provided: writeFile, writeFileSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "writeFile", function() { return writeFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "writeFileSync", function() { return writeFileSync; });
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/globals */ "../core/src/utils/globals.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/assert */ "../core/src/utils/assert.js");
/* harmony import */ var _node_write_file_node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../node/write-file.node */ 3);
/* harmony import */ var _node_write_file_node__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_write_file_node__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _file_aliases__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./file-aliases */ "../core/src/lib/fetch/file-aliases.js");





function writeFile(filePath, arrayBufferOrString, options) {
  filePath = Object(_file_aliases__WEBPACK_IMPORTED_MODULE_3__["resolvePath"])(filePath);
  if (!_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"] && _node_write_file_node__WEBPACK_IMPORTED_MODULE_2__["writeFile"]) {
    return _node_write_file_node__WEBPACK_IMPORTED_MODULE_2__["writeFile"](filePath, arrayBufferOrString, options);
  }
  return Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(false);
}

function writeFileSync(filePath, arrayBufferOrString, options) {
  filePath = Object(_file_aliases__WEBPACK_IMPORTED_MODULE_3__["resolvePath"])(filePath);
  if (!_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"] && _node_write_file_node__WEBPACK_IMPORTED_MODULE_2__["writeFileSync"]) {
    return _node_write_file_node__WEBPACK_IMPORTED_MODULE_2__["writeFileSync"](filePath, arrayBufferOrString, options);
  }
  return Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(false);
}


/***/ }),

/***/ "../core/src/lib/load.js":
/*!*******************************!*\
  !*** ../core/src/lib/load.js ***!
  \*******************************/
/*! exports provided: loadInBatches, load */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadInBatches", function() { return loadInBatches; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "load", function() { return load; });
/* harmony import */ var _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../javascript-utils/is-type */ "../core/src/javascript-utils/is-type.js");
/* harmony import */ var _fetch_fetch_file__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fetch/fetch-file */ "../core/src/lib/fetch/fetch-file.js");
/* harmony import */ var _loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loader-utils/normalize-loader */ "../core/src/lib/loader-utils/normalize-loader.js");
/* harmony import */ var _loader_utils_normalize_options__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loader-utils/normalize-options */ "../core/src/lib/loader-utils/normalize-options.js");
/* harmony import */ var _select_loader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./select-loader */ "../core/src/lib/select-loader.js");
/* harmony import */ var _parse__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parse */ "../core/src/lib/parse.js");
/* harmony import */ var _parse_in_batches__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./parse-in-batches */ "../core/src/lib/parse-in-batches.js");









async function loadInBatches(url, loaders, options) {
  const response = await Object(_fetch_fetch_file__WEBPACK_IMPORTED_MODULE_1__["fetchFile"])(url, options);
  return Object(_parse_in_batches__WEBPACK_IMPORTED_MODULE_6__["parseInBatches"])(response, loaders, options, url);
}

// Note: Load does duplicate a lot of parse.
// Works like parse but can call `loadAndParse` for parsers that need to do their own loading
// it can also call fetchFile on string urls, which `parse` won't do.
async function load(url, loaders, options) {
  // Signature: load(url, options)
  if (!Array.isArray(loaders) && !Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_2__["isLoaderObject"])(loaders)) {
    options = loaders;
    loaders = null;
  }

  // Extract a url for auto detection
  const autoUrl = Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isFileReadable"])(url) ? url.name : url;

  // Initial loader autodection (Use registered loaders if none provided)
  // This only uses URL extensions to detect loaders.
  const loader = Object(_select_loader__WEBPACK_IMPORTED_MODULE_4__["selectLoader"])(loaders, autoUrl, null, {nothrow: true});

  if (loader) {
    // Some loaders do not separate reading and parsing of data (e.g ImageLoader)
    // These can only be handled by `load`, not `parse`
    // TODO - ImageLoaders can be rewritten to separate load and parse, phase out this variant?
    if (loader.loadAndParse) {
      const loaderOptions = Object(_loader_utils_normalize_options__WEBPACK_IMPORTED_MODULE_3__["mergeLoaderAndUserOptions"])(options, loader);
      return await loader.loadAndParse(url, loaderOptions);
    }
  }

  // at this point, data can be binary or text
  let data = url;
  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isFileReadable"])(data) || typeof data === 'string') {
    data = await Object(_fetch_fetch_file__WEBPACK_IMPORTED_MODULE_1__["fetchFile"])(url, options);
  }

  // Fall back to parse
  // Note: An improved round of autodetection is possible now that data has been loaded
  // This means that another loader might be selected
  return Object(_parse__WEBPACK_IMPORTED_MODULE_5__["parse"])(data, loaders, options, url);
}


/***/ }),

/***/ "../core/src/lib/loader-utils/check-errors.js":
/*!****************************************************!*\
  !*** ../core/src/lib/loader-utils/check-errors.js ***!
  \****************************************************/
/*! exports provided: checkFetchResponseStatus, checkFetchResponseStatusSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkFetchResponseStatus", function() { return checkFetchResponseStatus; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkFetchResponseStatusSync", function() { return checkFetchResponseStatusSync; });
async function checkFetchResponseStatus(response) {
  if (!response.ok) {
    let errorMessage = `fetch failed ${response.status} `;
    try {
      const text = await response.text();
      errorMessage += text;
    } catch (error) {
      // ignore error
    }
    throw new Error(errorMessage);
  }
}

function checkFetchResponseStatusSync(response) {
  if (!response.ok) {
    throw new Error(`fetch failed ${response.status}`);
  }
}


/***/ }),

/***/ "../core/src/lib/loader-utils/get-data.js":
/*!************************************************!*\
  !*** ../core/src/lib/loader-utils/get-data.js ***!
  \************************************************/
/*! exports provided: getUrlFromData, getArrayBufferOrStringFromDataSync, getArrayBufferOrStringFromData, getAsyncIteratorFromData, getIteratorFromData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUrlFromData", function() { return getUrlFromData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArrayBufferOrStringFromDataSync", function() { return getArrayBufferOrStringFromDataSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArrayBufferOrStringFromData", function() { return getArrayBufferOrStringFromData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAsyncIteratorFromData", function() { return getAsyncIteratorFromData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIteratorFromData", function() { return getIteratorFromData; });
/* harmony import */ var _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../javascript-utils/is-type */ "../core/src/javascript-utils/is-type.js");
/* harmony import */ var _javascript_utils_stream_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../javascript-utils/stream-utils */ "../core/src/javascript-utils/stream-utils.js");
/* harmony import */ var _fetch_fetch_file_browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../fetch/fetch-file.browser */ "../core/src/lib/fetch/fetch-file.browser.js");
/* harmony import */ var _check_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./check-errors */ "../core/src/lib/loader-utils/check-errors.js");
/* global TextDecoder */





const ERR_DATA = 'Cannot convert supplied data type';

// Extract a URL from `parse` arguments if possible
// If a fetch Response object or File/Blob were passed in get URL from those objects
function getUrlFromData(data, url) {
  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isFetchResponse"])(data)) {
    url = url || data.url;
  } else if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isFileReadable"])(url)) {
    // File or Blob
    url = url.name;
  }
  // Strip any query string
  return typeof url === 'string' ? url.replace(/\?.*/, '') : url;
}

function getArrayBufferOrStringFromDataSync(data, loader) {
  if (loader.text && typeof data === 'string') {
    return data;
  }

  if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
    const arrayBuffer = data.buffer || data;
    if (loader.text && !loader.binary) {
      const textDecoder = new TextDecoder('utf8');
      return textDecoder.decode(arrayBuffer);
    }
    return arrayBuffer;
  }

  throw new Error(ERR_DATA);
}

// Convert async iterator to a promise
async function getArrayBufferOrStringFromData(data, loader) {
  // Resolve any promise
  data = await data;

  const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);
  if (typeof data === 'string' || isArrayBuffer) {
    return getArrayBufferOrStringFromDataSync(data, loader);
  }

  // Blobs and files are FileReader compatible
  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isFileReadable"])(data)) {
    data = await Object(_fetch_fetch_file_browser__WEBPACK_IMPORTED_MODULE_2__["default"])(data);
  }

  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isFetchResponse"])(data)) {
    await Object(_check_errors__WEBPACK_IMPORTED_MODULE_3__["checkFetchResponseStatus"])(data);
    return loader.binary ? await data.arrayBuffer() : await data.text();
  }

  // if (isIterable(data) || isAsyncIterable(data)) {
  // }

  // Assume arrayBuffer iterator - attempt to concatenate
  // return concatenateAsyncIterator(data);

  throw new Error(ERR_DATA);
}

function getAsyncIteratorFromData(data) {
  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isIterator"])(data)) {
    return data;
  }

  // TODO: Our fetchFileReaderObject response does not yet support a body stream
  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isFetchResponse"])(data) && data.body) {
    // Note Since this function is not async, we currently can't load error message, just status
    Object(_check_errors__WEBPACK_IMPORTED_MODULE_3__["checkFetchResponseStatusSync"])(data);
    return Object(_javascript_utils_stream_utils__WEBPACK_IMPORTED_MODULE_1__["getStreamIterator"])(data.body);
  }

  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isReadableStream"])(data)) {
    return Object(_javascript_utils_stream_utils__WEBPACK_IMPORTED_MODULE_1__["getStreamIterator"])(data);
  }

  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isAsyncIterable"])(data)) {
    return data[Symbol.asyncIterator]();
  }

  return getIteratorFromData(data);
}

function getIteratorFromData(data) {
  // generate an iterator that emits a single chunk
  if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
    return (function* oneChunk() {
      yield data.buffer || data;
    })();
  }

  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isIterator"])(data)) {
    return data;
  }

  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isIterable"])(data)) {
    return data[Symbol.iterator]();
  }

  throw new Error(ERR_DATA);
}


/***/ }),

/***/ "../core/src/lib/loader-utils/get-loader-context.js":
/*!**********************************************************!*\
  !*** ../core/src/lib/loader-utils/get-loader-context.js ***!
  \**********************************************************/
/*! exports provided: getLoaderContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLoaderContext", function() { return getLoaderContext; });
function getLoaderContext(context, options) {
  return {
    fetch: typeof window !== 'undefined' && window.fetch,
    ...context
  };
}


/***/ }),

/***/ "../core/src/lib/loader-utils/normalize-loader.js":
/*!********************************************************!*\
  !*** ../core/src/lib/loader-utils/normalize-loader.js ***!
  \********************************************************/
/*! exports provided: isLoaderObject, normalizeLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isLoaderObject", function() { return isLoaderObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeLoader", function() { return normalizeLoader; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/assert */ "../core/src/utils/assert.js");


function isLoaderObject(loader) {
  if (!loader) {
    return false;
  }

  if (Array.isArray(loader)) {
    loader = loader[0];
  }

  const hasParser =
    loader.parseTextSync ||
    loader.parseSync ||
    loader.parse ||
    loader.loadAndParse ||
    loader.parseStream || // TODO Replace with parseInBatches
    loader.parseInBatches ||
    // loader.parseInBatchesSync || // Optimization only, parseInBatches needed
    loader.worker;

  return hasParser;
}

function normalizeLoader(loader) {
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(isLoaderObject(loader));

  // NORMALIZE [LOADER, OPTIONS] => LOADER

  // If [loader, options], create a new loaders object with options merged in
  let options;
  if (Array.isArray(loader)) {
    options = loader[1];
    loader = loader[0];
    loader = {
      ...loader,
      options: {...loader.options, ...options}
    };
  }

  // NORMALIZE LOADER.EXTENSIONS

  // Remove `extension`` prop, replace with `extensions``
  if (loader.extension) {
    loader.extensions = loader.extensions || loader.extension;
    delete loader.extension;
  }

  // Ensure loader.extensions is an array
  if (!Array.isArray(loader.extensions)) {
    loader.extensions = [loader.extensions];
  }

  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(loader.extensions && loader.extensions.length > 0 && loader.extensions[0]);

  // NORMALIZE text and binary flags

  // Ensure at least one of text/binary flags are properly set
  if (loader.parseTextSync) {
    loader.text = true;
  }

  if (!loader.text) {
    loader.binary = true;
  }

  // TODO - Does adding a default MIME type add any value?
  /*
  if (!loader.mimeType) {
    if (loader.binary) {
      // TODO - do we need separate mime types for binary and text formats?
      loader.mimeType = 'application/octet-stream';
    }
  }
  */

  return loader;
}


/***/ }),

/***/ "../core/src/lib/loader-utils/normalize-options.js":
/*!*********************************************************!*\
  !*** ../core/src/lib/loader-utils/normalize-options.js ***!
  \*********************************************************/
/*! exports provided: mergeLoaderAndUserOptions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeLoaderAndUserOptions", function() { return mergeLoaderAndUserOptions; });
/* harmony import */ var _null_log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./null-log */ "../core/src/lib/loader-utils/null-log.js");


function mergeLoaderAndUserOptions(options, loader) {
  options = Object.assign(
    {},
    loader && loader.DEFAULT_OPTIONS,
    loader && loader.defaultOptions,
    loader && loader.options,
    options,
    // TODO - explain why this option is needed for parsing
    {
      dataType: 'arraybuffer'
    }
  );

  // LOGGING

  // options.log can be set to `null` to defeat logging
  if (options.log === null) {
    options.log = new _null_log__WEBPACK_IMPORTED_MODULE_0__["default"]();
  }
  // log defaults to console
  if (!('log' in options)) {
    /* global console */
    options.log = console;
  }

  return options;
}


/***/ }),

/***/ "../core/src/lib/loader-utils/null-log.js":
/*!************************************************!*\
  !*** ../core/src/lib/loader-utils/null-log.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return NullLog; });
class NullLog {
  log() {}
  info() {}
  warn() {}
  error() {}
}


/***/ }),

/***/ "../core/src/lib/loader-utils/parse-with-worker.js":
/*!*********************************************************!*\
  !*** ../core/src/lib/loader-utils/parse-with-worker.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseWithWorker; });
/* harmony import */ var _javascript_utils_binary_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../javascript-utils/binary-utils */ "../core/src/javascript-utils/binary-utils.js");
/* harmony import */ var _worker_utils_worker_farm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../worker-utils/worker-farm */ "../core/src/worker-utils/worker-farm.js");
/* harmony import */ var _parse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parse */ "../core/src/lib/parse.js");
/* harmony import */ var _worker_utils_worker_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../worker-utils/worker-utils */ "../core/src/worker-utils/worker-utils.js");






let _workerFarm = null;

function getWorkerFarm(options = {}) {
  const props = {};
  if (options.maxConcurrency) {
    props.maxConcurrency = options.maxConcurrency;
  }
  if (options.onDebug) {
    props.onDebug = options.onDebug;
  }

  if (!_workerFarm) {
    _workerFarm = new _worker_utils_worker_farm__WEBPACK_IMPORTED_MODULE_1__["default"]({onMessage: onWorkerMessage});
  }
  _workerFarm.setProps(props);

  return _workerFarm;
}

async function onWorkerMessage({worker, data, resolve, reject}) {
  switch (data.type) {
    case 'done':
      resolve(data.result);
      break;

    case 'process':
      try {
        const result = await Object(_parse__WEBPACK_IMPORTED_MODULE_2__["parse"])(data.arraybuffer, data.options, data.url);
        worker.postMessage({type: 'process-done', id: data.id, result}, Object(_worker_utils_worker_utils__WEBPACK_IMPORTED_MODULE_3__["getTransferList"])(result));
      } catch (error) {
        worker.postMessage({type: 'process-error', id: data.id, message: error.message});
      }
      break;

    case 'error':
      reject(data.message);
      break;

    default:
    // TODO - is this not an error case? Log a warning?
  }
}

/**
 * this function expects that the worker function sends certain messages,
 * this can be automated if the worker is wrapper by a call to createWorker in @loaders.gl/loader-utils.
 */
function parseWithWorker(
  workerSource,
  workerName,
  data,
  options = {},
  context = {}
) {
  const workerFarm = getWorkerFarm(options);

  // options.log object contains functions which cannot be transferred
  // TODO - decide how to handle logging on workers
  options = JSON.parse(JSON.stringify(options));

  return workerFarm.process(workerSource, `loaders.gl-${workerName}`, {
    arraybuffer: Object(_javascript_utils_binary_utils__WEBPACK_IMPORTED_MODULE_0__["toArrayBuffer"])(data),
    options,
    source: 'loaders.gl', // Lets worker ignore unrelated messages
    type: 'process' // For future extension
  });
}


/***/ }),

/***/ "../core/src/lib/parse-in-batches-sync.js":
/*!************************************************!*\
  !*** ../core/src/lib/parse-in-batches-sync.js ***!
  \************************************************/
/*! exports provided: parseInBatchesSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseInBatchesSync", function() { return parseInBatchesSync; });
/* harmony import */ var _loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loader-utils/normalize-loader */ "../core/src/lib/loader-utils/normalize-loader.js");
/* harmony import */ var _loader_utils_normalize_options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loader-utils/normalize-options */ "../core/src/lib/loader-utils/normalize-options.js");
/* harmony import */ var _loader_utils_get_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loader-utils/get-data */ "../core/src/lib/loader-utils/get-data.js");
/* harmony import */ var _loader_utils_get_loader_context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loader-utils/get-loader-context */ "../core/src/lib/loader-utils/get-loader-context.js");
/* harmony import */ var _select_loader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./select-loader */ "../core/src/lib/select-loader.js");






// TODO - remove?
async function parseInBatchesSync(data, loaders, options, url) {
  // Signature: parseInBatchesSync(data, options, url)
  // Uses registered loaders
  if (!Array.isArray(loaders) && !Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_0__["isLoaderObject"])(loaders)) {
    url = options;
    options = loaders;
    loaders = null;
  }

  // Chooses a loader and normalizes it
  // TODO - only uses URL, need a selectLoader variant that peeks at first stream chunk...
  const loader = Object(_select_loader__WEBPACK_IMPORTED_MODULE_4__["selectLoader"])(loaders, url, null);

  // Normalize options
  options = Object(_loader_utils_normalize_options__WEBPACK_IMPORTED_MODULE_1__["mergeLoaderAndUserOptions"])(options, loader);

  const context = Object(_loader_utils_get_loader_context__WEBPACK_IMPORTED_MODULE_3__["getLoaderContext"])({url}, options);

  return parseWithLoaderInBatchesSync(loader, data, options, context);
}

function parseWithLoaderInBatchesSync(loader, data, options, context) {
  // Create async iterator adapter for data, and concatenate result
  if (loader.parseInBatchesSync) {
    const inputIterator = Object(_loader_utils_get_data__WEBPACK_IMPORTED_MODULE_2__["getIteratorFromData"])(data);
    const outputIterator = loader.parseInBatchesSync(inputIterator, options, context, loader);
    return outputIterator;
  }

  throw new Error('parseWithLoaderInBatchesSync not available');
}


/***/ }),

/***/ "../core/src/lib/parse-in-batches.js":
/*!*******************************************!*\
  !*** ../core/src/lib/parse-in-batches.js ***!
  \*******************************************/
/*! exports provided: parseInBatches */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseInBatches", function() { return parseInBatches; });
/* harmony import */ var _loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loader-utils/normalize-loader */ "../core/src/lib/loader-utils/normalize-loader.js");
/* harmony import */ var _loader_utils_normalize_options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loader-utils/normalize-options */ "../core/src/lib/loader-utils/normalize-options.js");
/* harmony import */ var _loader_utils_get_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loader-utils/get-data */ "../core/src/lib/loader-utils/get-data.js");
/* harmony import */ var _loader_utils_get_loader_context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loader-utils/get-loader-context */ "../core/src/lib/loader-utils/get-loader-context.js");
/* harmony import */ var _select_loader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./select-loader */ "../core/src/lib/select-loader.js");






async function parseInBatches(data, loaders, options, url) {
  // Signature: parseInBatches(data, options, url)
  // Uses registered loaders
  if (!Array.isArray(loaders) && !Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_0__["isLoaderObject"])(loaders)) {
    url = options;
    options = loaders;
    loaders = null;
  }

  // Chooses a loader and normalizes it
  // TODO - only uses URL, need a selectLoader variant that peeks at first stream chunk...
  const loader = Object(_select_loader__WEBPACK_IMPORTED_MODULE_4__["selectLoader"])(loaders, url, null);

  // Normalize options
  options = Object(_loader_utils_normalize_options__WEBPACK_IMPORTED_MODULE_1__["mergeLoaderAndUserOptions"])(options, loader);

  const context = Object(_loader_utils_get_loader_context__WEBPACK_IMPORTED_MODULE_3__["getLoaderContext"])({url}, options);

  return parseWithLoaderInBatches(loader, data, options, context);
}

function parseWithLoaderInBatches(loader, data, options, context) {
  // Create async iterator adapter for data, and concatenate result
  if (loader.parseInBatches) {
    const inputIterator = Object(_loader_utils_get_data__WEBPACK_IMPORTED_MODULE_2__["getAsyncIteratorFromData"])(data);
    const outputIterator = loader.parseInBatches(inputIterator, options, context, loader);
    return outputIterator;
  }

  throw new Error('parseWithLoaderInBatchesSync not available');
}


/***/ }),

/***/ "../core/src/lib/parse-sync.js":
/*!*************************************!*\
  !*** ../core/src/lib/parse-sync.js ***!
  \*************************************/
/*! exports provided: parseSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseSync", function() { return parseSync; });
/* harmony import */ var _select_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select-loader */ "../core/src/lib/select-loader.js");
/* harmony import */ var _loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loader-utils/normalize-loader */ "../core/src/lib/loader-utils/normalize-loader.js");
/* harmony import */ var _loader_utils_normalize_options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loader-utils/normalize-options */ "../core/src/lib/loader-utils/normalize-options.js");
/* harmony import */ var _loader_utils_get_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loader-utils/get-data */ "../core/src/lib/loader-utils/get-data.js");
/* harmony import */ var _loader_utils_get_loader_context__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./loader-utils/get-loader-context */ "../core/src/lib/loader-utils/get-loader-context.js");






function parseSync(data, loaders, options, url) {
  // Signature: parseSync(data, options, url)
  // Uses registered loaders
  if (!Array.isArray(loaders) && !Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_1__["isLoaderObject"])(loaders)) {
    url = options;
    options = loaders;
    loaders = null;
  }

  // Chooses a loader and normalize it
  const loader = Object(_select_loader__WEBPACK_IMPORTED_MODULE_0__["selectLoader"])(loaders, url, data);
  // Note: if nothrow option was set, it is possible that no loader was found, if so just return null
  if (!loader) {
    return null;
  }

  // Normalize options
  options = Object(_loader_utils_normalize_options__WEBPACK_IMPORTED_MODULE_2__["mergeLoaderAndUserOptions"])(options, loader);

  const context = Object(_loader_utils_get_loader_context__WEBPACK_IMPORTED_MODULE_4__["getLoaderContext"])({url, parseSync}, options);

  return parseWithLoaderSync(loader, data, options, context);
}

// TODO - should accept loader.parseSync/parse and generate 1 chunk asyncIterator
function parseWithLoaderSync(loader, data, options, context) {
  data = Object(_loader_utils_get_data__WEBPACK_IMPORTED_MODULE_3__["getArrayBufferOrStringFromDataSync"])(data, loader);

  if (loader.parseTextSync && typeof data === 'string') {
    return loader.parseTextSync(data, options, context, loader);
  }

  if (loader.parseSync) {
    return loader.parseSync(data, options, context, loader);
  }

  // TBD - If synchronous parser not available, return null
  throw new Error(`Could not parse ${context.url || 'data'} using ${loader.name} loader`);
}


/***/ }),

/***/ "../core/src/lib/parse.js":
/*!********************************!*\
  !*** ../core/src/lib/parse.js ***!
  \********************************/
/*! exports provided: parse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "../core/src/utils/assert.js");
/* harmony import */ var _loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loader-utils/normalize-loader */ "../core/src/lib/loader-utils/normalize-loader.js");
/* harmony import */ var _loader_utils_normalize_options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loader-utils/normalize-options */ "../core/src/lib/loader-utils/normalize-options.js");
/* harmony import */ var _loader_utils_get_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loader-utils/get-data */ "../core/src/lib/loader-utils/get-data.js");
/* harmony import */ var _loader_utils_get_loader_context__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./loader-utils/get-loader-context */ "../core/src/lib/loader-utils/get-loader-context.js");
/* harmony import */ var _loader_utils_parse_with_worker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./loader-utils/parse-with-worker */ "../core/src/lib/loader-utils/parse-with-worker.js");
/* harmony import */ var _select_loader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./select-loader */ "../core/src/lib/select-loader.js");









async function parse(data, loaders, options, url) {
  // Signature: parse(data, options, url)
  // Uses registered loaders
  if (loaders && !Array.isArray(loaders) && !Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_1__["isLoaderObject"])(loaders)) {
    url = options;
    options = loaders;
    loaders = null;
  }

  options = options || {};

  // Extract a url for auto detection
  const autoUrl = Object(_loader_utils_get_data__WEBPACK_IMPORTED_MODULE_3__["getUrlFromData"])(data, url);

  // Chooses a loader and normalize it
  const loader = Object(_select_loader__WEBPACK_IMPORTED_MODULE_6__["selectLoader"])(loaders, autoUrl, data);

  // Normalize options
  options = Object(_loader_utils_normalize_options__WEBPACK_IMPORTED_MODULE_2__["mergeLoaderAndUserOptions"])(options, loader);

  const context = Object(_loader_utils_get_loader_context__WEBPACK_IMPORTED_MODULE_4__["getLoaderContext"])({url: autoUrl, parse}, options);

  return await parseWithLoader(loader, data, options, context);
}

// TODO: support progress and abort
// TODO: support moving loading to worker
// TODO - should accept loader.parseAsyncIterator and concatenate.
async function parseWithLoader(loader, data, options, context) {
  data = await Object(_loader_utils_get_data__WEBPACK_IMPORTED_MODULE_3__["getArrayBufferOrStringFromData"])(data, loader);

  // First check for synchronous text parser, wrap results in promises
  if (loader.parseTextSync && typeof data === 'string') {
    options.dataType = 'text';
    return loader.parseTextSync(data, options, context, loader);
  }

  // Check for asynchronous parser
  if (loader.parse) {
    return await loader.parse(data, options, context, loader);
  }

  // Now check for synchronous binary data parser, wrap results in promises
  if (loader.parseSync) {
    return loader.parseSync(data, options, context, loader);
  }

  if (loader.worker) {
    return await Object(_loader_utils_parse_with_worker__WEBPACK_IMPORTED_MODULE_5__["default"])(loader.worker, loader.name, data, options, context, loader);
  }

  // TBD - If asynchronous parser not available, return null
  // => This loader does not work on loaded data and only supports `loadAndParseAsync`
  return Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(false);
}


/***/ }),

/***/ "../core/src/lib/path/path.js":
/*!************************************!*\
  !*** ../core/src/lib/path/path.js ***!
  \************************************/
/*! exports provided: dirname */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dirname", function() { return dirname; });
// Beginning of a minimal implementation of the Node.js path API, that doesn't pull in big polyfills.
function dirname(url) {
  const slashIndex = url && url.lastIndexOf('/');
  return slashIndex >= 0 ? url.substr(0, slashIndex) : '';
}


/***/ }),

/***/ "../core/src/lib/progress/fetch-progress.js":
/*!**************************************************!*\
  !*** ../core/src/lib/progress/fetch-progress.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return fetchProgress; });
// Forked from github AnthumChris/fetch-progress-indicators under MIT license
/* global Response, ReadableStream */

// Intercepts the Response stream and creates a new Response
async function fetchProgress(
  response,
  onProgress,
  onDone = () => {},
  onError = () => {}
) {
  response = await response;
  if (!response.ok) {
    // ERROR checking needs to be done separately
    return response;
  }
  if (!response.body) {
    // 'ReadableStream not yet supported in this browser.
    return response;
  }
  const contentLength = response.headers.get('content-length');
  const totalBytes = contentLength && parseInt(contentLength, 10);
  if (!(contentLength > 0)) {
    return response;
  }
  // Currently override only implemented in browser
  if (typeof ReadableStream === 'undefined') {
    return response;
  }

  // Create a new stream that invisbly wraps original stream
  const progressStream = new ReadableStream({
    start(controller) {
      const reader = response.body.getReader();
      read(controller, reader, 0, totalBytes, onProgress, onDone, onError);
    }
  });

  return new Response(progressStream);
}

// Forward to original streams controller
// TODO - this causes a crazy deep "async stack"... rewrite as async iterator?
// eslint-disable-next-line max-params
async function read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError) {
  try {
    const {done, value} = await reader.read();
    if (done) {
      onDone();
      controller.close();
      return;
    }
    loadedBytes += value.byteLength;
    const percent = Math.round((loadedBytes / totalBytes) * 100);
    onProgress(percent, {loadedBytes, totalBytes});
    controller.enqueue(value);
    await read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError);
  } catch (error) {
    controller.error(error);
    onError(error);
  }
}


/***/ }),

/***/ "../core/src/lib/register-loaders.js":
/*!*******************************************!*\
  !*** ../core/src/lib/register-loaders.js ***!
  \*******************************************/
/*! exports provided: registerLoaders, getRegisteredLoaders, _unregisterLoaders */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerLoaders", function() { return registerLoaders; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRegisteredLoaders", function() { return getRegisteredLoaders; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_unregisterLoaders", function() { return _unregisterLoaders; });
/* harmony import */ var _loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loader-utils/normalize-loader */ "../core/src/lib/loader-utils/normalize-loader.js");


let registeredLoaders = [];

function registerLoaders(loaders) {
  loaders = Array.isArray(loaders) ? loaders : [loaders];

  for (const loader of loaders) {
    const normalizedLoader = Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_0__["normalizeLoader"])(loader);
    if (!registeredLoaders.find(registeredLoader => normalizedLoader === registeredLoader)) {
      // add to the beginning of the registeredLoaders, so the last registeredLoader get picked
      registeredLoaders.unshift(normalizedLoader);
    }
  }
}

function getRegisteredLoaders() {
  return registeredLoaders;
}

// For testing
function _unregisterLoaders() {
  registeredLoaders = [];
}


/***/ }),

/***/ "../core/src/lib/save.js":
/*!*******************************!*\
  !*** ../core/src/lib/save.js ***!
  \*******************************/
/*! exports provided: save, saveSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "save", function() { return save; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saveSync", function() { return saveSync; });
/* harmony import */ var _encode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./encode */ "../core/src/lib/encode.js");
/* harmony import */ var _fetch_write_file__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fetch/write-file */ "../core/src/lib/fetch/write-file.js");



function save(data, url, writer, options) {
  const encodedData = Object(_encode__WEBPACK_IMPORTED_MODULE_0__["encode"])(data, writer, options, url);
  return Object(_fetch_write_file__WEBPACK_IMPORTED_MODULE_1__["writeFile"])(url, encodedData);
}

function saveSync(data, url, writer, options) {
  const encodedData = Object(_encode__WEBPACK_IMPORTED_MODULE_0__["encodeSync"])(data, writer, options, url);
  return Object(_fetch_write_file__WEBPACK_IMPORTED_MODULE_1__["writeFileSync"])(url, encodedData);
}


/***/ }),

/***/ "../core/src/lib/select-loader.js":
/*!****************************************!*\
  !*** ../core/src/lib/select-loader.js ***!
  \****************************************/
/*! exports provided: selectLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selectLoader", function() { return selectLoader; });
/* harmony import */ var _register_loaders__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./register-loaders */ "../core/src/lib/register-loaders.js");
/* harmony import */ var _loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loader-utils/normalize-loader */ "../core/src/lib/loader-utils/normalize-loader.js");



const EXT_PATTERN = /\.([^.]+)$/;
const DATA_URL_PATTERN = /^data:(.*?)(;|,)/;

// Find a loader that matches file extension and/or initial file content
// Search the loaders array argument for a loader that matches url extension or initial data
// Returns: a normalized loader

// TODO - Need a variant that peeks at streams for parseInBatches
// TODO - Detect multiple matching loaders? Use heuristics to grade matches?
// TODO - Allow apps to pass context to disambiguate between multiple matches (e.g. multiple .json formats)?

function selectLoader(loaders, url = '', data = null, {nothrow = false} = {}) {
  url = url || '';

  // if only a single loader was provided (not as array), force its use
  // TODO - Should this behaviour be kept and documented?
  if (loaders && !Array.isArray(loaders)) {
    const loader = loaders;
    Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_1__["normalizeLoader"])(loader);
    return loader;
  }

  // If no loaders provided, get the registered loaders
  loaders = loaders || Object(_register_loaders__WEBPACK_IMPORTED_MODULE_0__["getRegisteredLoaders"])();
  normalizeLoaders(loaders);

  url = url.replace(/\?.*/, '');
  let loader = null;
  loader = loader || findLoaderByUrl(loaders, url);
  loader = loader || findLoaderByExamingInitialData(loaders, data);

  // no loader available
  if (!loader) {
    if (nothrow) {
      return null;
    }
    throw new Error(`No valid loader found for ${url}`);
  }

  return loader;
}

function normalizeLoaders(loaders) {
  for (const loader of loaders) {
    Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_1__["normalizeLoader"])(loader);
  }
}

// TODO - Would be nice to support http://example.com/file.glb?parameter=1
// E.g: x = new URL('http://example.com/file.glb?load=1'; x.pathname
function findLoaderByUrl(loaders, url) {
  // Check for data url
  let match = url.match(DATA_URL_PATTERN);
  const mimeType = match && match[1];
  if (mimeType) {
    return findLoaderByMimeType(loaders, mimeType);
  }
  // Get extension
  match = url.match(EXT_PATTERN);
  const extension = match && match[1];
  const loader = extension && findLoaderByExtension(loaders, extension);
  return loader;
}

function findLoaderByMimeType(loaders, mimeType) {
  for (const loader of loaders) {
    if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {
      return loader;
    }
  }
  return null;
}

function findLoaderByExtension(loaders, extension) {
  extension = extension.toLowerCase();

  for (const loader of loaders) {
    for (const loaderExtension of loader.extensions) {
      if (loaderExtension.toLowerCase() === extension) {
        return loader;
      }
    }
  }
  return null;
}

function findLoaderByExamingInitialData(loaders, data) {
  if (!data) {
    return null;
  }

  for (const loader of loaders) {
    if (typeof data === 'string') {
      if (testText(data, loader)) {
        return loader;
      }
    } else if (ArrayBuffer.isView(data)) {
      // Typed Arrays can have offsets into underlying buffer
      if (testBinary(data.buffer, data.byteOffset, loader)) {
        return loader;
      }
    } else if (data instanceof ArrayBuffer) {
      const byteOffset = 0;
      if (testBinary(data, byteOffset, loader)) {
        return loader;
      }
    }
    // TODO Handle streaming case (requires creating a new AsyncIterator)
  }
  return null;
}

function testText(data, loader) {
  return loader.testText && loader.testText(data);
}

function testBinary(data, byteOffset, loader) {
  const type = Array.isArray(loader.test) ? 'array' : typeof loader.test;
  switch (type) {
    case 'function':
      return loader.test(data, loader);

    case 'string':
    case 'array':
      // Magic bytes check: If `loader.test` is a string or array of strings,
      // check if binary data starts with one of those strings
      const tests = Array.isArray(loader.test) ? loader.test : [loader.test];
      return tests.some(test => {
        const magic = getMagicString(data, byteOffset, test.length);
        return test === magic;
      });

    default:
      return false;
  }
}

function getMagicString(arrayBuffer, byteOffset, length) {
  if (arrayBuffer.byteLength <= byteOffset + length) {
    return '';
  }
  const dataView = new DataView(arrayBuffer);
  let magic = '';
  for (let i = 0; i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }
  return magic;
}


/***/ }),

/***/ "../core/src/utils/assert.js":
/*!***********************************!*\
  !*** ../core/src/utils/assert.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
// Replacement for the external assert method to reduce bundle size
// Note: We don't use the second "message" argument in calling code,
// so no need to support it here
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loader assertion failed.');
  }
}


/***/ }),

/***/ "../core/src/utils/globals.js":
/*!************************************!*\
  !*** ../core/src/utils/globals.js ***!
  \************************************/
/*! exports provided: isBrowser, self, window, global, document, nodeVersion */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process, global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return isBrowser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "self", function() { return self_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "window", function() { return window_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "global", function() { return global_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "document", function() { return document_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nodeVersion", function() { return nodeVersion; });
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Purpose: include this in your module to avoids adding dependencies on
// micro modules like 'global' and 'is-browser';

/* eslint-disable no-restricted-globals */
/* global process, window, global, document */
const isBrowser =
  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;

/* global self, window, global, document */
const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};

const self_ = globals.self || globals.window || globals.global;
const window_ = globals.window || globals.self || globals.global;
const global_ = globals.global || globals.self || globals.window;
const document_ = globals.document || {};



// Extract node version
const matches =
  typeof process !== 'undefined' && process.version && process.version.match(/v([0-9]*)/);
const nodeVersion = (matches && parseFloat(matches[1])) || 0;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/process/browser.js */ "../../node_modules/process/browser.js"), __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../core/src/worker-utils/worker-farm.js":
/*!***********************************************!*\
  !*** ../core/src/worker-utils/worker-farm.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorkerFarm; });
/* harmony import */ var _worker_pool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-pool */ "../core/src/worker-utils/worker-pool.js");


const DEFAULT_MAX_CONCURRENCY = 5;

/**
 * Process multiple data messages with a "farm" of different workers (in worker pools)
 */
class WorkerFarm {
  /**
   * @param processor {function | string} - worker function
   * @param maxConcurrency {number} - max count of workers
   */
  constructor({maxConcurrency = DEFAULT_MAX_CONCURRENCY, onMessage, onDebug = () => {}}) {
    this.maxConcurrency = maxConcurrency;
    this.onMessage = onMessage;
    this.onDebug = onDebug;
    this.workerPools = new Map();
  }

  setProps(props) {
    if ('maxConcurrency' in props) {
      this.maxConcurrency = props.maxConcurrency;
    }

    if ('onDebug' in props) {
      this.onDebug = props.onDebug;
    }
  }

  destroy() {
    this.workerPools.forEach(workerPool => workerPool.destroy());
  }

  /**
   * Process binary data in a worker
   * @param data {data containing binary typed arrays} - data to be transferred to worker
   * @returns a Promise with data containing typed arrays transferred back from work
   */
  async process(workerSource, workerName, data) {
    const workerPool = this._getWorkerPool(workerSource, workerName);
    return workerPool.process(data);
  }

  // PRIVATE

  _getWorkerPool(workerSource, workerName) {
    let workerPool = this.workerPools.get(workerName);
    if (!workerPool) {
      workerPool = new _worker_pool__WEBPACK_IMPORTED_MODULE_0__["default"]({
        source: workerSource,
        name: workerName,
        onMessage: this.onMessage,
        maxConcurrency: this.maxConcurrency,
        onDebug: this.onDebug
      });
      this.workerPools.set(workerName, workerPool);
    }
    return workerPool;
  }
}


/***/ }),

/***/ "../core/src/worker-utils/worker-pool.js":
/*!***********************************************!*\
  !*** ../core/src/worker-utils/worker-pool.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorkerPool; });
/* harmony import */ var _worker_thread__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-thread */ "../core/src/worker-utils/worker-thread.js");


/**
 * Process multiple data messages with small pool of identical workers
 */
class WorkerPool {
  /**
   * @param processor {function | string} - worker function
   * @param maxConcurrency {number} - max count of workers
   */
  constructor({source, name = 'unnamed', maxConcurrency = 1, onMessage, onDebug = () => {}}) {
    this.source = source;
    this.name = name;
    this.maxConcurrency = maxConcurrency;
    this.onMessage = onMessage;
    this.onDebug = onDebug;

    this.jobQueue = [];
    this.idleQueue = [];
    this.count = 0;
    this.isDestroyed = false;
  }

  destroy() {
    // Destroy idle workers, active Workers will be destroyed on completion
    this.idleQueue.forEach(worker => worker.destroy());
    this.isDestroyed = true;
  }

  /**
   * Process binary data in a worker
   * @param data {data containing binary typed arrays} - data to be transferred to worker
   * @returns a Promise with data containing typed arrays transferred back from work
   */
  async process(data, jobName) {
    return new Promise((resolve, reject) => {
      this.jobQueue.push({data, jobName, resolve, reject});
      this._startQueuedJob();
    });
  }

  // PRIVATE

  _startQueuedJob() {
    if (!this.jobQueue.length) {
      return;
    }
    const worker = this._getAvailableWorker();
    if (!worker) {
      return;
    }

    // We have a worker, dequeue and start the job
    const job = this.jobQueue.shift();

    this.onDebug({
      message: 'processing',
      worker: worker.name,
      job: job.jobName,
      backlog: this.jobQueue.length
    });

    worker
      .process(job.data)
      .then(result => job.resolve(result))
      .catch(error => job.reject(error))
      .then(() => this._onWorkerDone(worker));
  }

  _onWorkerDone(worker) {
    if (this.isDestroyed) {
      worker.destroy();
    } else {
      this.idleQueue.push(worker);
      this._startQueuedJob();
    }
  }

  _getAvailableWorker() {
    // If a worker has completed and returned to the queue, it can be used
    if (this.idleQueue.length > 0) {
      return this.idleQueue.shift();
    }

    // Create fresh worker if we haven't yet created the max amount of worker threads for this worker source
    if (this.count < this.maxConcurrency) {
      this.count++;
      const name = `${this.name.toLowerCase()}-worker-${this.count}-of-${this.maxConcurrency}`;
      return new _worker_thread__WEBPACK_IMPORTED_MODULE_0__["default"]({source: this.source, onMessage: this.onMessage, name});
    }

    // No worker available, have to wait
    return null;
  }
}


/***/ }),

/***/ "../core/src/worker-utils/worker-thread.js":
/*!*************************************************!*\
  !*** ../core/src/worker-utils/worker-thread.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorkerThread; });
/* harmony import */ var _worker_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-utils */ "../core/src/worker-utils/worker-utils.js");
/* global Worker */


let count = 0;

// By default resolves to the first message the worker sends back
function defaultOnMessage({data, resolve}) {
  resolve(data);
}

class WorkerThread {
  constructor({source, name = `web-worker-${count++}`, onMessage}) {
    const url = Object(_worker_utils__WEBPACK_IMPORTED_MODULE_0__["getWorkerURL"])(source);
    this.worker = new Worker(url, {name});
    this.name = name;
    this.onMessage = onMessage || defaultOnMessage;
  }

  /**
   * Process binary data in a worker
   * @param data {data containing binary typed arrays} - data to be transferred to worker
   * @returns a Promise with data containing typed arrays transferred back from work
   */
  async process(data) {
    return new Promise((resolve, reject) => {
      this.worker.onmessage = event =>
        this.onMessage({worker: this.worker, data: event.data, resolve, reject});
      this.worker.onerror = error => reject(error);
      const transferList = Object(_worker_utils__WEBPACK_IMPORTED_MODULE_0__["getTransferList"])(data);
      this.worker.postMessage(data, transferList);
    });
  }

  destroy() {
    this.worker.terminate();
    this.worker = null;
  }
}


/***/ }),

/***/ "../core/src/worker-utils/worker-utils.js":
/*!************************************************!*\
  !*** ../core/src/worker-utils/worker-utils.js ***!
  \************************************************/
/*! exports provided: getTransferList, getWorkerURL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTransferList", function() { return getTransferList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getWorkerURL", function() { return getWorkerURL; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "../core/src/utils/assert.js");
/* global URL, Blob */


function getTransferList(object, recursive = true, transfers = []) {
  if (!object) {
    // ignore
  } else if (object instanceof ArrayBuffer) {
    transfers.push(object);
  } else if (object.buffer && object.buffer instanceof ArrayBuffer) {
    // Typed array
    transfers.push(object.buffer);
  } else if (recursive && typeof object === 'object') {
    for (const key in object) {
      // Avoid perf hit - only go one level deep
      getTransferList(object[key], recursive, transfers);
    }
  }
  return transfers;
}

const workerURLCache = new Map();

// Creates a URL from worker source that can be used to create `Worker` instances
// Packages (and then caches) the result of `webworkify` as an "Object URL"
function getWorkerURL(workerSource) {
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(typeof workerSource === 'string', 'worker source');

  // url(./worker.js)
  // This pattern is used to differentiate worker urls from worker source code
  // Load from url is needed for testing, when using Webpack & webworker target
  if (workerSource.startsWith('url(') && workerSource.endsWith(')')) {
    return workerSource.match(/^url\((.*)\)$/)[1];
  }

  let workerURL = workerURLCache.get(workerSource);

  if (!workerURL) {
    const blob = new Blob([workerSource], {type: 'application/javascript'});
    // const blob = webworkify(workerSource, {bare: true});
    workerURL = URL.createObjectURL(blob);
    workerURLCache.set(workerSource, workerURL);
  }

  return workerURL;
}


/***/ }),

/***/ "../loader-utils/src/categories/mesh/mesh-utils.js":
/*!*********************************************************!*\
  !*** ../loader-utils/src/categories/mesh/mesh-utils.js ***!
  \*********************************************************/
/*! exports provided: getMeshSize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMeshSize", function() { return getMeshSize; });
function getMeshSize(attributes) {
  let size = 0;
  for (const attributeName in attributes) {
    const attribute = attributes[attributeName];
    if (ArrayBuffer.isView(attribute)) {
      size += attribute.length * attribute.BYTES_PER_ELEMENT;
    }
  }
  return size;
}


/***/ }),

/***/ "../loader-utils/src/index.js":
/*!************************************!*\
  !*** ../loader-utils/src/index.js ***!
  \************************************/
/*! exports provided: createWorker, padTo4Bytes, copyToArray, copyArrayBuffer, copyPaddedArrayBufferToDataView, copyPaddedStringToDataView, padStringToByteAlignment, copyStringToDataView, copyBinaryToDataView, _getMeshSize, assert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _worker_utils_create_worker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-utils/create-worker */ "../loader-utils/src/worker-utils/create-worker.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createWorker", function() { return _worker_utils_create_worker__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _lib_memory_copy_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/memory-copy-utils */ "../loader-utils/src/lib/memory-copy-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "padTo4Bytes", function() { return _lib_memory_copy_utils__WEBPACK_IMPORTED_MODULE_1__["padTo4Bytes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyToArray", function() { return _lib_memory_copy_utils__WEBPACK_IMPORTED_MODULE_1__["copyToArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyArrayBuffer", function() { return _lib_memory_copy_utils__WEBPACK_IMPORTED_MODULE_1__["copyArrayBuffer"]; });

/* harmony import */ var _lib_binary_copy_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/binary-copy-utils */ "../loader-utils/src/lib/binary-copy-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyPaddedArrayBufferToDataView", function() { return _lib_binary_copy_utils__WEBPACK_IMPORTED_MODULE_2__["copyPaddedArrayBufferToDataView"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyPaddedStringToDataView", function() { return _lib_binary_copy_utils__WEBPACK_IMPORTED_MODULE_2__["copyPaddedStringToDataView"]; });

/* harmony import */ var _lib_encode_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/encode-utils */ "../loader-utils/src/lib/encode-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "padStringToByteAlignment", function() { return _lib_encode_utils__WEBPACK_IMPORTED_MODULE_3__["padStringToByteAlignment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyStringToDataView", function() { return _lib_encode_utils__WEBPACK_IMPORTED_MODULE_3__["copyStringToDataView"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyBinaryToDataView", function() { return _lib_encode_utils__WEBPACK_IMPORTED_MODULE_3__["copyBinaryToDataView"]; });

/* harmony import */ var _categories_mesh_mesh_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./categories/mesh/mesh-utils */ "../loader-utils/src/categories/mesh/mesh-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_getMeshSize", function() { return _categories_mesh_mesh_utils__WEBPACK_IMPORTED_MODULE_4__["getMeshSize"]; });

/* harmony import */ var _lib_utils_assert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/utils/assert */ "../loader-utils/src/lib/utils/assert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return _lib_utils_assert__WEBPACK_IMPORTED_MODULE_5__["default"]; });

// WORKER UTILS


// MEMORY COPY UTILS




// MESH CATEGORY UTILS





/***/ }),

/***/ "../loader-utils/src/lib/binary-copy-utils.js":
/*!****************************************************!*\
  !*** ../loader-utils/src/lib/binary-copy-utils.js ***!
  \****************************************************/
/*! exports provided: copyPaddedArrayBufferToDataView, copyPaddedStringToDataView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyPaddedArrayBufferToDataView", function() { return copyPaddedArrayBufferToDataView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyPaddedStringToDataView", function() { return copyPaddedStringToDataView; });
/* harmony import */ var _memory_copy_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./memory-copy-utils */ "../loader-utils/src/lib/memory-copy-utils.js");
/* global TextEncoder */


function copyPaddedArrayBufferToDataView(dataView, byteOffset, sourceBuffer, padding) {
  const paddedLength = Object(_memory_copy_utils__WEBPACK_IMPORTED_MODULE_0__["padTo4Bytes"])(sourceBuffer.byteLength);
  const padLength = paddedLength - sourceBuffer.byteLength;

  if (dataView) {
    // Copy array
    const targetArray = new Uint8Array(
      dataView.buffer,
      dataView.byteOffset + byteOffset,
      sourceBuffer.byteLength
    );
    const sourceArray = new Uint8Array(sourceBuffer);
    targetArray.set(sourceArray);

    // Add PADDING
    for (let i = 0; i < padLength; ++i) {
      // json chunk is padded with spaces (ASCII 0x20)
      dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 0x20);
    }
  }
  byteOffset += paddedLength;
  return byteOffset;
}

function copyPaddedStringToDataView(dataView, byteOffset, string, padding) {
  const textEncoder = new TextEncoder();
  // PERFORMANCE IDEA: We encode twice, once to get size and once to store
  // PERFORMANCE IDEA: Use TextEncoder.encodeInto() to avoid temporary copy
  const stringBuffer = textEncoder.encode(string);

  byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer, padding);

  return byteOffset;
}


/***/ }),

/***/ "../loader-utils/src/lib/encode-utils.js":
/*!***********************************************!*\
  !*** ../loader-utils/src/lib/encode-utils.js ***!
  \***********************************************/
/*! exports provided: padStringToByteAlignment, copyStringToDataView, copyBinaryToDataView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "padStringToByteAlignment", function() { return padStringToByteAlignment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyStringToDataView", function() { return copyStringToDataView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyBinaryToDataView", function() { return copyBinaryToDataView; });
// UTILITIES

// PERFORMANCE IDEA: No need to copy string twice...
function padStringToByteAlignment(string, byteAlignment) {
  const length = string.length;
  const paddedLength = Math.ceil(length / byteAlignment) * byteAlignment; // Round up to the required alignment
  const padding = paddedLength - length;
  let whitespace = '';
  for (let i = 0; i < padding; ++i) {
    whitespace += ' ';
  }
  return string + whitespace;
}

function copyStringToDataView(dataView, byteOffset, string, byteLength) {
  if (dataView) {
    for (let i = 0; i < byteLength; i++) {
      dataView.setUint8(byteOffset + i, string.charCodeAt(i));
    }
  }
  return byteOffset + byteLength;
}

function copyBinaryToDataView(dataView, byteOffset, binary, byteLength) {
  if (dataView) {
    for (let i = 0; i < byteLength; i++) {
      dataView.setUint8(byteOffset + i, binary[i]);
      byteOffset++;
    }
  }
  return byteOffset + byteLength;
}


/***/ }),

/***/ "../loader-utils/src/lib/memory-copy-utils.js":
/*!****************************************************!*\
  !*** ../loader-utils/src/lib/memory-copy-utils.js ***!
  \****************************************************/
/*! exports provided: padTo4Bytes, copyArrayBuffer, copyToArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "padTo4Bytes", function() { return padTo4Bytes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyArrayBuffer", function() { return copyArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyToArray", function() { return copyToArray; });
function padTo4Bytes(byteLength) {
  return (byteLength + 3) & ~3;
}

/* Creates a new Uint8Array based on two different ArrayBuffers
 * @private
 * @param {ArrayBuffers} buffer1 The first buffer.
 * @param {ArrayBuffers} buffer2 The second buffer.
 * @return {ArrayBuffers} The new ArrayBuffer created out of the two.
 */
function copyArrayBuffer(
  targetBuffer,
  sourceBuffer,
  byteOffset,
  byteLength = sourceBuffer.byteLength
) {
  const targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);
  const sourceArray = new Uint8Array(sourceBuffer);
  targetArray.set(sourceArray);
  return targetBuffer;
}

/**
 * Copy from source to target at the targetOffset
 *
 * @param {ArrayBuffer|TypedArray} source - The data to copy
 * @param {TypedArray} target - The destination to copy data into
 * @param {Number} targetOffset - The start offset into target to place the copied data
 *
 * @return {Number} Returns the new offset taking into account proper padding
 */
function copyToArray(source, target, targetOffset) {
  let sourceArray;

  if (source instanceof ArrayBuffer) {
    sourceArray = new Uint8Array(source);
  } else {
    // Pack buffer onto the big target array
    //
    // 'source.data.buffer' could be a view onto a larger buffer.
    // We MUST use this constructor to ensure the byteOffset and byteLength is
    // set to correct values from 'source.data' and not the underlying
    // buffer for target.set() to work properly.
    const srcByteOffset = source.byteOffset;
    const srcByteLength = source.byteLength;
    sourceArray = new Uint8Array(source.buffer, srcByteOffset, srcByteLength);
  }

  // Pack buffer onto the big target array
  target.set(sourceArray, targetOffset);

  return targetOffset + padTo4Bytes(sourceArray.byteLength);
}


/***/ }),

/***/ "../loader-utils/src/lib/utils/assert.js":
/*!***********************************************!*\
  !*** ../loader-utils/src/lib/utils/assert.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
// Replacement for the external assert method to reduce bundle size
// Note: We don't use the second "message" argument in calling code,
// so no need to support it here
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loader assertion failed.');
  }
}


/***/ }),

/***/ "../loader-utils/src/worker-utils/create-worker.js":
/*!*********************************************************!*\
  !*** ../loader-utils/src/worker-utils/create-worker.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createWorker; });
/* harmony import */ var _get_transfer_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-transfer-list */ "../loader-utils/src/worker-utils/get-transfer-list.js");
/* eslint-disable no-restricted-globals */
/* global TextDecoder, self */


// Set up a WebWorkerGlobalScope to talk with the main thread
function createWorker(loader) {
  // TODO - explain when this happens? Just a sanity check? Throw an error or log a warning?
  if (typeof self === 'undefined') {
    return;
  }

  self.onmessage = async evt => {
    const {data} = evt;

    try {
      if (!isKnownMessage(data, loader.name)) {
        return;
      }

      const {arraybuffer, byteOffset = 0, byteLength = 0, options = {}} = data;

      const result = await parseData(loader, arraybuffer, byteOffset, byteLength, options);
      const transferList = Object(_get_transfer_list__WEBPACK_IMPORTED_MODULE_0__["default"])(result);
      self.postMessage({type: 'done', result}, transferList);
    } catch (error) {
      self.postMessage({type: 'error', message: error.message});
    }
  };

  let requestId = 0;
  self.parse = (arraybuffer, options = {}, url) =>
    new Promise((resolve, reject) => {
      const id = requestId++;

      const onMessage = ({data}) => {
        if (!data || data.id !== id) {
          // not ours
          return;
        }
        switch (data.type) {
          case 'process-done':
            self.removeEventListener('message', onMessage);
            resolve(data.result);
            break;

          case 'process-error':
            self.removeEventListener('message', onMessage);
            reject(data.message);
            break;

          default:
          // ignore
        }
      };
      self.addEventListener('message', onMessage);
      // Ask the main thread to decode data
      self.postMessage({type: 'process', id, arraybuffer, options, url}, [arraybuffer]);
    });
}

// TODO - Support byteOffset and byteLength (enabling parsing of embedded binaries without copies)
// TODO - Why not support async loader.parse* funcs here?
// TODO - Why not reuse a common function instead of reimplementing loader.parse* selection logic? Keeping loader small?
// TODO - Lack of appropriate parser functions can be detected when we create worker, no need to wait until parse
async function parseData(loader, arraybuffer, byteOffset, byteLength, options) {
  let data;
  let parser;
  if (loader.parseSync || loader.parse) {
    data = arraybuffer;
    parser = loader.parseSync || loader.parse;
  } else if (loader.parseTextSync) {
    const textDecoder = new TextDecoder();
    data = textDecoder.decode(arraybuffer);
    parser = loader.parseTextSync;
  } else {
    throw new Error(`Could not load data with ${loader.name} loader`);
  }

  return await parser(data, options);
}

// Filter out noise messages sent to workers
function isKnownMessage(data, name) {
  return data && data.type === 'process' && data.source === 'loaders.gl';
}

/*
function checkMessage(evt, name) {
  switch (evt.data && evt.data.source) {
    // Ignore known noise event from react-dev-tools bridge, webpack build progress etc...
    case 'react-devtools-bridge':
    case 'react-devtools-content-script':
    case 'react-devtools-detector':
      return false;
    default:
      // fall through
  }

  switch (evt.data && evt.data.type) {
    case 'webpackProgress':
    case 'webpackOk':
      return false;
    default:
      // Enable to debug messages
      // const message = `${name.toLowerCase()}-worker: ignoring unknown message`;
      // console.log(message, evt.data, evt); // eslint-disable-line
      return false;
  }
}
*/


/***/ }),

/***/ "../loader-utils/src/worker-utils/get-transfer-list.js":
/*!*************************************************************!*\
  !*** ../loader-utils/src/worker-utils/get-transfer-list.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getTransferList; });
// Returns an array of Transferrable objects that can be used with
// postMessage: https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage
function getTransferList(object, recursive = true, transfers) {
  // Make sure that items in the transfer list is unique
  const transfersSet = transfers || new Set();

  if (!object) {
    // ignore
  } else if (object instanceof ArrayBuffer) {
    transfersSet.add(object);
  } else if (object.buffer && object.buffer instanceof ArrayBuffer) {
    // Typed array
    transfersSet.add(object.buffer);
  } else if (recursive && typeof object === 'object') {
    for (const key in object) {
      // Avoid perf hit - only go one level deep
      getTransferList(object[key], recursive, transfersSet);
    }
  }

  // If transfers is defined, is internal recursive call
  // Otherwise it's called by the user
  return transfers === undefined ? Array.from(transfersSet) : null;
}


/***/ }),

/***/ "../math/src/geometry/attributes/compute-vertex-normals.js":
/*!*****************************************************************!*\
  !*** ../math/src/geometry/attributes/compute-vertex-normals.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return computeVertexNormals; });
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ "../math/src/geometry/constants.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/assert */ "../math/src/geometry/utils/assert.js");
/* harmony import */ var _iterators_primitive_iterator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../iterators/primitive-iterator */ "../math/src/geometry/iterators/primitive-iterator.js");
/* harmony import */ var _primitives_modes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../primitives/modes */ "../math/src/geometry/primitives/modes.js");
/* harmony import */ var _get_attribute_from_geometry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./get-attribute-from-geometry */ "../math/src/geometry/attributes/get-attribute-from-geometry.js");







// eslint-disable-next-line max-statements
function computeVertexNormals({mode, indices, attributes}) {
  // Only support GL.TRIANGLES, GL.TRIANGLE_STRIP, GL.TRIANGLE_FAN
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(Object(_primitives_modes__WEBPACK_IMPORTED_MODULE_4__["getPrimitiveModeType"])(mode) === _constants__WEBPACK_IMPORTED_MODULE_1__["GL"].TRIANGLES, 'TRIANGLES required');

  const {values: positions} = Object(_get_attribute_from_geometry__WEBPACK_IMPORTED_MODULE_5__["getPositions"])({mode, indices, attributes});

  const normals = new Float32Array(positions.length);

  const vectorA = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
  const vectorB = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
  const vectorC = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

  const vectorCB = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
  const vectorAB = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

  for (const primitive of Object(_iterators_primitive_iterator__WEBPACK_IMPORTED_MODULE_3__["default"])({mode, indices, attributes})) {
    vectorA.fromArray(positions, primitive.i1 * 3);
    vectorB.fromArray(positions, primitive.i2 * 3 + 3);
    vectorC.fromArray(positions, primitive.i3 * 3 + 6);

    vectorCB.subVectors(vectorC, vectorB);
    vectorAB.subVectors(vectorA, vectorB);
    const normal = vectorCB.cross(vectorAB);
    normal.normalize();

    const {primitiveIndex} = primitive;

    normals[primitiveIndex * 9 + 0] = normal.x;
    normals[primitiveIndex * 9 + 1] = normal.y;
    normals[primitiveIndex * 9 + 2] = normal.z;

    normals[primitiveIndex * 9 + 3] = normal.x;
    normals[primitiveIndex * 9 + 4] = normal.y;
    normals[primitiveIndex * 9 + 5] = normal.z;

    normals[primitiveIndex * 9 + 6] = normal.x;
    normals[primitiveIndex * 9 + 7] = normal.y;
    normals[primitiveIndex * 9 + 8] = normal.z;
  }

  return normals;
}


/***/ }),

/***/ "../math/src/geometry/attributes/get-attribute-from-geometry.js":
/*!**********************************************************************!*\
  !*** ../math/src/geometry/attributes/get-attribute-from-geometry.js ***!
  \**********************************************************************/
/*! exports provided: getPositions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPositions", function() { return getPositions; });
/* harmony import */ var _is_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../is-geometry */ "../math/src/geometry/is-geometry.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/assert */ "../math/src/geometry/utils/assert.js");



function getPositions(geometry) {
  // If geometry, extract positions
  if (Object(_is_geometry__WEBPACK_IMPORTED_MODULE_0__["default"])(geometry)) {
    const {attributes} = geometry;
    const position = attributes.POSITION || attributes.positions;
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(position);
    return position;
  }

  // If arraybuffer, assume 3 components
  if (ArrayBuffer.isView(geometry)) {
    return {values: geometry, size: 3};
  }

  // Else assume accessor object
  if (geometry) {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(geometry.values);
    return geometry;
  }

  return Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(false);
}


/***/ }),

/***/ "../math/src/geometry/colors/rgb565.js":
/*!*********************************************!*\
  !*** ../math/src/geometry/colors/rgb565.js ***!
  \*********************************************/
/*! exports provided: decodeRGB565, encodeRGB565 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeRGB565", function() { return decodeRGB565; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeRGB565", function() { return encodeRGB565; });
function decodeRGB565(rgb565, target = [0, 0, 0]) {
  const r5 = (rgb565 >> 11) & 31;
  const g6 = (rgb565 >> 5) & 63;
  const b5 = rgb565 & 31;

  target[0] = r5 << 3;
  target[1] = g6 << 2;
  target[2] = b5 << 3;

  return target;
}

function encodeRGB565(rgb) {
  const r5 = Math.floor(rgb[0] / 8) + 4;
  const g6 = Math.floor(rgb[1] / 4) + 2;
  const b5 = Math.floor(rgb[2] / 8) + 4;
  return r5 + (g6 << 5) + (b5 << 11);
}


/***/ }),

/***/ "../math/src/geometry/compression/attribute-compression.js":
/*!*****************************************************************!*\
  !*** ../math/src/geometry/compression/attribute-compression.js ***!
  \*****************************************************************/
/*! exports provided: octEncodeInRange, octEncode, octEncodeToVector4, octDecodeInRange, octDecode, octDecodeFromVector4, octPackFloat, octEncodeFloat, octDecodeFloat, octPack, octUnpack, compressTextureCoordinates, decompressTextureCoordinates, zigZagDeltaDecode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "octEncodeInRange", function() { return octEncodeInRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "octEncode", function() { return octEncode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "octEncodeToVector4", function() { return octEncodeToVector4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "octDecodeInRange", function() { return octDecodeInRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "octDecode", function() { return octDecode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "octDecodeFromVector4", function() { return octDecodeFromVector4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "octPackFloat", function() { return octPackFloat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "octEncodeFloat", function() { return octEncodeFloat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "octDecodeFloat", function() { return octDecodeFloat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "octPack", function() { return octPack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "octUnpack", function() { return octUnpack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compressTextureCoordinates", function() { return compressTextureCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decompressTextureCoordinates", function() { return decompressTextureCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zigZagDeltaDecode", function() { return zigZagDeltaDecode; });
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/assert */ "../math/src/geometry/utils/assert.js");
// Attribute compression and decompression functions.

// This file is derived from the Cesium code base under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md




const RIGHT_SHIFT = 1.0 / 256.0;
const LEFT_SHIFT = 256.0;

const scratchVector2 = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();
const scratchVector3 = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const scratchEncodeVector2 = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();
const octEncodeScratch = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();

const uint8ForceArray = new Uint8Array(1);

// Force a value to Uint8
function forceUint8(value) {
  uint8ForceArray[0] = value;
  return uint8ForceArray[0];
}

/**
 * Converts a SNORM value in the range [0, rangeMaximum] to a scalar in the range [-1.0, 1.0].
 * @param {Number} value SNORM value in the range [0, rangeMaximum]
 * @param {Number} [rangeMaximum=255] The maximum value in the SNORM range, 255 by default.
 * @returns {Number} Scalar in the range [-1.0, 1.0].
 *
 * @see CesiumMath.toSNorm
 */
function fromSNorm(value, rangeMaximum = 255) {
  return (Object(math_gl__WEBPACK_IMPORTED_MODULE_0__["clamp"])(value, 0.0, rangeMaximum) / rangeMaximum) * 2.0 - 1.0;
}

/**
 * Converts a scalar value in the range [-1.0, 1.0] to a SNORM in the range [0, rangeMaximum]
 * @param {Number} value The scalar value in the range [-1.0, 1.0]
 * @param {Number} [rangeMaximum=255] The maximum value in the mapped range, 255 by default.
 * @returns {Number} A SNORM value, where 0 maps to -1.0 and rangeMaximum maps to 1.0.
 *
 * @see CesiumMath.fromSNorm
 */
function toSNorm(value, rangeMaximum = 255) {
  return Math.round((Object(math_gl__WEBPACK_IMPORTED_MODULE_0__["clamp"])(value, -1.0, 1.0) * 0.5 + 0.5) * rangeMaximum);
}

/**
 * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.
 * This is similar to `Math.sign` except that returns 1.0 instead of
 * 0.0 when the input value is 0.0.
 * @param {Number} value The value to return the sign of.
 * @returns {Number} The sign of value.
 */
function signNotZero(value) {
  return value < 0.0 ? -1.0 : 1.0;
}

/**
 * Encodes a normalized vector into 2 SNORM values in the range of [0-rangeMax] following the 'oct' encoding.
 *
 * Oct encoding is a compact representation of unit length vectors.
 * The 'oct' encoding is described in "A Survey of Efficient Representations of Independent Unit Vectors",
 * Cigolle et al 2014: {@link http://jcgt.org/published/0003/02/01/}
 *
 * @param {Vector3} vector The normalized vector to be compressed into 2 component 'oct' encoding.
 * @param {Vector2} result The 2 component oct-encoded unit length vector.
 * @param {Number} rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.
 * @returns {Vector2} The 2 component oct-encoded unit length vector.
 *
 * @exception {Error} vector must be normalized.
 *
 * @see octDecodeInRange
 */
function octEncodeInRange(vector, rangeMax, result) {
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(vector);
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(result);

  const vector3 = scratchVector3.from(vector);

  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(Math.abs(vector3.magnitudeSquared() - 1.0) <= math_gl__WEBPACK_IMPORTED_MODULE_0__["_MathUtils"].EPSILON6);

  result.x = vector.x / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));
  result.y = vector.y / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));

  if (vector.z < 0) {
    const x = result.x;
    const y = result.y;
    result.x = (1.0 - Math.abs(y)) * signNotZero(x);
    result.y = (1.0 - Math.abs(x)) * signNotZero(y);
  }

  result.x = toSNorm(result.x, rangeMax);
  result.y = toSNorm(result.y, rangeMax);

  return result;
}

/**
 * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding.
 *
 * @param {Vector3} vector The normalized vector to be compressed into 2 byte 'oct' encoding.
 * @param {Vector2} result The 2 byte oct-encoded unit length vector.
 * @returns {Vector2} The 2 byte oct-encoded unit length vector.
 *
 * @exception {Error} vector must be normalized.
 *
 * @see octEncodeInRange
 * @see octDecode
 */
function octEncode(vector, result) {
  return octEncodeInRange(vector, 255, result);
}

/**
 * @param {Vector3} vector The normalized vector to be compressed into 4 byte 'oct' encoding.
 * @param {Vector4} result The 4 byte oct-encoded unit length vector.
 * @returns {Vector4} The 4 byte oct-encoded unit length vector.
 *
 * @exception {Error} vector must be normalized.
 *
 * @see octEncodeInRange
 * @see octDecodeFromVector4
 */
function octEncodeToVector4(vector, result) {
  octEncodeInRange(vector, 65535, octEncodeScratch);
  result.x = forceUint8(octEncodeScratch.x * RIGHT_SHIFT);
  result.y = forceUint8(octEncodeScratch.x);
  result.z = forceUint8(octEncodeScratch.y * RIGHT_SHIFT);
  result.w = forceUint8(octEncodeScratch.y);
  return result;
}

/**
 * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component vector.
 *
 * @param {Number} x The x component of the oct-encoded unit length vector.
 * @param {Number} y The y component of the oct-encoded unit length vector.
 * @param {Number} rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.
 * @param {Vector3} result The decoded and normalized vector
 * @returns {Vector3} The decoded and normalized vector.
 *
 * @exception {Error} x and y must be unsigned normalized integers between 0 and rangeMax.
 *
 * @see octEncodeInRange
 */
function octDecodeInRange(x, y, rangeMax, result) {
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(result);
  if (x < 0 || x > rangeMax || y < 0 || y > rangeMax) {
    throw new Error(`x and y must be unsigned normalized integers between 0 and ${rangeMax}`);
  }

  result.x = fromSNorm(x, rangeMax);
  result.y = fromSNorm(y, rangeMax);
  result.z = 1.0 - (Math.abs(result.x) + Math.abs(result.y));

  if (result.z < 0.0) {
    const oldVX = result.x;
    result.x = (1.0 - Math.abs(result.y)) * signNotZero(oldVX);
    result.y = (1.0 - Math.abs(oldVX)) * signNotZero(result.y);
  }

  return result.normalize();
}

/**
 * Decodes a unit-length vector in 2 byte 'oct' encoding to a normalized 3-component vector.
 *
 * @param {Number} x The x component of the oct-encoded unit length vector.
 * @param {Number} y The y component of the oct-encoded unit length vector.
 * @param {Vector3} result The decoded and normalized vector.
 * @returns {Vector3} The decoded and normalized vector.
 *
 * @exception {Error} x and y must be an unsigned normalized integer between 0 and 255.
 *
 * @see octDecodeInRange
 */
function octDecode(x, y, result) {
  return octDecodeInRange(x, y, 255, result);
}

/**
 * Decodes a unit-length vector in 4 byte 'oct' encoding to a normalized 3-component vector.
 *
 * @param {Vector4} encoded The oct-encoded unit length vector.
 * @param {Vector3} result The decoded and normalized vector.
 * @returns {Vector3} The decoded and normalized vector.
 *
 * @exception {Error} x, y, z, and w must be unsigned normalized integers between 0 and 255.
 *
 * @see octDecodeInRange
 * @see octEncodeToVector4
 */
function octDecodeFromVector4(encoded, result) {
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(encoded);
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(result);
  const x = encoded.x;
  const y = encoded.y;
  const z = encoded.z;
  const w = encoded.w;
  if (x < 0 || x > 255 || y < 0 || y > 255 || z < 0 || z > 255 || w < 0 || w > 255) {
    throw new Error('x, y, z, and w must be unsigned normalized integers between 0 and 255');
  }

  const xOct16 = x * LEFT_SHIFT + y;
  const yOct16 = z * LEFT_SHIFT + w;
  return octDecodeInRange(xOct16, yOct16, 65535, result);
}

/**
 * Packs an oct encoded vector into a single floating-point number.
 *
 * @param {Vector2} encoded The oct encoded vector.
 * @returns {Number} The oct encoded vector packed into a single float.
 *
 */
function octPackFloat(encoded) {
  const vector2 = scratchVector2.from(encoded);
  return 256.0 * vector2.x + vector2.y;
}

/**
 * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding and
 * stores those values in a single float-point number.
 *
 * @param {Vector3} vector The normalized vector to be compressed into 2 byte 'oct' encoding.
 * @returns {Number} The 2 byte oct-encoded unit length vector.
 *
 * @exception {Error} vector must be normalized.
 */
function octEncodeFloat(vector) {
  octEncode(vector, scratchEncodeVector2);
  return octPackFloat(scratchEncodeVector2);
}

/**
 * Decodes a unit-length vector in 'oct' encoding packed in a floating-point number to a normalized 3-component vector.
 *
 * @param {Number} value The oct-encoded unit length vector stored as a single floating-point number.
 * @param {Vector3} result The decoded and normalized vector
 * @returns {Vector3} The decoded and normalized vector.
 *
 */
function octDecodeFloat(value, result) {
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(Number.isFinite(value));

  const temp = value / 256.0;
  const x = Math.floor(temp);
  const y = (temp - x) * 256.0;

  return octDecode(x, y, result);
}

/**
 * Encodes three normalized vectors into 6 SNORM values in the range of [0-255] following the 'oct' encoding and
 * packs those into two floating-point numbers.
 *
 * @param {Vector3} v1 A normalized vector to be compressed.
 * @param {Vector3} v2 A normalized vector to be compressed.
 * @param {Vector3} v3 A normalized vector to be compressed.
 * @param {Vector2} result The 'oct' encoded vectors packed into two floating-point numbers.
 * @returns {Vector2} The 'oct' encoded vectors packed into two floating-point numbers.
 *
 */
function octPack(v1, v2, v3, result) {
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(v1);
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(v2);
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(v3);
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(result);

  const encoded1 = octEncodeFloat(v1);
  const encoded2 = octEncodeFloat(v2);

  const encoded3 = octEncode(v3, scratchEncodeVector2);
  result.x = 65536.0 * encoded3.x + encoded1;
  result.y = 65536.0 * encoded3.y + encoded2;
  return result;
}

/**
 * Decodes three unit-length vectors in 'oct' encoding packed into a floating-point number to a normalized 3-component vector.
 *
 * @param {Vector2} packed The three oct-encoded unit length vectors stored as two floating-point number.
 * @param {Vector3} v1 One decoded and normalized vector.
 * @param {Vector3} v2 One decoded and normalized vector.
 * @param {Vector3} v3 One decoded and normalized vector.
 */
function octUnpack(packed, v1, v2, v3) {
  let temp = packed.x / 65536.0;
  const x = Math.floor(temp);
  const encodedFloat1 = (temp - x) * 65536.0;

  temp = packed.y / 65536.0;
  const y = Math.floor(temp);
  const encodedFloat2 = (temp - y) * 65536.0;

  octDecodeFloat(encodedFloat1, v1);
  octDecodeFloat(encodedFloat2, v2);
  octDecode(x, y, v3);
}

/**
 * Pack texture coordinates into a single float. The texture coordinates will only preserve 12 bits of precision.
 *
 * @param {Vector2} textureCoordinates The texture coordinates to compress.  Both coordinates must be in the range 0.0-1.0.
 * @returns {Number} The packed texture coordinates.
 *
 */
function compressTextureCoordinates(textureCoordinates) {
  // Move x and y to the range 0-4095;
  const x = (textureCoordinates.x * 4095.0) | 0;
  const y = (textureCoordinates.y * 4095.0) | 0;
  return 4096.0 * x + y;
}

/**
 * Decompresses texture coordinates that were packed into a single float.
 *
 * @param {Number} compressed The compressed texture coordinates.
 * @param {Vector2} result The decompressed texture coordinates.
 * @returns {Vector2} The modified result parameter.
 *
 */
function decompressTextureCoordinates(compressed, result) {
  const temp = compressed / 4096.0;
  const xZeroTo4095 = Math.floor(temp);
  result.x = xZeroTo4095 / 4095.0;
  result.y = (compressed - xZeroTo4095 * 4096) / 4095;
  return result;
}

/**
 * Decodes delta and ZigZag encoded vertices. This modifies the buffers in place.
 *
 * @param {Uint16Array} uBuffer The buffer view of u values.
 * @param {Uint16Array} vBuffer The buffer view of v values.
 * @param {Uint16Array} [heightBuffer] The buffer view of height values.
 *
 * @see {@link https://github.com/AnalyticalGraphicsInc/quantized-mesh|quantized-mesh-1.0 terrain format}
 */
function zigZagDeltaDecode(uBuffer, vBuffer, heightBuffer) {
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(uBuffer);
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(vBuffer);
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(uBuffer.length === vBuffer.length);
  if (heightBuffer) {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(uBuffer.length === heightBuffer.length);
  }

  function zigZagDecode(value) {
    return (value >> 1) ^ -(value & 1);
  }

  let u = 0;
  let v = 0;
  let height = 0;

  for (let i = 0; i < uBuffer.length; ++i) {
    u += zigZagDecode(uBuffer[i]);
    v += zigZagDecode(vBuffer[i]);

    uBuffer[i] = u;
    vBuffer[i] = v;

    if (heightBuffer) {
      height += zigZagDecode(heightBuffer[i]);
      heightBuffer[i] = height;
    }
  }
}


/***/ }),

/***/ "../math/src/geometry/constants.js":
/*!*****************************************!*\
  !*** ../math/src/geometry/constants.js ***!
  \*****************************************/
/*! exports provided: GL_PRIMITIVE, GL_PRIMITIVE_MODE, GL_TYPE, GL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GL_PRIMITIVE", function() { return GL_PRIMITIVE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GL_PRIMITIVE_MODE", function() { return GL_PRIMITIVE_MODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GL_TYPE", function() { return GL_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GL", function() { return GL; });
// Subset of WebGL constants

const GL_PRIMITIVE = {
  POINTS: 0x0000, // Points. single points.
  LINES: 0x0001, // Lines. Each vertex connects to the one after it.
  TRIANGLES: 0x0004 // Triangles. Each set of three vertices creates a separate triangle.
};

// Primitive modes
const GL_PRIMITIVE_MODE = {
  POINTS: 0x0000, // Points. single points.
  LINES: 0x0001, // Lines. Each vertex connects to the one after it.
  LINE_LOOP: 0x0002, // Lines. Each set of two vertices is treated as a separate line segment.
  LINE_STRIP: 0x0003, // Lines/ a connected group of line segments from the first vertex to the last
  TRIANGLES: 0x0004, // Triangles. Each set of three vertices creates a separate triangle.
  TRIANGLE_STRIP: 0x0005, // Triangles. A connected group of triangles.
  TRIANGLE_FAN: 0x0006 // Triangles. A connected group of triangles.
  // Each vertex connects to the previous and the first vertex in the fan.
};

const GL_TYPE = {
  BYTE: 5120,
  UNSIGNED_BYTE: 5121,
  SHORT: 5122,
  UNSIGNED_SHORT: 5123,
  INT: 5124,
  UNSIGNED_INT: 5125,
  FLOAT: 5126,
  DOUBLE: 5130
};

const GL = {
  ...GL_PRIMITIVE_MODE,
  ...GL_TYPE
};


/***/ }),

/***/ "../math/src/geometry/gl/gl-type.js":
/*!******************************************!*\
  !*** ../math/src/geometry/gl/gl-type.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GLType; });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants */ "../math/src/geometry/constants.js");


const GL_TYPE_TO_ARRAY_TYPE = {
  [_constants__WEBPACK_IMPORTED_MODULE_0__["GL_TYPE"].DOUBLE]: Float64Array,
  [_constants__WEBPACK_IMPORTED_MODULE_0__["GL_TYPE"].FLOAT]: Float32Array,
  [_constants__WEBPACK_IMPORTED_MODULE_0__["GL_TYPE"].UNSIGNED_SHORT]: Uint16Array,
  [_constants__WEBPACK_IMPORTED_MODULE_0__["GL_TYPE"].UNSIGNED_INT]: Uint32Array,
  [_constants__WEBPACK_IMPORTED_MODULE_0__["GL_TYPE"].UNSIGNED_BYTE]: Uint8Array,
  [_constants__WEBPACK_IMPORTED_MODULE_0__["GL_TYPE"].BYTE]: Int8Array,
  [_constants__WEBPACK_IMPORTED_MODULE_0__["GL_TYPE"].SHORT]: Int16Array,
  [_constants__WEBPACK_IMPORTED_MODULE_0__["GL_TYPE"].INT]: Int32Array
};

const NAME_TO_GL_TYPE = {
  DOUBLE: _constants__WEBPACK_IMPORTED_MODULE_0__["GL_TYPE"].DOUBLE,
  FLOAT: _constants__WEBPACK_IMPORTED_MODULE_0__["GL_TYPE"].FLOAT,
  UNSIGNED_SHORT: _constants__WEBPACK_IMPORTED_MODULE_0__["GL_TYPE"].UNSIGNED_SHORT,
  UNSIGNED_INT: _constants__WEBPACK_IMPORTED_MODULE_0__["GL_TYPE"].UNSIGNED_INT,
  UNSIGNED_BYTE: _constants__WEBPACK_IMPORTED_MODULE_0__["GL_TYPE"].UNSIGNED_BYTE,
  BYTE: _constants__WEBPACK_IMPORTED_MODULE_0__["GL_TYPE"].BYTE,
  SHORT: _constants__WEBPACK_IMPORTED_MODULE_0__["GL_TYPE"].SHORT,
  INT: _constants__WEBPACK_IMPORTED_MODULE_0__["GL_TYPE"].INT
};

const ERR_TYPE_CONVERSION = 'Failed to convert GL type';

// Converts TYPED ARRAYS to corresponding GL constant
// Used to auto deduce gl parameter types
class GLType {
  // Signature: fromTypedArray(new Uint8Array())
  // Signature: fromTypedArray(Uint8Array)
  static fromTypedArray(arrayOrType) {
    // If typed array, look up constructor
    arrayOrType = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
    for (const glType in GL_TYPE_TO_ARRAY_TYPE) {
      const ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];
      if (ArrayType === arrayOrType) {
        return glType;
      }
    }
    throw new Error(ERR_TYPE_CONVERSION);
  }

  static fromName(name) {
    const glType = NAME_TO_GL_TYPE[name];
    if (!glType) {
      throw new Error(ERR_TYPE_CONVERSION);
    }
    return glType;
  }

  // Converts GL constant to corresponding typed array type
  // eslint-disable-next-line complexity
  static getArrayType(glType, clamped = false) {
    switch (glType) {
      case _constants__WEBPACK_IMPORTED_MODULE_0__["GL_TYPE"].UNSIGNED_SHORT_5_6_5:
      case _constants__WEBPACK_IMPORTED_MODULE_0__["GL_TYPE"].UNSIGNED_SHORT_4_4_4_4:
      case _constants__WEBPACK_IMPORTED_MODULE_0__["GL_TYPE"].UNSIGNED_SHORT_5_5_5_1:
        return Uint16Array;

      default:
        const ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];
        if (!ArrayType) {
          throw new Error(ERR_TYPE_CONVERSION);
        }
        return ArrayType;
    }
  }

  static getByteSize(glType) {
    const ArrayType = GLType.getArrayType(glType);
    return ArrayType.BYTES_PER_ELEMENT;
  }

  static validate(glType) {
    return Boolean(GLType.getArrayType(glType));
  }

  static createTypedArray(glType, buffer, byteOffset = 0, length) {
    if (length === undefined) {
      length = (buffer.byteLength - byteOffset) / GLType.getByteSize(glType);
    }

    const ArrayType = GLType.getArrayType(glType);

    return new ArrayType(buffer, byteOffset, length);
  }
}


/***/ }),

/***/ "../math/src/geometry/index.js":
/*!*************************************!*\
  !*** ../math/src/geometry/index.js ***!
  \*************************************/
/*! exports provided: GL, GL_TYPE, GLType, isGeometry, attributeIterator, primitiveIterator, computeVertexNormals, encodeRGB565, decodeRGB565, concatTypedArrays, octEncodeInRange, octEncode, octEncodeToVector4, octDecodeInRange, octDecode, octDecodeFromVector4, octPackFloat, octEncodeFloat, octDecodeFloat, octPack, octUnpack, compressTextureCoordinates, decompressTextureCoordinates, zigZagDeltaDecode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "../math/src/geometry/constants.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GL", function() { return _constants__WEBPACK_IMPORTED_MODULE_0__["GL"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GL_TYPE", function() { return _constants__WEBPACK_IMPORTED_MODULE_0__["GL_TYPE"]; });

/* harmony import */ var _gl_gl_type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gl/gl-type */ "../math/src/geometry/gl/gl-type.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLType", function() { return _gl_gl_type__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _is_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./is-geometry */ "../math/src/geometry/is-geometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isGeometry", function() { return _is_geometry__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _iterators_attribute_iterator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./iterators/attribute-iterator */ "../math/src/geometry/iterators/attribute-iterator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "attributeIterator", function() { return _iterators_attribute_iterator__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _iterators_primitive_iterator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./iterators/primitive-iterator */ "../math/src/geometry/iterators/primitive-iterator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "primitiveIterator", function() { return _iterators_primitive_iterator__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _attributes_compute_vertex_normals__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./attributes/compute-vertex-normals */ "../math/src/geometry/attributes/compute-vertex-normals.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "computeVertexNormals", function() { return _attributes_compute_vertex_normals__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _colors_rgb565__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./colors/rgb565 */ "../math/src/geometry/colors/rgb565.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "encodeRGB565", function() { return _colors_rgb565__WEBPACK_IMPORTED_MODULE_6__["encodeRGB565"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "decodeRGB565", function() { return _colors_rgb565__WEBPACK_IMPORTED_MODULE_6__["decodeRGB565"]; });

/* harmony import */ var _typed_arrays_typed_array_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./typed-arrays/typed-array-utils */ "../math/src/geometry/typed-arrays/typed-array-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concatTypedArrays", function() { return _typed_arrays_typed_array_utils__WEBPACK_IMPORTED_MODULE_7__["concatTypedArrays"]; });

/* harmony import */ var _compression_attribute_compression__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./compression/attribute-compression */ "../math/src/geometry/compression/attribute-compression.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "octEncodeInRange", function() { return _compression_attribute_compression__WEBPACK_IMPORTED_MODULE_8__["octEncodeInRange"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "octEncode", function() { return _compression_attribute_compression__WEBPACK_IMPORTED_MODULE_8__["octEncode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "octEncodeToVector4", function() { return _compression_attribute_compression__WEBPACK_IMPORTED_MODULE_8__["octEncodeToVector4"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "octDecodeInRange", function() { return _compression_attribute_compression__WEBPACK_IMPORTED_MODULE_8__["octDecodeInRange"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "octDecode", function() { return _compression_attribute_compression__WEBPACK_IMPORTED_MODULE_8__["octDecode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "octDecodeFromVector4", function() { return _compression_attribute_compression__WEBPACK_IMPORTED_MODULE_8__["octDecodeFromVector4"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "octPackFloat", function() { return _compression_attribute_compression__WEBPACK_IMPORTED_MODULE_8__["octPackFloat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "octEncodeFloat", function() { return _compression_attribute_compression__WEBPACK_IMPORTED_MODULE_8__["octEncodeFloat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "octDecodeFloat", function() { return _compression_attribute_compression__WEBPACK_IMPORTED_MODULE_8__["octDecodeFloat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "octPack", function() { return _compression_attribute_compression__WEBPACK_IMPORTED_MODULE_8__["octPack"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "octUnpack", function() { return _compression_attribute_compression__WEBPACK_IMPORTED_MODULE_8__["octUnpack"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "compressTextureCoordinates", function() { return _compression_attribute_compression__WEBPACK_IMPORTED_MODULE_8__["compressTextureCoordinates"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "decompressTextureCoordinates", function() { return _compression_attribute_compression__WEBPACK_IMPORTED_MODULE_8__["decompressTextureCoordinates"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zigZagDeltaDecode", function() { return _compression_attribute_compression__WEBPACK_IMPORTED_MODULE_8__["zigZagDeltaDecode"]; });



// GL support



// Geometry


// Iterators



// Helper methods




// Typed array utils


// Compression



/***/ }),

/***/ "../math/src/geometry/is-geometry.js":
/*!*******************************************!*\
  !*** ../math/src/geometry/is-geometry.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isGeometry; });
function isGeometry(geometry) {
  return (
    geometry &&
    typeof geometry === 'object' &&
    geometry.mode &&
    geometry.attributes &&
    typeof geometry.attributes === 'object'
  );
}


/***/ }),

/***/ "../math/src/geometry/iterators/attribute-iterator.js":
/*!************************************************************!*\
  !*** ../math/src/geometry/iterators/attribute-iterator.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return attributeIterator; });
// Iterates over a single attribute
// NOTE: creates and re-yields a single element

function* attributeIterator({values, size}) {
  const ArrayType = values.constructor;
  const element = new ArrayType(size);
  for (let i = 0; i < values.length; i += size) {
    for (let j = 0; j < size; j++) {
      element[j] = element[i + j];
    }
    yield element;
  }
}


/***/ }),

/***/ "../math/src/geometry/iterators/primitive-iterator.js":
/*!************************************************************!*\
  !*** ../math/src/geometry/iterators/primitive-iterator.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return primitiveIterator; });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants */ "../math/src/geometry/constants.js");
/* harmony import */ var _primitives_modes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../primitives/modes */ "../math/src/geometry/primitives/modes.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/assert */ "../math/src/utils/assert.js");




// Will iterate over each primitive, expanding (dereferencing) indices
// eslint-disable-next-line complexity
function* primitiveIterator({indices, attributes, mode, start = 0, end}) {
  // support indices being an object with a values array
  if (indices) {
    indices = indices.values || indices.value || indices;
  }

  // Autodeduce length from indices
  if (end === undefined) {
    if (indices) {
      end = indices.length;
    }
  }

  // iteration info
  const info = {
    attributes,
    type: Object(_primitives_modes__WEBPACK_IMPORTED_MODULE_1__["getPrimitiveModeType"])(mode)
  };

  let i = start;
  while (i < end) {
    switch (mode) {
      case _constants__WEBPACK_IMPORTED_MODULE_0__["GL"].POINTS: // draw single points.
        info.i1 = i;
        i += 1;
        break;
      case _constants__WEBPACK_IMPORTED_MODULE_0__["GL"].LINES: // draw lines. Each set of two vertices is treated as a separate line segment.
        info.i1 = i;
        info.i2 = i + 1;
        i += 2;
        break;
      case _constants__WEBPACK_IMPORTED_MODULE_0__["GL"].LINE_STRIP: // draw lines. Each vertex connects to the one after it.
        info.i1 = i;
        info.i2 = i + 1;
        i += 1;
        break;
      case _constants__WEBPACK_IMPORTED_MODULE_0__["GL"].LINE_LOOP: // draw a connected group of line segments from the first vertex to the last
        info.i1 = i;
        info.i2 = i + 1;
        i += 1;
        break;
      case _constants__WEBPACK_IMPORTED_MODULE_0__["GL"].TRIANGLES: // draw triangles. Each set of three vertices creates a separate triangle.
        info.i1 = i;
        info.i2 = i + 1;
        info.i3 = i + 2;
        i += 3;
        break;
      case _constants__WEBPACK_IMPORTED_MODULE_0__["GL"].TRIANGLE_STRIP: // draw a connected group of triangles.
        info.i1 = i;
        info.i2 = i + 1;
        i += 1;
        break;
      case _constants__WEBPACK_IMPORTED_MODULE_0__["GL"].TRIANGLE_FAN: // draw a connected group of triangles.
        info.i1 = 1;
        info.i2 = i;
        info.i2 = i + 1;
        i += 1;
        break;

      default:
        Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(false);
    }

    // if indices are present, lookup actual vertices in indices
    if (indices) {
      if ('i1' in info) {
        info.i1 = indices[info.i1];
        info.i2 = indices[info.i2];
        info.i3 = indices[info.i3];
      }
    }

    yield info;
  }
}


/***/ }),

/***/ "../math/src/geometry/primitives/modes.js":
/*!************************************************!*\
  !*** ../math/src/geometry/primitives/modes.js ***!
  \************************************************/
/*! exports provided: getPrimitiveModeType, isPrimitiveModeExpandable, getPrimitiveModeExpandedLength */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPrimitiveModeType", function() { return getPrimitiveModeType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPrimitiveModeExpandable", function() { return isPrimitiveModeExpandable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPrimitiveModeExpandedLength", function() { return getPrimitiveModeExpandedLength; });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants */ "../math/src/geometry/constants.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/assert */ "../math/src/geometry/utils/assert.js");



function getPrimitiveModeType(mode) {
  switch (mode) {
    case _constants__WEBPACK_IMPORTED_MODULE_0__["GL"].POINTS: // draw single points.
      return _constants__WEBPACK_IMPORTED_MODULE_0__["GL"].POINTS;
    case _constants__WEBPACK_IMPORTED_MODULE_0__["GL"].LINES: // draw lines. Each set of two vertices is treated as a separate line segment.
    case _constants__WEBPACK_IMPORTED_MODULE_0__["GL"].LINE_STRIP: // draw lines. Each vertex connects to the one after it.
    case _constants__WEBPACK_IMPORTED_MODULE_0__["GL"].LINE_LOOP: // draw a connected group of line segments from the first vertex to the last
      return _constants__WEBPACK_IMPORTED_MODULE_0__["GL"].LINES;
    case _constants__WEBPACK_IMPORTED_MODULE_0__["GL"].TRIANGLES:
    case _constants__WEBPACK_IMPORTED_MODULE_0__["GL"].TRIANGLE_STRIP:
    case _constants__WEBPACK_IMPORTED_MODULE_0__["GL"].TRIANGLE_FAN: // draw a connected group of triangles.
      return _constants__WEBPACK_IMPORTED_MODULE_0__["GL"].TRIANGLES;
    default:
      return Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(false);
  }
}

function isPrimitiveModeExpandable(mode) {
  switch (mode) {
    case _constants__WEBPACK_IMPORTED_MODULE_0__["GL"].LINE_STRIP: // draw lines. Each vertex connects to the one after it.
    case _constants__WEBPACK_IMPORTED_MODULE_0__["GL"].LINE_LOOP: // draw a connected group of line segments from the first vertex to the last
    case _constants__WEBPACK_IMPORTED_MODULE_0__["GL"].TRIANGLE_STRIP: // draw a connected group of triangles.
    case _constants__WEBPACK_IMPORTED_MODULE_0__["GL"].TRIANGLE_FAN: // draw a connected group of triangles.
      return true;
    default:
      return false;
  }
}

function getPrimitiveModeExpandedLength(mode, length) {
  switch (mode) {
    case _constants__WEBPACK_IMPORTED_MODULE_0__["GL"].POINTS: // draw single points.
      return length;
    case _constants__WEBPACK_IMPORTED_MODULE_0__["GL"].LINES: // draw lines. Each set of two vertices is treated as a separate line segment.
      return length;
    case _constants__WEBPACK_IMPORTED_MODULE_0__["GL"].LINE_STRIP: // draw lines. Each vertex connects to the one after it.
      return length;
    case _constants__WEBPACK_IMPORTED_MODULE_0__["GL"].LINE_LOOP: // draw a connected group of line segments from the first vertex to the last
      return length + 1;
    case _constants__WEBPACK_IMPORTED_MODULE_0__["GL"].TRIANGLES: // draw triangles. Each set of three vertices creates a separate triangle.
      return length;
    case _constants__WEBPACK_IMPORTED_MODULE_0__["GL"].TRIANGLE_STRIP: // draw a connected group of triangles.
    case _constants__WEBPACK_IMPORTED_MODULE_0__["GL"].TRIANGLE_FAN: // draw a connected group of triangles.
      return (length - 2) * 3;
    default:
      return Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(false);
  }
}


/***/ }),

/***/ "../math/src/geometry/typed-arrays/typed-array-utils.js":
/*!**************************************************************!*\
  !*** ../math/src/geometry/typed-arrays/typed-array-utils.js ***!
  \**************************************************************/
/*! exports provided: concatTypedArrays */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concatTypedArrays", function() { return concatTypedArrays; });
function concatTypedArrays(arrays) {
  let byteLength = 0;
  for (let i = 0; i < arrays.length; ++i) {
    byteLength += arrays[i].byteLength;
  }
  const buffer = new Uint8Array(byteLength);

  let byteOffset = 0;
  for (let i = 0; i < arrays.length; ++i) {
    const data = new Uint8Array(arrays[i].buffer);
    byteLength = data.length;
    for (let j = 0; j < byteLength; ++j) {
      buffer[byteOffset++] = data[j];
    }
  }
  return buffer;
}


/***/ }),

/***/ "../math/src/geometry/utils/assert.js":
/*!********************************************!*\
  !*** ../math/src/geometry/utils/assert.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
function assert(condition, message) {
  if (!condition) {
    throw new Error(`math.gl assertion failed. ${message}`);
  }
}


/***/ }),

/***/ "../math/src/index.js":
/*!****************************!*\
  !*** ../math/src/index.js ***!
  \****************************/
/*! exports provided: GL, GL_TYPE, GLType, isGeometry, attributeIterator, primitiveIterator, computeVertexNormals, encodeRGB565, decodeRGB565, concatTypedArrays, octEncodeInRange, octEncode, octEncodeToVector4, octDecodeInRange, octDecode, octDecodeFromVector4, octPackFloat, octEncodeFloat, octDecodeFloat, octPack, octUnpack, compressTextureCoordinates, decompressTextureCoordinates, zigZagDeltaDecode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geometry */ "../math/src/geometry/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GL", function() { return _geometry__WEBPACK_IMPORTED_MODULE_0__["GL"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GL_TYPE", function() { return _geometry__WEBPACK_IMPORTED_MODULE_0__["GL_TYPE"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLType", function() { return _geometry__WEBPACK_IMPORTED_MODULE_0__["GLType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isGeometry", function() { return _geometry__WEBPACK_IMPORTED_MODULE_0__["isGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "attributeIterator", function() { return _geometry__WEBPACK_IMPORTED_MODULE_0__["attributeIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "primitiveIterator", function() { return _geometry__WEBPACK_IMPORTED_MODULE_0__["primitiveIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "computeVertexNormals", function() { return _geometry__WEBPACK_IMPORTED_MODULE_0__["computeVertexNormals"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "encodeRGB565", function() { return _geometry__WEBPACK_IMPORTED_MODULE_0__["encodeRGB565"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "decodeRGB565", function() { return _geometry__WEBPACK_IMPORTED_MODULE_0__["decodeRGB565"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concatTypedArrays", function() { return _geometry__WEBPACK_IMPORTED_MODULE_0__["concatTypedArrays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "octEncodeInRange", function() { return _geometry__WEBPACK_IMPORTED_MODULE_0__["octEncodeInRange"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "octEncode", function() { return _geometry__WEBPACK_IMPORTED_MODULE_0__["octEncode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "octEncodeToVector4", function() { return _geometry__WEBPACK_IMPORTED_MODULE_0__["octEncodeToVector4"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "octDecodeInRange", function() { return _geometry__WEBPACK_IMPORTED_MODULE_0__["octDecodeInRange"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "octDecode", function() { return _geometry__WEBPACK_IMPORTED_MODULE_0__["octDecode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "octDecodeFromVector4", function() { return _geometry__WEBPACK_IMPORTED_MODULE_0__["octDecodeFromVector4"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "octPackFloat", function() { return _geometry__WEBPACK_IMPORTED_MODULE_0__["octPackFloat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "octEncodeFloat", function() { return _geometry__WEBPACK_IMPORTED_MODULE_0__["octEncodeFloat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "octDecodeFloat", function() { return _geometry__WEBPACK_IMPORTED_MODULE_0__["octDecodeFloat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "octPack", function() { return _geometry__WEBPACK_IMPORTED_MODULE_0__["octPack"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "octUnpack", function() { return _geometry__WEBPACK_IMPORTED_MODULE_0__["octUnpack"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "compressTextureCoordinates", function() { return _geometry__WEBPACK_IMPORTED_MODULE_0__["compressTextureCoordinates"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "decompressTextureCoordinates", function() { return _geometry__WEBPACK_IMPORTED_MODULE_0__["decompressTextureCoordinates"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zigZagDeltaDecode", function() { return _geometry__WEBPACK_IMPORTED_MODULE_0__["zigZagDeltaDecode"]; });




/***/ }),

/***/ "../math/src/utils/assert.js":
/*!***********************************!*\
  !*** ../math/src/utils/assert.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
// Replacement for the external assert method to reduce bundle size
// Note: We don't use the second "message" argument in calling code,
// so no need to support it here
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || '3d-tile loader: assertion failed.');
  }
}


/***/ }),

/***/ "./src/bundle.js":
/*!***********************!*\
  !*** ./src/bundle.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/* global window, global */
const moduleExports = __webpack_require__(/*! ./index */ "./src/index.js");

const _global = typeof window === 'undefined' ? global : window;
_global.loaders = _global.loaders || {};

module.exports = Object.assign(_global.loaders, moduleExports);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/classes/helpers/tile-3d-accessor-utils.js":
/*!*******************************************************!*\
  !*** ./src/classes/helpers/tile-3d-accessor-utils.js ***!
  \*******************************************************/
/*! exports provided: createTypedArrayFromAccessor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createTypedArrayFromAccessor", function() { return createTypedArrayFromAccessor; });
/* harmony import */ var _loaders_gl_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/math */ "../math/src/index.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/assert */ "./src/utils/assert.js");
 // '@math.gl/geometry';


const COMPONENTS_PER_ATTRIBUTE = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};

// TODO - could just return typed array views...
// prettier-ignore
const UNPACKER = {
  SCALAR: (values, i) => values[i],
  VEC2: (values, i) => [values[2 * i + 0], values[2 * i + 1]],
  VEC3: (values, i) => [values[3 * i + 0], values[3 * i + 1], values[3 * i + 2]],
  VEC4: (values, i) => [values[4 * i + 0], values[4 * i + 1], values[4 * i + 2], values[4 * i + 3]],
  // TODO: check column major
  MAT2: (values, i) => [
    values[4 * i + 0], values[4 * i + 1],
    values[4 * i + 2], values[4 * i + 3]
  ],
  MAT3: (values, i) => [
    values[9 * i + 0], values[9 * i + 1], values[9 * i + 2],
    values[9 * i + 3], values[9 * i + 4], values[9 * i + 5],
    values[9 * i + 6], values[9 * i + 7], values[9 * i + 8]
  ],
  MAT4: (values, i) => [
    values[16 * i + 0], values[16 * i + 1], values[16 * i + 2], values[16 * i + 3],
    values[16 * i + 4], values[16 * i + 5], values[16 * i + 6], values[16 * i + 7],
    values[16 * i + 8], values[16 * i + 9], values[16 * i + 10], values[16 * i + 11],
    values[16 * i + 12], values[16 * i + 13], values[16 * i + 14], values[16 * i + 15]
  ]
};

const PACKER = {
  SCALAR: (x, values, i) => {
    values[i] = x;
  },
  VEC2: (x, values, i) => {
    values[2 * i + 0] = x[0];
    values[2 * i + 1] = x[1];
  },
  VEC3: (x, values, i) => {
    values[3 * i + 0] = x[0];
    values[3 * i + 1] = x[1];
    values[3 * i + 2] = x[2];
  },
  VEC4: (x, values, i) => {
    values[4 * i + 0] = x[0];
    values[4 * i + 1] = x[1];
    values[4 * i + 2] = x[2];
    values[4 * i + 3] = x[3];
  },
  // TODO: check column major correctness
  MAT2: (x, values, i) => {
    values[4 * i + 0] = x[0];
    values[4 * i + 1] = x[1];
    values[4 * i + 2] = x[2];
    values[4 * i + 3] = x[3];
  },
  MAT3: (x, values, i) => {
    values[9 * i + 0] = x[0];
    values[9 * i + 1] = x[1];
    values[9 * i + 2] = x[2];
    values[9 * i + 3] = x[3];
    values[9 * i + 4] = x[4];
    values[9 * i + 5] = x[5];
    values[9 * i + 6] = x[6];
    values[9 * i + 7] = x[7];
    values[9 * i + 8] = x[8];
    values[9 * i + 9] = x[9];
  },
  MAT4: (x, values, i) => {
    values[16 * i + 0] = x[0];
    values[16 * i + 1] = x[1];
    values[16 * i + 2] = x[2];
    values[16 * i + 3] = x[3];
    values[16 * i + 4] = x[4];
    values[16 * i + 5] = x[5];
    values[16 * i + 6] = x[6];
    values[16 * i + 7] = x[7];
    values[16 * i + 8] = x[8];
    values[16 * i + 9] = x[9];
    values[16 * i + 10] = x[10];
    values[16 * i + 11] = x[11];
    values[16 * i + 12] = x[12];
    values[16 * i + 13] = x[13];
    values[16 * i + 14] = x[14];
    values[16 * i + 15] = x[15];
  }
};

function createTypedArrayFromAccessor(tile3DAccessor, buffer, byteOffset, length) {
  const {componentType} = tile3DAccessor;
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(tile3DAccessor.componentType);
  const type = typeof componentType === 'string' ? _loaders_gl_math__WEBPACK_IMPORTED_MODULE_0__["GLType"].fromName(componentType) : componentType;
  const size = COMPONENTS_PER_ATTRIBUTE[tile3DAccessor.type];
  const unpacker = UNPACKER[tile3DAccessor.type];
  const packer = PACKER[tile3DAccessor.type];

  byteOffset += tile3DAccessor.byteOffset;
  const values = _loaders_gl_math__WEBPACK_IMPORTED_MODULE_0__["GLType"].createTypedArray(type, buffer, byteOffset, size * length);

  return {
    values,
    type,
    size,
    unpacker,
    packer
  };
}


/***/ }),

/***/ "./src/classes/tile-3d-batch-table-hierarchy.js":
/*!******************************************************!*\
  !*** ./src/classes/tile-3d-batch-table-hierarchy.js ***!
  \******************************************************/
/*! exports provided: initializeHierarchy, traverseHierarchy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initializeHierarchy", function() { return initializeHierarchy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "traverseHierarchy", function() { return traverseHierarchy; });
// This file is derived from the Cesium code base under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md

// TODO - Finish hierarchy suypport: this file is only half ported
/* eslint-disable */
const defined = x => x !== undefined;

function initializeHierarchy(batchTable, jsonHeader, binaryBody) {
  if (!jsonHeader) {
    return null;
  }

  let hierarchy = batchTable.getExtension('3DTILES_batch_table_hierarchy');

  const legacyHierarchy = jsonHeader.HIERARCHY;
  if (legacyHierarchy) {
    // eslint-disable-next-line
    console.warn('3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy.');
    jsonHeader.extensions = jsonHeader.extensions || {};
    jsonHeader.extensions['3DTILES_batch_table_hierarchy'] = legacyHierarchy;
    hierarchy = legacyHierarchy;
  }

  if (!hierarchy) {
    return null;
  }

  return initializeHierarchyValues(hierarchy, binaryBody);
}

// eslint-disable-next-line max-statements
function initializeHierarchyValues(hierarchyJson, binaryBody) {
  let i;
  let classId;
  let binaryAccessor;

  const instancesLength = hierarchyJson.instancesLength;
  const classes = hierarchyJson.classes;
  const classIds = hierarchyJson.classIds;
  const parentCounts = hierarchyJson.parentCounts;
  const parentIds = hierarchyJson.parentIds;
  const parentIdsLength = instancesLength;

  if (defined(classIds.byteOffset)) {
    classIds.componentType = defaultValue(classIds.componentType, GL.UNSIGNED_SHORT);
    classIds.type = AttributeType.SCALAR;
    binaryAccessor = getBinaryAccessor(classIds);
    classIds = binaryAccessor.createArrayBufferView(
      binaryBody.buffer,
      binaryBody.byteOffset + classIds.byteOffset,
      instancesLength
    );
  }

  let parentIndexes;
  if (defined(parentCounts)) {
    if (defined(parentCounts.byteOffset)) {
      parentCounts.componentType = defaultValue(parentCounts.componentType, GL.UNSIGNED_SHORT);
      parentCounts.type = AttributeType.SCALAR;
      binaryAccessor = getBinaryAccessor(parentCounts);
      parentCounts = binaryAccessor.createArrayBufferView(
        binaryBody.buffer,
        binaryBody.byteOffset + parentCounts.byteOffset,
        instancesLength
      );
    }
    parentIndexes = new Uint16Array(instancesLength);
    parentIdsLength = 0;
    for (i = 0; i < instancesLength; ++i) {
      parentIndexes[i] = parentIdsLength;
      parentIdsLength += parentCounts[i];
    }
  }

  if (defined(parentIds) && defined(parentIds.byteOffset)) {
    parentIds.componentType = defaultValue(parentIds.componentType, GL.UNSIGNED_SHORT);
    parentIds.type = AttributeType.SCALAR;
    binaryAccessor = getBinaryAccessor(parentIds);
    parentIds = binaryAccessor.createArrayBufferView(
      binaryBody.buffer,
      binaryBody.byteOffset + parentIds.byteOffset,
      parentIdsLength
    );
  }

  const classesLength = classes.length;
  for (i = 0; i < classesLength; ++i) {
    const classInstancesLength = classes[i].length;
    const properties = classes[i].instances;
    const binaryProperties = getBinaryProperties(classInstancesLength, properties, binaryBody);
    classes[i].instances = combine(binaryProperties, properties);
  }

  const classCounts = new Array(classesLength).fill(0);
  const classIndexes = new Uint16Array(instancesLength);
  for (i = 0; i < instancesLength; ++i) {
    classId = classIds[i];
    classIndexes[i] = classCounts[classId];
    ++classCounts[classId];
  }

  const hierarchy = {
    classes,
    classIds,
    classIndexes,
    parentCounts,
    parentIndexes,
    parentIds
  };

  validateHierarchy(hierarchy);

  return hierarchy;
}

// HELPER CODE

// Traverse over the hierarchy and process each instance with the endConditionCallback.
// When the endConditionCallback returns a value, the traversal stops and that value is returned.
function traverseHierarchy(hierarchy, instanceIndex, endConditionCallback) {
  if (!hierarchy) {
    return;
  }

  const parentCounts = hierarchy.parentCounts;
  const parentIds = hierarchy.parentIds;
  if (parentIds) {
    return endConditionCallback(hierarchy, instanceIndex);
  }
  if (parentCounts > 0) {
    return traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback);
  }
  return traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback);
}

// eslint-disable-next-line max-statements
function traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback) {
  const classIds = hierarchy.classIds;
  const parentCounts = hierarchy.parentCounts;
  const parentIds = hierarchy.parentIds;
  const parentIndexes = hierarchy.parentIndexes;
  const instancesLength = classIds.length;

  // Ignore instances that have already been visited. This occurs in diamond inheritance situations.
  // Use a marker value to indicate that an instance has been visited, which increments with each run.
  // This is more efficient than clearing the visited array every time.
  const visited = scratchVisited;
  visited.length = Math.max(visited.length, instancesLength);
  const visitedMarker = ++marker;

  const stack = scratchStack;
  stack.length = 0;
  stack.push(instanceIndex);

  while (stack.length > 0) {
    instanceIndex = stack.pop();
    if (visited[instanceIndex] === visitedMarker) {
      // This instance has already been visited, stop traversal
      continue;
    }
    visited[instanceIndex] = visitedMarker;
    const result = endConditionCallback(hierarchy, instanceIndex);
    if (defined(result)) {
      // The end condition was met, stop the traversal and return the result
      return result;
    }
    const parentCount = parentCounts[instanceIndex];
    const parentIndex = parentIndexes[instanceIndex];
    for (let i = 0; i < parentCount; ++i) {
      const parentId = parentIds[parentIndex + i];
      // Stop the traversal when the instance has no parent (its parentId equals itself)
      // else add the parent to the stack to continue the traversal.
      if (parentId !== instanceIndex) {
        stack.push(parentId);
      }
    }
  }

  return null;
}

function traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback) {
  let hasParent = true;
  while (hasParent) {
    const result = endConditionCallback(hierarchy, instanceIndex);
    if (defined(result)) {
      // The end condition was met, stop the traversal and return the result
      return result;
    }
    const parentId = hierarchy.parentIds[instanceIndex];
    hasParent = parentId !== instanceIndex;
    instanceIndex = parentId;
  }
  throw new Error('traverseHierarchySingleParent');
}

// DEBUG CODE

function validateHierarchy(hierarchy) {
  const scratchValidateStack = [];

  const classIds = hierarchy.classIds;
  const instancesLength = classIds.length;

  for (let i = 0; i < instancesLength; ++i) {
    validateInstance(hierarchy, i, stack);
  }
}

function validateInstance(hierarchy, instanceIndex, stack) {
  const parentCounts = hierarchy.parentCounts;
  const parentIds = hierarchy.parentIds;
  const parentIndexes = hierarchy.parentIndexes;
  const classIds = hierarchy.classIds;
  const instancesLength = classIds.length;

  if (!defined(parentIds)) {
    // No need to validate if there are no parents
    return;
  }

  assert(
    instanceIndex < instancesLength,
    `Parent index ${instanceIndex} exceeds the total number of instances: ${instancesLength}`
  );
  assert(
    stack.indexOf(instanceIndex) === -1,
    'Circular dependency detected in the batch table hierarchy.'
  );

  stack.push(instanceIndex);
  const parentCount = defined(parentCounts) ? parentCounts[instanceIndex] : 1;
  const parentIndex = defined(parentCounts) ? parentIndexes[instanceIndex] : instanceIndex;
  for (let i = 0; i < parentCount; ++i) {
    const parentId = parentIds[parentIndex + i];
    // Stop the traversal when the instance has no parent (its parentId equals itself), else continue the traversal.
    if (parentId !== instanceIndex) {
      validateInstance(hierarchy, parentId, stack);
    }
  }
  stack.pop(instanceIndex);
}


/***/ }),

/***/ "./src/classes/tile-3d-batch-table.js":
/*!********************************************!*\
  !*** ./src/classes/tile-3d-batch-table.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Tile3DBatchTableParser; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "./src/utils/assert.js");
/* harmony import */ var _helpers_tile_3d_accessor_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers/tile-3d-accessor-utils */ "./src/classes/helpers/tile-3d-accessor-utils.js");
/* harmony import */ var _tile_3d_batch_table_hierarchy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tile-3d-batch-table-hierarchy */ "./src/classes/tile-3d-batch-table-hierarchy.js");
// This file is derived from the Cesium code base under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md

// import {GL} from '../constants';




const defined = x => x !== undefined;
const clone = x => x;

// These top level fields in the batch table json are not properties
const IGNORED_PROPERTY_FIELDS = {
  HIERARCHY: true, // Deprecated HIERARCHY property
  extensions: true,
  extras: true
};

// The size of this array equals the maximum instance count among all loaded tiles, which has the potential to be large.
class Tile3DBatchTableParser {
  constructor(json, binary, featureCount, options = {}) {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(featureCount >= 0);
    this.json = json || {};
    this.binary = binary;
    this.featureCount = featureCount;

    this._extensions = (this.json && this.json.extensions) || {};

    // Copy all top-level property fields from the json object, ignoring special fields
    this._properties = {};
    for (const propertyName in this.json) {
      if (!IGNORED_PROPERTY_FIELDS[propertyName]) {
        this._properties[propertyName] = this.json[propertyName];
      }
    }

    this._binaryProperties = this._initializeBinaryProperties();

    // TODO: hierarchy support is only partially implemented and not tested
    if (options['3DTILES_batch_table_hierarchy']) {
      this._hierarchy = Object(_tile_3d_batch_table_hierarchy__WEBPACK_IMPORTED_MODULE_2__["initializeHierarchy"])(this, this.json, this.binary);
    }
  }

  getExtension(extensionName) {
    return this.json && this.json.extensions && this.json.extensions[extensionName];
  }

  memorySizeInBytes() {
    return 0;
  }

  isClass(batchId, className) {
    this._checkBatchId(batchId);
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(typeof className === 'string', className);

    // extension: 3DTILES_batch_table_hierarchy
    if (this._hierarchy) {
      // PERFORMANCE_IDEA : cache results in the ancestor classes
      //   to speed up this check if this area becomes a hotspot
      // PERFORMANCE_IDEA : treat class names as integers for faster comparisons
      const result = Object(_tile_3d_batch_table_hierarchy__WEBPACK_IMPORTED_MODULE_2__["traverseHierarchy"])(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
        const classId = hierarchy.classIds[instanceIndex];
        const instanceClass = hierarchy.classes[classId];
        return instanceClass.name === className;
      });
      return defined(result);
    }

    return false;
  }

  isExactClass(batchId, className) {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(typeof className === 'string', className);

    return this.getExactClassName(batchId) === className;
  }

  getExactClassName(batchId) {
    this._checkBatchId(batchId);

    // extension: 3DTILES_batch_table_hierarchy
    if (this._hierarchy) {
      const classId = this._hierarchy.classIds[batchId];
      const instanceClass = this._hierarchy.classes[classId];
      return instanceClass.name;
    }

    return undefined;
  }

  hasProperty(batchId, name) {
    this._checkBatchId(batchId);
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(typeof name === 'string', name);

    return defined(this._properties[name]) || this._hasPropertyInHierarchy(batchId, name);
  }

  getPropertyNames(batchId, results) {
    this._checkBatchId(batchId);

    results = defined(results) ? results : [];
    results.length = 0;

    const propertyNames = Object.keys(this._properties);
    results.push(...propertyNames);

    if (this._hierarchy) {
      this._getPropertyNamesInHierarchy(batchId, results);
    }

    return results;
  }

  getProperty(batchId, name) {
    this._checkBatchId(batchId);
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(typeof name === 'string', name);

    if (this._binaryProperties) {
      const binaryProperty = this._binaryProperties[name];
      if (defined(binaryProperty)) {
        return this._getBinaryProperty(binaryProperty, batchId);
      }
    }

    const propertyValues = this._properties[name];
    if (defined(propertyValues)) {
      return clone(propertyValues[batchId], true);
    }

    // EXTENSION: 3DTILES_batch_table_hierarchy
    if (this._hierarchy) {
      const hierarchyProperty = this._getHierarchyProperty(batchId, name);
      if (defined(hierarchyProperty)) {
        return hierarchyProperty;
      }
    }

    return undefined;
  }

  setProperty(batchId, name, value) {
    const featureCount = this.featureCount;

    this._checkBatchId(batchId, featureCount);
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(typeof name === 'string', name);

    if (this._binaryProperties) {
      const binaryProperty = this._binaryProperties[name];
      if (binaryProperty) {
        this._setBinaryProperty(binaryProperty, batchId, value);
        return;
      }
    }

    // EXTENSION: 3DTILES_batch_table_hierarchy
    if (this._hierarchy) {
      if (this._setHierarchyProperty(this, batchId, name, value)) {
        return;
      }
    }

    let propertyValues = this._properties[name];
    if (!defined(propertyValues)) {
      // Property does not exist. Create it.
      this._properties[name] = new Array(featureCount);
      propertyValues = this._properties[name];
    }

    propertyValues[batchId] = clone(value, true);
  }

  // PRIVATE METHODS

  _checkBatchId(batchId) {
    const valid = batchId >= 0 && batchId < this.featureCount;
    if (!valid) {
      throw new Error(`batchId not in range [0, featureCount - 1].`);
    }
  }

  _getBinaryProperty(binaryProperty, index) {
    return binaryProperty.unpack(binaryProperty.typedArray, index);
  }

  _setBinaryProperty(binaryProperty, index, value) {
    binaryProperty.pack(value, binaryProperty.typedArray, index);
  }

  _initializeBinaryProperties() {
    let binaryProperties = null;
    for (const name in this._properties) {
      const property = this._properties[name];
      const binaryProperty = this._initializeBinaryProperty(name, property);
      // Store any information needed to access the binary data, including the typed array,
      // componentCount (e.g. a VEC4 would be 4), and the type used to pack and unpack (e.g. Cartesian4).
      if (binaryProperty) {
        binaryProperties = binaryProperties || {};
        binaryProperties[name] = binaryProperty;
      }
    }
    return binaryProperties;
  }

  _initializeBinaryProperty(name, property) {
    if ('byteOffset' in property) {
      // This is a binary property
      const tile3DAccessor = property;

      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(this.binary, `Property ${name} requires a batch table binary.`);
      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(tile3DAccessor.type, `Property ${name} requires a type.`);

      const accessor = Object(_helpers_tile_3d_accessor_utils__WEBPACK_IMPORTED_MODULE_1__["createTypedArrayFromAccessor"])(
        tile3DAccessor,
        this.binary.buffer,
        this.binary.byteOffset | 0,
        this.featureCount
      );

      // Store any information needed to access the binary data, including the typed array,
      // componentCount (e.g. a VEC4 would be 4), and the type used to pack and unpack (e.g. Cartesian4).
      return {
        typedArray: accessor.values,
        componentCount: accessor.size,
        unpack: accessor.unpacker,
        pack: accessor.packer
      };
    }

    return null;
  }

  //  EXTENSION SUPPORT: 3DTILES_batch_table_hierarchy

  _hasPropertyInHierarchy(batchId, name) {
    if (!this._hierarchy) {
      return false;
    }

    const result = Object(_tile_3d_batch_table_hierarchy__WEBPACK_IMPORTED_MODULE_2__["traverseHierarchy"])(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
      const classId = hierarchy.classIds[instanceIndex];
      const instances = hierarchy.classes[classId].instances;
      return defined(instances[name]);
    });

    return defined(result);
  }

  _getPropertyNamesInHierarchy(batchId, results) {
    Object(_tile_3d_batch_table_hierarchy__WEBPACK_IMPORTED_MODULE_2__["traverseHierarchy"])(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
      const classId = hierarchy.classIds[instanceIndex];
      const instances = hierarchy.classes[classId].instances;
      for (const name in instances) {
        if (instances.hasOwnProperty(name)) {
          if (results.indexOf(name) === -1) {
            results.push(name);
          }
        }
      }
    });
  }

  _getHierarchyProperty(batchId, name) {
    return Object(_tile_3d_batch_table_hierarchy__WEBPACK_IMPORTED_MODULE_2__["traverseHierarchy"])(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
      const classId = hierarchy.classIds[instanceIndex];
      const instanceClass = hierarchy.classes[classId];
      const indexInClass = hierarchy.classIndexes[instanceIndex];
      const propertyValues = instanceClass.instances[name];
      if (defined(propertyValues)) {
        if (defined(propertyValues.typedArray)) {
          return this._getBinaryProperty(propertyValues, indexInClass);
        }
        return clone(propertyValues[indexInClass], true);
      }
      return null;
    });
  }

  _setHierarchyProperty(batchTable, batchId, name, value) {
    const result = Object(_tile_3d_batch_table_hierarchy__WEBPACK_IMPORTED_MODULE_2__["traverseHierarchy"])(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
      const classId = hierarchy.classIds[instanceIndex];
      const instanceClass = hierarchy.classes[classId];
      const indexInClass = hierarchy.classIndexes[instanceIndex];
      const propertyValues = instanceClass.instances[name];
      if (defined(propertyValues)) {
        Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(instanceIndex === batchId, `Inherited property "${name}" is read-only.`);
        if (defined(propertyValues.typedArray)) {
          this._setBinaryProperty(propertyValues, indexInClass, value);
        } else {
          propertyValues[indexInClass] = clone(value, true);
        }
        return true;
      }
      return false;
    });
    return defined(result);
  }
}


/***/ }),

/***/ "./src/classes/tile-3d-feature-table.js":
/*!**********************************************!*\
  !*** ./src/classes/tile-3d-feature-table.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Tile3DFeatureTable; });
/* harmony import */ var _loaders_gl_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/math */ "../math/src/index.js");
// This file is derived from the Cesium code base under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md



// Reference:
// https://github.com/AnalyticalGraphicsInc/cesium/blob/1de96d087f0b17575eb1a3f736407b348c765d59/Source/Scene/Cesium3DTileFeatureTable.js
class Tile3DFeatureTable {
  constructor(featureTableJson, featureTableBinary) {
    this.json = featureTableJson;
    this.buffer = featureTableBinary;
    this.featuresLength = 0;
    this._cachedTypedArrays = {};
  }

  getExtension(extensionName) {
    return this.json.extensions && this.json.extensions[extensionName];
  }

  hasProperty(propertyName) {
    return Boolean(this.json[propertyName]);
  }

  getGlobalProperty(propertyName, componentType = _loaders_gl_math__WEBPACK_IMPORTED_MODULE_0__["GL"].UNSIGNED_INT, componentLength = 1) {
    const jsonValue = this.json[propertyName];

    if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {
      return this._getTypedArrayFromBinary(
        propertyName,
        componentType,
        componentLength,
        1,
        jsonValue.byteOffset
      );
    }

    return jsonValue;
  }

  getPropertyArray(propertyName, componentType, componentLength) {
    const jsonValue = this.json[propertyName];

    if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {
      if ('componentType' in jsonValue) {
        componentType = _loaders_gl_math__WEBPACK_IMPORTED_MODULE_0__["GLType"].fromName(jsonValue.componentType);
      }
      return this._getTypedArrayFromBinary(
        propertyName,
        componentType,
        componentLength,
        this.featuresLength,
        jsonValue.byteOffset
      );
    }

    return this._getTypedArrayFromArray(propertyName, componentType, jsonValue);
  }

  getProperty(propertyName, componentType, componentLength, featureId, result) {
    const jsonValue = this.json[propertyName];
    if (!jsonValue) {
      return jsonValue;
    }

    const typedArray = this.getPropertyArray(propertyName, componentType, componentLength);

    if (componentLength === 1) {
      return typedArray[featureId];
    }

    for (let i = 0; i < componentLength; ++i) {
      result[i] = typedArray[componentLength * featureId + i];
    }

    return result;
  }

  // HELPERS

  _getTypedArrayFromBinary(propertyName, componentType, componentLength, count, byteOffset) {
    const cachedTypedArrays = this._cachedTypedArrays;
    let typedArray = cachedTypedArrays[propertyName];
    if (!typedArray) {
      typedArray = _loaders_gl_math__WEBPACK_IMPORTED_MODULE_0__["GLType"].createTypedArray(
        componentType,
        this.buffer.buffer,
        this.buffer.byteOffset + byteOffset,
        count * componentLength
      );
      cachedTypedArrays[propertyName] = typedArray;
    }
    return typedArray;
  }

  _getTypedArrayFromArray(propertyName, componentType, array) {
    const cachedTypedArrays = this._cachedTypedArrays;
    let typedArray = cachedTypedArrays[propertyName];
    if (!typedArray) {
      typedArray = _loaders_gl_math__WEBPACK_IMPORTED_MODULE_0__["GLType"].createTypedArray(componentType, array);
      cachedTypedArrays[propertyName] = typedArray;
    }
    return typedArray;
  }
}


/***/ }),

/***/ "./src/constants.js":
/*!**************************!*\
  !*** ./src/constants.js ***!
  \**************************/
/*! exports provided: TILE3D_TYPE, TILE3D_TYPES, MAGIC_ARRAY, TILE3D_CONTENT_STATE, TILE3D_OPTIMIZATION_HINT, TILE3D_COLOR_BLEND_MODE, TILE3D_REFINEMENT */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TILE3D_TYPE", function() { return TILE3D_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TILE3D_TYPES", function() { return TILE3D_TYPES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAGIC_ARRAY", function() { return MAGIC_ARRAY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TILE3D_CONTENT_STATE", function() { return TILE3D_CONTENT_STATE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TILE3D_OPTIMIZATION_HINT", function() { return TILE3D_OPTIMIZATION_HINT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TILE3D_COLOR_BLEND_MODE", function() { return TILE3D_COLOR_BLEND_MODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TILE3D_REFINEMENT", function() { return TILE3D_REFINEMENT; });
// TILE TYPES

const TILE3D_TYPE = {
  COMPOSITE: 'cmpt',
  POINT_CLOUD: 'pnts',
  BATCHED_3D_MODEL: 'b3dm',
  INSTANCED_3D_MODEL: 'i3dm',
  GEOMETRY: 'geom',
  VECTOR: 'vect'
};

const TILE3D_TYPES = Object.keys(TILE3D_TYPE);

const MAGIC_ARRAY = {
  BATCHED_MODEL: [98, 51, 100, 109],
  INSTANCED_MODEL: [105, 51, 100, 109],
  POINT_CLOUD: [112, 110, 116, 115],
  COMPOSITE: [99, 109, 112, 116]
};

// TILE CONSTANTS

// TODO - do we need this?
const TILE3D_CONTENT_STATE = {
  UNLOADED: 0, // Has never been requested
  LOADING: 1, // Is waiting on a pending request
  PROCESSING: 2, // Request received.  Contents are being processed for rendering.  Depending on the content, it might make its own requests for external data.
  READY: 3, // Ready to render.
  EXPIRED: 4, // Is expired and will be unloaded once new content is loaded.
  FAILED: 5 // Request failed.
};

const TILE3D_OPTIMIZATION_HINT = {
  NOT_COMPUTED: -1,
  USE_OPTIMIZATION: 1,
  SKIP_OPTIMIZATION: 0
};

const TILE3D_COLOR_BLEND_MODE = {
  HIGHLIGHT: 0, // Multiplies the source color by the feature color.
  REPLACE: 1, // Replaces the source color with the feature color.
  MIX: 2 // Blends the source color and feature color together
};

const TILE3D_REFINEMENT = {
  ADD: 0, // Render tile and, if screen space error exceeded, also refine to its children.
  REPLACE: 1 // Render tile or, if screen space error exceeded, refine to its descendants instead.
};
// SUBSET OF GL CONSTANTS - CAN BE USED DIRECTLY WITH WEBGL


/***/ }),

/***/ "./src/encoders/encode-3d-tile-batched-model.js":
/*!******************************************************!*\
  !*** ./src/encoders/encode-3d-tile-batched-model.js ***!
  \******************************************************/
/*! exports provided: encodeBatchedModel3DTile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeBatchedModel3DTile", function() { return encodeBatchedModel3DTile; });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../loader-utils/src/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ "./src/constants.js");
/* harmony import */ var _helpers_encode_3d_tile_header__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers/encode-3d-tile-header */ "./src/encoders/helpers/encode-3d-tile-header.js");
// This file is derived from the Cesium code base under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md





// Procedurally encode the tile array dataView for testing purposes
function encodeBatchedModel3DTile(tile, dataView, byteOffset, options) {
  const {featuresLength = 1} = tile;

  const featureTableJson = {
    BATCH_LENGTH: featuresLength
  };
  const featureTableJsonString = JSON.stringify(featureTableJson);
  const featureTableJsonByteLength = featureTableJsonString.length;

  // Add default magic for this tile type
  tile = {magic: _constants__WEBPACK_IMPORTED_MODULE_1__["MAGIC_ARRAY"].BATCHED_MODEL, ...tile};

  const byteOffsetStart = byteOffset;

  byteOffset = Object(_helpers_encode_3d_tile_header__WEBPACK_IMPORTED_MODULE_2__["encode3DTileHeader"])(tile, dataView, byteOffset);

  if (dataView) {
    dataView.setUint32(12, featureTableJsonByteLength, true); // featureTableJsonByteLength
    dataView.setUint32(16, 0, true); // featureTableBinaryByteLength
    dataView.setUint32(20, 0, true); // batchTableJsonByteLength
    dataView.setUint32(24, 0, true); // batchTableBinaryByteLength
  }
  byteOffset += 16;

  // TODO feature table binary
  byteOffset += Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["copyStringToDataView"])(
    dataView,
    byteOffset,
    featureTableJsonString,
    featureTableJsonByteLength
  );
  // TODO batch table

  // Go "back" and rewrite the tile's `byteLength` now that we know the value
  Object(_helpers_encode_3d_tile_header__WEBPACK_IMPORTED_MODULE_2__["encode3DTileByteLength"])(dataView, byteOffsetStart, byteOffset - byteOffsetStart);

  return byteOffset;
}


/***/ }),

/***/ "./src/encoders/encode-3d-tile-composite.js":
/*!**************************************************!*\
  !*** ./src/encoders/encode-3d-tile-composite.js ***!
  \**************************************************/
/*! exports provided: encodeComposite3DTile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeComposite3DTile", function() { return encodeComposite3DTile; });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants */ "./src/constants.js");
/* harmony import */ var _helpers_encode_3d_tile_header__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers/encode-3d-tile-header */ "./src/encoders/helpers/encode-3d-tile-header.js");
// This file is derived from the Cesium code base under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md




function encodeComposite3DTile(tile, dataView, byteOffset, options, encode3DTile) {
  // Add default magic for this tile type
  tile = {magic: _constants__WEBPACK_IMPORTED_MODULE_0__["MAGIC_ARRAY"].COMPOSITE, tiles: [], ...tile};

  const byteOffsetStart = byteOffset;

  byteOffset += Object(_helpers_encode_3d_tile_header__WEBPACK_IMPORTED_MODULE_1__["encode3DTileHeader"])(tile, dataView, byteOffset);

  if (dataView) {
    dataView.setUint32(byteOffset, tile.tiles.length, true); // tilesLength
  }
  byteOffset += 4;

  for (let i = 0; i < tile.tiles.length; ++i) {
    byteOffset += encode3DTile(tile.tiles[i], dataView, byteOffset, options);
  }

  // Go "back" and rewrite the tile's `byteLength` now that we know the value
  Object(_helpers_encode_3d_tile_header__WEBPACK_IMPORTED_MODULE_1__["encode3DTileByteLength"])(dataView, byteOffsetStart, byteOffset - byteOffsetStart);

  return byteOffset;
}


/***/ }),

/***/ "./src/encoders/encode-3d-tile-instanced-model.js":
/*!********************************************************!*\
  !*** ./src/encoders/encode-3d-tile-instanced-model.js ***!
  \********************************************************/
/*! exports provided: encodeInstancedModel3DTile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeInstancedModel3DTile", function() { return encodeInstancedModel3DTile; });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../loader-utils/src/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ "./src/constants.js");
/* harmony import */ var _helpers_encode_3d_tile_header__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers/encode-3d-tile-header */ "./src/encoders/helpers/encode-3d-tile-header.js");
// This file is derived from the Cesium code base under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md





// Procedurally encode the tile array buffer for testing purposes
// eslint-disable-next-line max-statements
function encodeInstancedModel3DTile(tile, dataView, byteOffset, options) {
  const {featuresLength = 1, gltfFormat = 1, gltfUri = ''} = tile;

  const gltfUriByteLength = gltfUri.length;

  const featureTableJson = {
    INSTANCES_LENGTH: featuresLength,
    POSITION: new Array(featuresLength * 3).fill(0)
  };
  const featureTableJsonString = JSON.stringify(featureTableJson);
  const featureTableJsonByteLength = featureTableJsonString.length;

  // Add default magic for this tile type
  tile = {magic: _constants__WEBPACK_IMPORTED_MODULE_1__["MAGIC_ARRAY"].INSTANCED_MODEL, ...tile};

  const byteOffsetStart = byteOffset;

  Object(_helpers_encode_3d_tile_header__WEBPACK_IMPORTED_MODULE_2__["encode3DTileHeader"])(tile, dataView, 0);

  if (dataView) {
    dataView.setUint32(12, featureTableJsonByteLength, true); // featureTableJsonByteLength
    dataView.setUint32(16, 0, true); // featureTableBinaryByteLength
    dataView.setUint32(20, 0, true); // batchTableJsonByteLength
    dataView.setUint32(24, 0, true); // batchTableBinaryByteLength
    dataView.setUint32(28, gltfFormat, true); // gltfFormat
  }

  byteOffset += Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["copyStringToDataView"])(
    dataView,
    byteOffset,
    featureTableJsonString,
    featureTableJsonByteLength
  );
  byteOffset += Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["copyStringToDataView"])(dataView, byteOffset, gltfUri, gltfUriByteLength);

  // Go "back" and rewrite the tile's `byteLength` now that we know the value
  Object(_helpers_encode_3d_tile_header__WEBPACK_IMPORTED_MODULE_2__["encode3DTileByteLength"])(dataView, byteOffsetStart, byteOffset - byteOffsetStart);

  return byteOffset;
}


/***/ }),

/***/ "./src/encoders/encode-3d-tile-point-cloud.js":
/*!****************************************************!*\
  !*** ./src/encoders/encode-3d-tile-point-cloud.js ***!
  \****************************************************/
/*! exports provided: encodePointCloud3DTile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodePointCloud3DTile", function() { return encodePointCloud3DTile; });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants */ "./src/constants.js");
/* harmony import */ var _helpers_encode_3d_tile_header__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers/encode-3d-tile-header */ "./src/encoders/helpers/encode-3d-tile-header.js");
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../loader-utils/src/index.js");
// This file is derived from the Cesium code base under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md





const DEFAULT_FEATURE_TABLE_JSON = {
  POINTS_LENGTH: 1,
  POSITIONS: {
    byteOffset: 0
  }
};

function encodePointCloud3DTile(tile, dataView, byteOffset, options) {
  const {featureTableJson = DEFAULT_FEATURE_TABLE_JSON} = tile;

  let featureTableJsonString = JSON.stringify(featureTableJson);
  featureTableJsonString = Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_2__["padStringToByteAlignment"])(featureTableJsonString, 4);

  const {featureTableJsonByteLength = featureTableJsonString.length} = tile;

  const featureTableBinary = new ArrayBuffer(12); // Enough space to hold 3 floats
  const featureTableBinaryByteLength = featureTableBinary.byteLength;

  // Add default magic for this tile type
  tile = {magic: _constants__WEBPACK_IMPORTED_MODULE_0__["MAGIC_ARRAY"].POINT_CLOUD, ...tile};

  const byteOffsetStart = byteOffset;

  byteOffset += Object(_helpers_encode_3d_tile_header__WEBPACK_IMPORTED_MODULE_1__["encode3DTileHeader"])(tile, dataView, 0);

  if (dataView) {
    dataView.setUint32(byteOffset + 0, featureTableJsonByteLength, true); // featureTableJsonByteLength
    dataView.setUint32(byteOffset + 4, featureTableBinaryByteLength, true); // featureTableBinaryByteLength
    dataView.setUint32(byteOffset + 8, 0, true); // batchTableJsonByteLength
    dataView.setUint32(byteOffset + 12, 0, true); // batchTableBinaryByteLength
  }
  byteOffset += 16;

  byteOffset += Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_2__["copyStringToDataView"])(
    dataView,
    byteOffset,
    featureTableJsonString,
    featureTableJsonByteLength
  );
  byteOffset += Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_2__["copyBinaryToDataView"])(
    dataView,
    byteOffset,
    featureTableBinary,
    featureTableBinaryByteLength
  );

  // Go "back" and rewrite the tile's `byteLength` now that we know the value
  Object(_helpers_encode_3d_tile_header__WEBPACK_IMPORTED_MODULE_1__["encode3DTileByteLength"])(dataView, byteOffsetStart, byteOffset - byteOffsetStart);

  return byteOffset;
}


/***/ }),

/***/ "./src/encoders/encode-3d-tile.js":
/*!****************************************!*\
  !*** ./src/encoders/encode-3d-tile.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return encode3DTile; });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants */ "./src/constants.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/assert */ "./src/utils/assert.js");
/* harmony import */ var _encode_3d_tile_composite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./encode-3d-tile-composite */ "./src/encoders/encode-3d-tile-composite.js");
/* harmony import */ var _encode_3d_tile_batched_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./encode-3d-tile-batched-model */ "./src/encoders/encode-3d-tile-batched-model.js");
/* harmony import */ var _encode_3d_tile_instanced_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./encode-3d-tile-instanced-model */ "./src/encoders/encode-3d-tile-instanced-model.js");
/* harmony import */ var _encode_3d_tile_point_cloud__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./encode-3d-tile-point-cloud */ "./src/encoders/encode-3d-tile-point-cloud.js");
// This file is derived from the Cesium code base under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md









function encode3DTile(tile, options) {
  const byteLength = encode3DTileToDataView(tile, null, 0, options);
  const arrayBuffer = new ArrayBuffer(byteLength);
  const dataView = new DataView(arrayBuffer);
  encode3DTileToDataView(tile, dataView, 0, options);
  return arrayBuffer;
}

function encode3DTileToDataView(tile, dataView, byteOffset, options) {
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(typeof tile.type === 'string');

  switch (tile.type) {
    case _constants__WEBPACK_IMPORTED_MODULE_0__["TILE3D_TYPE"].COMPOSITE:
      return Object(_encode_3d_tile_composite__WEBPACK_IMPORTED_MODULE_2__["encodeComposite3DTile"])(tile, dataView, byteOffset, options, encode3DTileToDataView);
    case _constants__WEBPACK_IMPORTED_MODULE_0__["TILE3D_TYPE"].POINT_CLOUD:
      return Object(_encode_3d_tile_point_cloud__WEBPACK_IMPORTED_MODULE_5__["encodePointCloud3DTile"])(tile, dataView, byteOffset, options);
    case _constants__WEBPACK_IMPORTED_MODULE_0__["TILE3D_TYPE"].BATCHED_3D_MODEL:
      return Object(_encode_3d_tile_batched_model__WEBPACK_IMPORTED_MODULE_3__["encodeBatchedModel3DTile"])(tile, dataView, byteOffset, options);
    case _constants__WEBPACK_IMPORTED_MODULE_0__["TILE3D_TYPE"].INSTANCED_3D_MODEL:
      return Object(_encode_3d_tile_instanced_model__WEBPACK_IMPORTED_MODULE_4__["encodeInstancedModel3DTile"])(tile, dataView, byteOffset, options);
    default:
      throw new Error('3D Tiles: unknown tile type');
  }
}


/***/ }),

/***/ "./src/encoders/helpers/encode-3d-tile-header.js":
/*!*******************************************************!*\
  !*** ./src/encoders/helpers/encode-3d-tile-header.js ***!
  \*******************************************************/
/*! exports provided: encode3DTileHeader, encode3DTileByteLength */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encode3DTileHeader", function() { return encode3DTileHeader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encode3DTileByteLength", function() { return encode3DTileByteLength; });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../loader-utils/src/index.js");
// HELPER ENCODERS


function encode3DTileHeader(tile, dataView, byteOffset) {
  const HEADER_SIZE = 12;

  if (!dataView) {
    return byteOffset + HEADER_SIZE;
  }

  const {magic, version = 1, byteLength = 12} = tile;

  Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(Array.isArray(magic) && Number.isFinite(version) && Number.isFinite(byteLength));

  dataView.setUint8(byteOffset + 0, magic[0]);
  dataView.setUint8(byteOffset + 1, magic[1]);
  dataView.setUint8(byteOffset + 2, magic[2]);
  dataView.setUint8(byteOffset + 3, magic[3]);
  dataView.setUint32(byteOffset + 4, version, true); // version
  dataView.setUint32(byteOffset + 8, byteLength, true); // byteLength

  byteOffset += HEADER_SIZE;

  return byteOffset;
}

// Bytelength is sometimes only known at the end of writing a tile
function encode3DTileByteLength(dataView, byteOffsetTileStart, byteLength) {
  if (!dataView) {
    return;
  }

  dataView.setUint32(byteOffsetTileStart + 8, byteLength, true); // byteLength
}


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: TILE3D_TYPE, Tileset3DLoader, Tile3DLoader, Tile3DWriter, Tileset3D, Tile3DFeatureTable, Tile3DBatchTable, _getIonTilesetMetadata */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "./src/constants.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TILE3D_TYPE", function() { return _constants__WEBPACK_IMPORTED_MODULE_0__["TILE3D_TYPE"]; });

/* harmony import */ var _tileset_3d_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tileset-3d-loader */ "./src/tileset-3d-loader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tileset3DLoader", function() { return _tileset_3d_loader__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _tile_3d_loader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tile-3d-loader */ "./src/tile-3d-loader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tile3DLoader", function() { return _tile_3d_loader__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _tile_3d_writer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tile-3d-writer */ "./src/tile-3d-writer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tile3DWriter", function() { return _tile_3d_writer__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _tileset_tileset_3d__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tileset/tileset-3d */ "./src/tileset/tileset-3d.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tileset3D", function() { return _tileset_tileset_3d__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _classes_tile_3d_feature_table__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./classes/tile-3d-feature-table */ "./src/classes/tile-3d-feature-table.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tile3DFeatureTable", function() { return _classes_tile_3d_feature_table__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _classes_tile_3d_batch_table__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./classes/tile-3d-batch-table */ "./src/classes/tile-3d-batch-table.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tile3DBatchTable", function() { return _classes_tile_3d_batch_table__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _ion_ion__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ion/ion */ "./src/ion/ion.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_getIonTilesetMetadata", function() { return _ion_ion__WEBPACK_IMPORTED_MODULE_7__["getIonTilesetMetadata"]; });

// TODO - this module is a work-in-progress, all exports are experimental













// EXPERIMENTAL




/***/ }),

/***/ "./src/ion/ion.js":
/*!************************!*\
  !*** ./src/ion/ion.js ***!
  \************************/
/*! exports provided: getIonTilesetMetadata, getIonAssets, getIonAssetMetadata */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIonTilesetMetadata", function() { return getIonTilesetMetadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIonAssets", function() { return getIonAssets; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIonAssetMetadata", function() { return getIonAssetMetadata; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "./src/utils/assert.js");
/* harmony import */ var _loaders_gl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/core */ "../core/src/index.js");
// Minimal support to load tilsets from the Cesium ION services
/* global fetch */



const CESIUM_ION_URL = 'https://api.cesium.com/v1/assets';
// const CESIUM_ION_URL = 'https://api.cesium.com/v1/assets/2/endpoint';

// Returns `{url, headers, type, attributions}` for an ion tileset
async function getIonTilesetMetadata(accessToken, assetId) {
  // Step 1, if no asset id, look for first 3DTILES asset associated with this token.
  if (!assetId) {
    const assets = await getIonAssets(accessToken);
    for (const item of assets.items) {
      if (item.type === '3DTILES') {
        assetId = item.id;
      }
    }
  }

  // Step 2: Query metdatadata for this asset.
  const ionAssetMetadata = await getIonAssetMetadata(accessToken, assetId);
  const {type, url} = ionAssetMetadata;
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(type === '3DTILES' && url);

  // Prepare a headers object for fetch
  ionAssetMetadata.headers = {
    Authorization: `Bearer ${ionAssetMetadata.accessToken}`
  };
  return ionAssetMetadata;
}

// Return a list of all assets associated with accessToken
async function getIonAssets(accessToken) {
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(accessToken);
  const url = CESIUM_ION_URL;
  const headers = {Authorization: `Bearer ${accessToken}`};
  const response = await fetch(url, {headers});
  if (!response.ok) {
    throw new Error(await Object(_loaders_gl_core__WEBPACK_IMPORTED_MODULE_1__["_getErrorMessageFromResponse"])(response));
  }
  return await response.json();
}

// Return metadata for a specific asset assocated with token
async function getIonAssetMetadata(accessToken, assetId) {
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(accessToken, assetId);
  const url = `${CESIUM_ION_URL}/${assetId}/endpoint`;
  const headers = {Authorization: `Bearer ${accessToken}`};
  const response = await fetch(url, {headers});
  if (!response.ok) {
    throw new Error(await Object(_loaders_gl_core__WEBPACK_IMPORTED_MODULE_1__["_getErrorMessageFromResponse"])(response));
  }
  return await response.json();
}


/***/ }),

/***/ "./src/parsers/helpers/normalize-3d-tile-colors.js":
/*!*********************************************************!*\
  !*** ./src/parsers/helpers/normalize-3d-tile-colors.js ***!
  \*********************************************************/
/*! exports provided: normalize3DTileColorAttribute */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize3DTileColorAttribute", function() { return normalize3DTileColorAttribute; });
/* harmony import */ var _loaders_gl_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/math */ "../math/src/index.js");


/* eslint-disable complexity*/
function normalize3DTileColorAttribute(tile, colors, batchTable) {
  // no colors defined
  if (!colors && (!tile || !tile.batchIds || !batchTable)) {
    return null;
  }

  const {batchIds, isRGB565, pointCount} = tile;
  // Batch table, look up colors in table
  if (batchIds && batchTable) {
    const colorArray = new Uint8ClampedArray(pointCount * 3);
    for (let i = 0; i < pointCount; i++) {
      const batchId = batchIds[i];
      // TODO figure out what is `dimensions` used for
      const dimensions = batchTable.getProperty(batchId, 'dimensions');
      const color = dimensions.map(d => d * 255);
      colorArray[i * 3] = color[0];
      colorArray[i * 3 + 1] = color[1];
      colorArray[i * 3 + 2] = color[2];
    }
    return {
      type: _loaders_gl_math__WEBPACK_IMPORTED_MODULE_0__["GL"].UNSIGNED_BYTE,
      value: colorArray,
      size: 3,
      normalized: true
    };
  }

  // RGB565 case, convert to RGB
  if (isRGB565) {
    const colorArray = new Uint8ClampedArray(pointCount * 3);
    for (let i = 0; i < pointCount; i++) {
      const color = Object(_loaders_gl_math__WEBPACK_IMPORTED_MODULE_0__["decodeRGB565"])(colors[i]);
      colorArray[i * 3] = color[0];
      colorArray[i * 3 + 1] = color[1];
      colorArray[i * 3 + 2] = color[2];
    }
    return {
      type: _loaders_gl_math__WEBPACK_IMPORTED_MODULE_0__["GL"].UNSIGNED_BYTE,
      value: colorArray,
      size: 3,
      normalized: true
    };
  }

  // RGB case (tile.isTranslucent)
  if (colors && colors.length === pointCount * 3) {
    return {
      type: _loaders_gl_math__WEBPACK_IMPORTED_MODULE_0__["GL"].UNSIGNED_BYTE,
      value: colors,
      size: 3,
      normalized: true
    };
  }

  // DEFAULT: RGBA case
  return {
    type: _loaders_gl_math__WEBPACK_IMPORTED_MODULE_0__["GL"].UNSIGNED_BYTE,
    value: colors,
    size: 4,
    normalized: true
  };
}
/* eslint-enable complexity*/


/***/ }),

/***/ "./src/parsers/helpers/normalize-3d-tile-normals.js":
/*!**********************************************************!*\
  !*** ./src/parsers/helpers/normalize-3d-tile-normals.js ***!
  \**********************************************************/
/*! exports provided: normalize3DTileNormalAttribute */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize3DTileNormalAttribute", function() { return normalize3DTileNormalAttribute; });
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");
/* harmony import */ var _loaders_gl_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/math */ "../math/src/index.js");



const scratchNormal = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

function normalize3DTileNormalAttribute(tile, normals) {
  if (!normals) {
    return null;
  }

  if (tile.isOctEncoded16P) {
    const decodedArray = new Float32Array(tile.pointsLength * 3);
    for (let i = 0; i < tile.pointsLength; i++) {
      Object(_loaders_gl_math__WEBPACK_IMPORTED_MODULE_1__["octDecode"])(normals[i * 2], normals[i * 2 + 1], scratchNormal);
      scratchNormal.toArray(decodedArray, i * 3);
    }

    return {
      type: _loaders_gl_math__WEBPACK_IMPORTED_MODULE_1__["GL"].FLOAT,
      size: 2,
      value: decodedArray
    };
  }

  return {
    type: _loaders_gl_math__WEBPACK_IMPORTED_MODULE_1__["GL"].FLOAT,
    size: 2,
    value: normals
  };
}


/***/ }),

/***/ "./src/parsers/helpers/normalize-3d-tile-positions.js":
/*!************************************************************!*\
  !*** ./src/parsers/helpers/normalize-3d-tile-positions.js ***!
  \************************************************************/
/*! exports provided: normalize3DTilePositionAttribute */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize3DTilePositionAttribute", function() { return normalize3DTilePositionAttribute; });
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");
/* harmony import */ var _loaders_gl_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/math */ "../math/src/index.js");



// Prepare attribute for positions
function normalize3DTilePositionAttribute(tile, positions, options) {
  if (!tile.isQuantized) {
    return positions;
  }

  // For quantized posititions, either expand to Float32Array or return custom accessor
  // https://github.com/AnalyticalGraphicsInc/3d-tiles/blob/master/specification/TileFormats/Instanced3DModel/README.md#quantized-positions

  // Optionally decodes quantized positions on GPU, for simpler renderers that don't accept normalized attributes
  if (options.decodeQuantizedPositions) {
    tile.isQuantized = false;
    return decodeQuantizedPositions(tile, positions);
  }

  // Default: Use normalized shorts directly, no copying/processing.
  // NOTE: The "missing" offset/scaling operations are automatically added to modelMatrix if `tile.isQuantized === true`
  return {
    type: _loaders_gl_math__WEBPACK_IMPORTED_MODULE_1__["GL"].UNSIGNED_SHORT,
    value: positions,
    size: 3,
    normalized: true
  };
}

// Pre-scale quantized positions on CPU
function decodeQuantizedPositions(tile, positions) {
  const scratchPosition = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
  const decodedArray = new Float32Array(tile.pointCount * 3);

  for (let i = 0; i < tile.pointCount; i++) {
    // POSITION = POSITION_QUANTIZED / 65535.0 * QUANTIZED_VOLUME_SCALE + QUANTIZED_VOLUME_OFFSET
    scratchPosition
      .set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2])
      .scale(1 / tile.quantizedRange)
      .multiply(tile.quantizedVolumeScale)
      .add(tile.quantizedVolumeOffset)
      .toArray(decodedArray, i * 3);
  }

  return decodedArray;
}


/***/ }),

/***/ "./src/parsers/helpers/parse-3d-tile-gltf-view.js":
/*!********************************************************!*\
  !*** ./src/parsers/helpers/parse-3d-tile-gltf-view.js ***!
  \********************************************************/
/*! exports provided: GLTF_FORMAT, parse3DTileGLTFViewSync, extractGLTF */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLTF_FORMAT", function() { return GLTF_FORMAT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse3DTileGLTFViewSync", function() { return parse3DTileGLTFViewSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractGLTF", function() { return extractGLTF; });
// This file is derived from the Cesium code base under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md

/* global TextDecoder */

// TODO - should we automatically parse the embedded glTF or leave it to the app?
// - I.e. some apps might work directly on a GLB, in that case no need for us to decode...
// - And if we decode, do we still keep the GLB in case it is needed?
// - Do we add an option to control this?
// - Also, should we have hard dependency on gltf module or use injection or auto-discovery for gltf parser?
//
// import {parseGLTFSync} from '@loaders.gl/gltf';

const GLTF_FORMAT = {
  URI: 0,
  EMBEDDED: 1
};

function parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset) {
  // Assume glTF consumes rest of tile
  const gltfByteLength = tile.byteOffset + tile.byteLength - byteOffset;
  if (gltfByteLength === 0) {
    throw new Error('glTF byte length must be greater than 0.');
  }

  // TODO - We can avoid copy if already 4-byte aligned...
  // if (byteOffset % 4 === 0) {
  //   tile.gltfArrayBuffer = arrayBuffer;
  //   tile.gltfByteOffset = byteOffset;
  //   tile.gltfByteLength = gltfByteLength;
  // } else {
  // Create a copy of the glb so that it is 4-byte aligned
  // eslint-disable-next-line
  // console.warn(`${tile.type}: embedded glb is not aligned to a 4-byte boundary.`);
  const subArray = new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + gltfByteLength);
  const arrayCopy = new Uint8Array(subArray);
  tile.gltfArrayBuffer = arrayCopy.buffer;
  tile.gltfByteOffset = 0;
  tile.gltfByteLength = gltfByteLength;
  // }

  // glTF models need to be rotated from Y to Z up
  // https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#y-up-to-z-up
  tile.rotateYtoZ = true;

  // Entire tile is consumed
  return tile.byteOffset + tile.byteLength;
}

function extractGLTF(tile, gltfFormat, options) {
  switch (gltfFormat) {
    case GLTF_FORMAT.URI:
      // We need to remove padding from the end of the model URL in case this tile was part of a composite tile.
      // This removes all white space and null characters from the end of the string.
      const gltfUrlBytes = new Uint8Array(tile.gltfArrayBuffer, tile.gltfByteOffset);
      const textDecoder = new TextDecoder();
      const gltfUrl = textDecoder.decode(gltfUrlBytes);
      tile.gltfUrl = gltfUrl.replace(/[\s\0]+$/, '');
      break;
    case GLTF_FORMAT.EMBEDDED:
      tile.gltf = {};
      // parseGLTFSync(tile.gltf, tile.gltfArrayBuffer, tile.gltfByteOffset, options);
      // delete tile.gltfArrayBuffer;
      // delete tile.gltfByteOffset;
      // delete tile.gltfByteLength;
      break;
    default:
      throw new Error(`i3dm: glTF format ${gltfFormat}: Must be 0 (uri) or 1 (embedded)`);
  }
}


/***/ }),

/***/ "./src/parsers/helpers/parse-3d-tile-header.js":
/*!*****************************************************!*\
  !*** ./src/parsers/helpers/parse-3d-tile-header.js ***!
  \*****************************************************/
/*! exports provided: parse3DTileHeaderSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse3DTileHeaderSync", function() { return parse3DTileHeaderSync; });
// This file is derived from the Cesium code base under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md

const SIZEOF_UINT32 = 4;

/* PARSE FIXED HEADER:
Populates
  magic, // identifies type of tile
  type, // String version of magic
  version,
  byteLength
 */
function parse3DTileHeaderSync(tile, arrayBuffer, byteOffset = 0) {
  const view = new DataView(arrayBuffer);

  tile.magic = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT32;

  tile.version = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT32;

  tile.byteLength = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT32;

  // TODO - move version check into each tile parser?
  if (tile.version !== 1) {
    throw new Error(`3D Tile Version ${tile.version} not supported`);
  }

  return byteOffset; // Indicates where the parsing ended
}


/***/ }),

/***/ "./src/parsers/helpers/parse-3d-tile-tables.js":
/*!*****************************************************!*\
  !*** ./src/parsers/helpers/parse-3d-tile-tables.js ***!
  \*****************************************************/
/*! exports provided: parse3DTileTablesHeaderSync, parse3DTileTablesSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse3DTileTablesHeaderSync", function() { return parse3DTileTablesHeaderSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse3DTileTablesSync", function() { return parse3DTileTablesSync; });
/* harmony import */ var _parse_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse-utils */ "./src/parsers/helpers/parse-utils.js");
// This file is derived from the Cesium code base under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md



const SIZEOF_UINT32 = 4;

// eslint-disable-next-line max-statements
function parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset) {
  const view = new DataView(arrayBuffer);

  tile.featureTableJsonByteLength = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT32;

  tile.featureTableBinaryByteLength = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT32;

  tile.batchTableJsonByteLength = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT32;

  tile.batchTableBinaryByteLength = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT32;

  return byteOffset;
}

function parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options) {
  byteOffset = parse3DTileFeatureTable(tile, arrayBuffer, byteOffset, options);
  byteOffset = parse3DTileBatchTable(tile, arrayBuffer, byteOffset, options);
  return byteOffset;
}

function parse3DTileFeatureTable(tile, arrayBuffer, byteOffset, options) {
  const {featureTableJsonByteLength, featureTableBinaryByteLength} = tile;

  tile.featureTableJson = {
    BATCH_LENGTH: 0
  };

  if (featureTableJsonByteLength > 0) {
    const featureTableString = Object(_parse_utils__WEBPACK_IMPORTED_MODULE_0__["getStringFromArrayBuffer"])(
      arrayBuffer,
      byteOffset,
      featureTableJsonByteLength
    );
    tile.featureTableJson = JSON.parse(featureTableString);
  }
  byteOffset += featureTableJsonByteLength;

  tile.featureTableBinary = new Uint8Array(arrayBuffer, byteOffset, featureTableBinaryByteLength);
  byteOffset += featureTableBinaryByteLength;

  /*
  const featureTable = parseFeatureTable(featureTableJson, featureTableBinary);

  const batchLength = featureTable.getGlobalProperty('BATCH_LENGTH');
  featureTable.featuresLength = batchLength;
  */

  return byteOffset;
}

function parse3DTileBatchTable(tile, arrayBuffer, byteOffset, options) {
  const {batchTableJsonByteLength, batchTableBinaryByteLength} = tile;

  if (batchTableJsonByteLength > 0) {
    const batchTableString = Object(_parse_utils__WEBPACK_IMPORTED_MODULE_0__["getStringFromArrayBuffer"])(
      arrayBuffer,
      byteOffset,
      batchTableJsonByteLength
    );
    tile.batchTableJson = JSON.parse(batchTableString);
    byteOffset += batchTableJsonByteLength;

    if (batchTableBinaryByteLength > 0) {
      // Has a batch table binary
      tile.batchTableBinary = new Uint8Array(arrayBuffer, byteOffset, batchTableBinaryByteLength);
      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed
      tile.batchTableBinary = new Uint8Array(tile.batchTableBinary);

      byteOffset += batchTableBinaryByteLength;
    }
  }

  return byteOffset;
}


/***/ }),

/***/ "./src/parsers/helpers/parse-utils.js":
/*!********************************************!*\
  !*** ./src/parsers/helpers/parse-utils.js ***!
  \********************************************/
/*! exports provided: getStringFromArrayBuffer, getStringFromTypedArray, getMagicString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStringFromArrayBuffer", function() { return getStringFromArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStringFromTypedArray", function() { return getStringFromTypedArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMagicString", function() { return getMagicString; });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../loader-utils/src/index.js");
// This file is derived from the Cesium code base under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md

/* global TextDecoder */


// Decode the JSON binary array into clear text
function getStringFromArrayBuffer(arrayBuffer, byteOffset, byteLength) {
  Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(arrayBuffer instanceof ArrayBuffer);
  const textDecoder = new TextDecoder('utf8');
  const typedArray = new Uint8Array(arrayBuffer, byteOffset, byteLength);
  const string = textDecoder.decode(typedArray);
  return string;
}

// Decode the JSON binary array into clear text
function getStringFromTypedArray(typedArray) {
  Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(ArrayBuffer.isView(typedArray));
  const textDecoder = new TextDecoder('utf8');
  const string = textDecoder.decode(typedArray);
  return string;
}

function getMagicString(arrayBuffer, byteOffset = 0) {
  const dataView = new DataView(arrayBuffer);
  return `\
${String.fromCharCode(dataView.getUint8(byteOffset + 0))}\
${String.fromCharCode(dataView.getUint8(byteOffset + 1))}\
${String.fromCharCode(dataView.getUint8(byteOffset + 2))}\
${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;
}


/***/ }),

/***/ "./src/parsers/parse-3d-tile-batched-model.js":
/*!****************************************************!*\
  !*** ./src/parsers/parse-3d-tile-batched-model.js ***!
  \****************************************************/
/*! exports provided: parseBatchedModel3DTile, parseBatchedModel3DTileSync, parseBatchedModel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseBatchedModel3DTile", function() { return parseBatchedModel3DTile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseBatchedModel3DTileSync", function() { return parseBatchedModel3DTileSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseBatchedModel", function() { return parseBatchedModel; });
/* harmony import */ var _loaders_gl_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/math */ "../math/src/index.js");
/* harmony import */ var _classes_tile_3d_feature_table__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../classes/tile-3d-feature-table */ "./src/classes/tile-3d-feature-table.js");
/* harmony import */ var _helpers_parse_3d_tile_header__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers/parse-3d-tile-header */ "./src/parsers/helpers/parse-3d-tile-header.js");
/* harmony import */ var _helpers_parse_3d_tile_tables__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers/parse-3d-tile-tables */ "./src/parsers/helpers/parse-3d-tile-tables.js");
/* harmony import */ var _helpers_parse_3d_tile_gltf_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers/parse-3d-tile-gltf-view */ "./src/parsers/helpers/parse-3d-tile-gltf-view.js");
// This file is derived from the Cesium code base under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md

 // math.gl/geometry;

// import Tile3DBatchTable from '../classes/tile-3d-batch-table';





async function parseBatchedModel3DTile(tile, arrayBuffer, byteOffset, options, context) {
  byteOffset = parseBatchedModel(tile, arrayBuffer, byteOffset, options, context);
  await Object(_helpers_parse_3d_tile_gltf_view__WEBPACK_IMPORTED_MODULE_4__["extractGLTF"])(tile, _helpers_parse_3d_tile_gltf_view__WEBPACK_IMPORTED_MODULE_4__["GLTF_FORMAT"].EMBEDDED, options, context);
  return byteOffset;
}

function parseBatchedModel3DTileSync(tile, arrayBuffer, byteOffset, options, context) {
  byteOffset = parseBatchedModel(tile, arrayBuffer, byteOffset, options, context);
  Object(_helpers_parse_3d_tile_gltf_view__WEBPACK_IMPORTED_MODULE_4__["extractGLTF"])(tile, _helpers_parse_3d_tile_gltf_view__WEBPACK_IMPORTED_MODULE_4__["GLTF_FORMAT"].EMBEDDED, options, context);
  return byteOffset;
}

function parseBatchedModel(tile, arrayBuffer, byteOffset, options, context) {
  byteOffset = Object(_helpers_parse_3d_tile_header__WEBPACK_IMPORTED_MODULE_2__["parse3DTileHeaderSync"])(tile, arrayBuffer, byteOffset, options);

  byteOffset = Object(_helpers_parse_3d_tile_tables__WEBPACK_IMPORTED_MODULE_3__["parse3DTileTablesHeaderSync"])(tile, arrayBuffer, byteOffset, options);
  byteOffset = Object(_helpers_parse_3d_tile_tables__WEBPACK_IMPORTED_MODULE_3__["parse3DTileTablesSync"])(tile, arrayBuffer, byteOffset, options);

  byteOffset = Object(_helpers_parse_3d_tile_gltf_view__WEBPACK_IMPORTED_MODULE_4__["parse3DTileGLTFViewSync"])(tile, arrayBuffer, byteOffset, options);

  const featureTable = new _classes_tile_3d_feature_table__WEBPACK_IMPORTED_MODULE_1__["default"](tile.featureTableJson, tile.featureTableBinary);
  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', _loaders_gl_math__WEBPACK_IMPORTED_MODULE_0__["GL"].FLOAT, 3);

  Object(_helpers_parse_3d_tile_gltf_view__WEBPACK_IMPORTED_MODULE_4__["extractGLTF"])(tile, _helpers_parse_3d_tile_gltf_view__WEBPACK_IMPORTED_MODULE_4__["GLTF_FORMAT"].EMBEDDED, options, context);

  return byteOffset;
}


/***/ }),

/***/ "./src/parsers/parse-3d-tile-composite.js":
/*!************************************************!*\
  !*** ./src/parsers/parse-3d-tile-composite.js ***!
  \************************************************/
/*! exports provided: parseComposite3DTile, parseComposite3DTileSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseComposite3DTile", function() { return parseComposite3DTile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseComposite3DTileSync", function() { return parseComposite3DTileSync; });
/* harmony import */ var _helpers_parse_3d_tile_header__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers/parse-3d-tile-header */ "./src/parsers/helpers/parse-3d-tile-header.js");
// This file is derived from the Cesium code base under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md

// Reference code:
// https://github.com/AnalyticalGraphicsInc/cesium/blob/master/Source/Scene/Composite3DTileContent.js#L182



// eslint-disable-next-line max-params
async function parseComposite3DTile(
  tile,
  arrayBuffer,
  byteOffset,
  options,
  context,
  parse3DTile
) {
  byteOffset = Object(_helpers_parse_3d_tile_header__WEBPACK_IMPORTED_MODULE_0__["parse3DTileHeaderSync"])(tile, arrayBuffer, byteOffset, options);

  const view = new DataView(arrayBuffer);

  // Extract number of tiles
  tile.tilesLength = view.getUint32(byteOffset, true);
  byteOffset += 4;

  // extract each tile from the byte stream
  tile.tiles = [];
  while (tile.tiles.length < tile.tilesLength && tile.byteLength - byteOffset > 12) {
    const subtile = {};
    tile.tiles.push(subtile);
    byteOffset = await parse3DTile(arrayBuffer, byteOffset, options, context, subtile);
    // TODO - do we need to add any padding in between tiles?
  }

  return byteOffset;
}

// eslint-disable-next-line max-params
function parseComposite3DTileSync(
  tile,
  arrayBuffer,
  byteOffset,
  options,
  context,
  parse3DTileSync
) {
  byteOffset = Object(_helpers_parse_3d_tile_header__WEBPACK_IMPORTED_MODULE_0__["parse3DTileHeaderSync"])(tile, arrayBuffer, byteOffset, options);

  const view = new DataView(arrayBuffer);

  // Extract number of tiles
  tile.tilesLength = view.getUint32(byteOffset, true);
  byteOffset += 4;

  // extract each tile from the byte stream
  tile.tiles = [];
  while (tile.tiles.length < tile.tilesLength && tile.byteLength - byteOffset > 12) {
    const subtile = {};
    tile.tiles.push(subtile);
    byteOffset = parse3DTileSync(arrayBuffer, byteOffset, options, context, subtile);
    // TODO - do we need to add any padding in between tiles?
  }

  return byteOffset;
}


/***/ }),

/***/ "./src/parsers/parse-3d-tile-instanced-model.js":
/*!******************************************************!*\
  !*** ./src/parsers/parse-3d-tile-instanced-model.js ***!
  \******************************************************/
/*! exports provided: parseInstancedModel3DTile, parseInstancedModel3DTileSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseInstancedModel3DTile", function() { return parseInstancedModel3DTile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseInstancedModel3DTileSync", function() { return parseInstancedModel3DTileSync; });
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");
/* harmony import */ var _math_gl_geospatial__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @math.gl/geospatial */ "../../node_modules/@math.gl/geospatial/dist/esm/index.js");
/* harmony import */ var _loaders_gl_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @loaders.gl/math */ "../math/src/index.js");
/* harmony import */ var _classes_tile_3d_feature_table__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../classes/tile-3d-feature-table */ "./src/classes/tile-3d-feature-table.js");
/* harmony import */ var _classes_tile_3d_batch_table__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../classes/tile-3d-batch-table */ "./src/classes/tile-3d-batch-table.js");
/* harmony import */ var _helpers_parse_3d_tile_header__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./helpers/parse-3d-tile-header */ "./src/parsers/helpers/parse-3d-tile-header.js");
/* harmony import */ var _helpers_parse_3d_tile_tables__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./helpers/parse-3d-tile-tables */ "./src/parsers/helpers/parse-3d-tile-tables.js");
/* harmony import */ var _helpers_parse_3d_tile_gltf_view__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./helpers/parse-3d-tile-gltf-view */ "./src/parsers/helpers/parse-3d-tile-gltf-view.js");
// This file is derived from the Cesium code base under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md



 // 'math.gl/geometry';







async function parseInstancedModel3DTile(tile, arrayBuffer, byteOffset, options, context) {
  byteOffset = parseInstancedModel(tile, arrayBuffer, byteOffset, options, context);
  await Object(_helpers_parse_3d_tile_gltf_view__WEBPACK_IMPORTED_MODULE_7__["extractGLTF"])(tile, tile.gltfFormat, options, context);
  return byteOffset;
}

// Reference code:
// https://github.com/AnalyticalGraphicsInc/cesium/blob/master/Source/Scene/Instanced3DModel3DTileContent.js#L190
function parseInstancedModel3DTileSync(tile, arrayBuffer, byteOffset, options, context) {
  byteOffset = parseInstancedModel(tile, arrayBuffer, byteOffset, options, context);
  // extractGLTFSync(tile, tile.gltfFormat, options, context);
  return byteOffset;
}

function parseInstancedModel(tile, arrayBuffer, byteOffset, options, context) {
  byteOffset = Object(_helpers_parse_3d_tile_header__WEBPACK_IMPORTED_MODULE_5__["parse3DTileHeaderSync"])(tile, arrayBuffer, byteOffset, options);
  if (tile.version !== 1) {
    throw new Error(`Instanced 3D Model version ${tile.version} is not supported`);
  }

  byteOffset = Object(_helpers_parse_3d_tile_tables__WEBPACK_IMPORTED_MODULE_6__["parse3DTileTablesHeaderSync"])(tile, arrayBuffer, byteOffset, options);

  const view = new DataView(arrayBuffer);

  tile.gltfFormat = view.getUint32(byteOffset, true);
  byteOffset += 4;

  // PARSE FEATURE TABLE
  byteOffset = Object(_helpers_parse_3d_tile_tables__WEBPACK_IMPORTED_MODULE_6__["parse3DTileTablesSync"])(tile, arrayBuffer, byteOffset, options);

  byteOffset = Object(_helpers_parse_3d_tile_gltf_view__WEBPACK_IMPORTED_MODULE_7__["parse3DTileGLTFViewSync"])(tile, arrayBuffer, byteOffset, options);

  // TODO - Is the feature table sometimes optional or can check be moved into table header parser?
  if (tile.featureTableJsonByteLength === 0) {
    throw new Error('i3dm parser: featureTableJsonByteLength is zero.');
  }

  const featureTable = new _classes_tile_3d_feature_table__WEBPACK_IMPORTED_MODULE_3__["default"](tile.featureTableJson, tile.featureTableBinary);

  const instancesLength = featureTable.getGlobalProperty('INSTANCES_LENGTH');
  featureTable.featuresLength = instancesLength;

  if (!Number.isFinite(instancesLength)) {
    throw new Error('i3dm parser: INSTANCES_LENGTH must be defined');
  }

  tile.eastNorthUp = featureTable.getGlobalProperty('EAST_NORTH_UP');
  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', _loaders_gl_math__WEBPACK_IMPORTED_MODULE_2__["GL"].FLOAT, 3);

  const batchTable = new _classes_tile_3d_batch_table__WEBPACK_IMPORTED_MODULE_4__["default"](
    tile.batchTableJson,
    tile.batchTableBinary,
    instancesLength
  );

  extractInstancedAttributes(tile, featureTable, batchTable, instancesLength);

  return byteOffset;
}

// eslint-disable-next-line max-statements, complexity
function extractInstancedAttributes(tile, featureTable, batchTable, instancesLength) {
  // Create model instance collection
  const collectionOptions = {
    instances: new Array(instancesLength),
    batchTable: tile._batchTable,
    cull: false, // Already culled by 3D Tiles
    url: undefined,
    // requestType: RequestType.TILES3D,
    gltf: undefined,
    basePath: undefined,
    incrementallyLoadTextures: false,
    // TODO - tileset is not available at this stage, tile is parsed independently
    // upAxis: (tileset && tileset._gltfUpAxis) || [0, 1, 0],
    forwardAxis: [1, 0, 0]
  };

  const instances = collectionOptions.instances;
  const instancePosition = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
  const instanceNormalRight = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
  const instanceNormalUp = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
  const instanceNormalForward = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
  const instanceRotation = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix3"]();
  const instanceQuaternion = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();
  const instanceScale = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
  const instanceTranslationRotationScale = {};
  const instanceTransform = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
  const scratch1 = [];
  const scratch2 = [];
  const scratchVector1 = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
  const scratchVector2 = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

  for (let i = 0; i < instancesLength; i++) {
    let position;

    // Get the instance position
    if (featureTable.hasProperty('POSITION')) {
      position = featureTable.getProperty('POSITION', _loaders_gl_math__WEBPACK_IMPORTED_MODULE_2__["GL"].FLOAT, 3, i, instancePosition);
    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {
      position = featureTable.getProperty(
        'POSITION_QUANTIZED',
        _loaders_gl_math__WEBPACK_IMPORTED_MODULE_2__["GL"].UNSIGNED_SHORT,
        3,
        i,
        instancePosition
      );

      const quantizedVolumeOffset = featureTable.getGlobalProperty(
        'QUANTIZED_VOLUME_OFFSET',
        _loaders_gl_math__WEBPACK_IMPORTED_MODULE_2__["GL"].FLOAT,
        3,
        scratchVector1
      );
      if (!quantizedVolumeOffset) {
        throw new Error(
          'i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.'
        );
      }

      const quantizedVolumeScale = featureTable.getGlobalProperty(
        'QUANTIZED_VOLUME_SCALE',
        _loaders_gl_math__WEBPACK_IMPORTED_MODULE_2__["GL"].FLOAT,
        3,
        scratchVector2
      );
      if (!quantizedVolumeScale) {
        throw new Error(
          'i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.'
        );
      }

      const MAX_UNSIGNED_SHORT = 65535.0;
      for (let j = 0; j < 3; j++) {
        position[j] =
          (position[j] / MAX_UNSIGNED_SHORT) * quantizedVolumeScale[j] + quantizedVolumeOffset[j];
      }
    }

    if (!position) {
      throw new Error('i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.');
    }

    instancePosition.copy(position);
    instanceTranslationRotationScale.translation = instancePosition;

    // Get the instance rotation
    tile.normalUp = featureTable.getProperty('NORMAL_UP', _loaders_gl_math__WEBPACK_IMPORTED_MODULE_2__["GL"].FLOAT, 3, i, scratch1);
    tile.normalRight = featureTable.getProperty('NORMAL_RIGHT', _loaders_gl_math__WEBPACK_IMPORTED_MODULE_2__["GL"].FLOAT, 3, i, scratch2);

    const hasCustomOrientation = false;
    if (tile.normalUp) {
      if (!tile.normalRight) {
        throw new Error('i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.');
      }
      // Vector3.unpack(normalUp, 0, instanceNormalUp);
      // Vector3.unpack(normalRight, 0, instanceNormalRight);
      tile.hasCustomOrientation = true;
    } else {
      tile.octNormalUp = featureTable.getProperty(
        'NORMAL_UP_OCT32P',
        _loaders_gl_math__WEBPACK_IMPORTED_MODULE_2__["GL"].UNSIGNED_SHORT,
        2,
        scratch1
      );
      tile.octNormalRight = featureTable.getProperty(
        'NORMAL_RIGHT_OCT32P',
        _loaders_gl_math__WEBPACK_IMPORTED_MODULE_2__["GL"].UNSIGNED_SHORT,
        2,
        scratch2
      );

      if (tile.octNormalUp) {
        if (!tile.octNormalRight) {
          throw new Error(
            'i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P'
          );
        }

        throw new Error('i3dm: oct-encoded orientation not implemented');
        /*
        AttributeCompression.octDecodeInRange(octNormalUp[0], octNormalUp[1], 65535, instanceNormalUp);
        AttributeCompression.octDecodeInRange(octNormalRight[0], octNormalRight[1], 65535, instanceNormalRight);
        hasCustomOrientation = true;
        */
      } else if (tile.eastNorthUp) {
        _math_gl_geospatial__WEBPACK_IMPORTED_MODULE_1__["Ellipsoid"].WGS84.eastNorthUpToFixedFrame(instancePosition, instanceTransform);
        instanceTransform.getRotationMatrix3(instanceRotation);
      } else {
        instanceRotation.identity();
      }
    }

    if (hasCustomOrientation) {
      instanceNormalForward
        .copy(instanceNormalRight)
        .cross(instanceNormalUp)
        .normalize();
      instanceRotation.setColumn(0, instanceNormalRight);
      instanceRotation.setColumn(1, instanceNormalUp);
      instanceRotation.setColumn(2, instanceNormalForward);
    }

    instanceQuaternion.fromMatrix3(instanceRotation);
    instanceTranslationRotationScale.rotation = instanceQuaternion;

    // Get the instance scale
    instanceScale.set(1.0, 1.0, 1.0);
    const scale = featureTable.getProperty('SCALE', _loaders_gl_math__WEBPACK_IMPORTED_MODULE_2__["GL"].FLOAT, 1, i);
    if (Number.isFinite(scale)) {
      instanceScale.multiplyByScalar(scale);
    }
    const nonUniformScale = featureTable.getProperty('SCALE_NON_UNIFORM', _loaders_gl_math__WEBPACK_IMPORTED_MODULE_2__["GL"].FLOAT, 3, i, scratch1);
    if (nonUniformScale) {
      instanceScale.scale(nonUniformScale);
    }

    instanceTranslationRotationScale.scale = instanceScale;

    // Get the batchId
    let batchId = featureTable.getProperty('BATCH_ID', _loaders_gl_math__WEBPACK_IMPORTED_MODULE_2__["GL"].UNSIGNED_SHORT, 1, i);
    if (batchId === undefined) {
      // If BATCH_ID semantic is undefined, batchId is just the instance number
      batchId = i;
    }

    const rotationMatrix = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]().fromQuaternion(instanceTranslationRotationScale.rotation);

    // Create the model matrix and the instance
    instanceTransform.identity();
    instanceTransform.translate(instanceTranslationRotationScale.translation);
    instanceTransform.multiplyRight(rotationMatrix);
    instanceTransform.scale(instanceTranslationRotationScale.scale);

    const modelMatrix = instanceTransform.clone();
    instances[i] = {
      modelMatrix,
      batchId
    };
  }

  tile.instances = instances;
}


/***/ }),

/***/ "./src/parsers/parse-3d-tile-point-cloud.js":
/*!**************************************************!*\
  !*** ./src/parsers/parse-3d-tile-point-cloud.js ***!
  \**************************************************/
/*! exports provided: parsePointCloud3DTile, parsePointCloud3DTileSync, loadDraco */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parsePointCloud3DTile", function() { return parsePointCloud3DTile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parsePointCloud3DTileSync", function() { return parsePointCloud3DTileSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadDraco", function() { return loadDraco; });
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");
/* harmony import */ var _loaders_gl_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/math */ "../math/src/index.js");
/* harmony import */ var _classes_tile_3d_feature_table__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../classes/tile-3d-feature-table */ "./src/classes/tile-3d-feature-table.js");
/* harmony import */ var _classes_tile_3d_batch_table__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../classes/tile-3d-batch-table */ "./src/classes/tile-3d-batch-table.js");
/* harmony import */ var _helpers_parse_3d_tile_header__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers/parse-3d-tile-header */ "./src/parsers/helpers/parse-3d-tile-header.js");
/* harmony import */ var _helpers_parse_3d_tile_tables__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./helpers/parse-3d-tile-tables */ "./src/parsers/helpers/parse-3d-tile-tables.js");
/* harmony import */ var _helpers_normalize_3d_tile_colors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./helpers/normalize-3d-tile-colors */ "./src/parsers/helpers/normalize-3d-tile-colors.js");
/* harmony import */ var _helpers_normalize_3d_tile_normals__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./helpers/normalize-3d-tile-normals */ "./src/parsers/helpers/normalize-3d-tile-normals.js");
/* harmony import */ var _helpers_normalize_3d_tile_positions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./helpers/normalize-3d-tile-positions */ "./src/parsers/helpers/normalize-3d-tile-positions.js");
// This file is derived from the Cesium code base under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md


 // 'math.gl/geometry';









async function parsePointCloud3DTile(tile, arrayBuffer, byteOffset, options, context) {
  byteOffset = Object(_helpers_parse_3d_tile_header__WEBPACK_IMPORTED_MODULE_4__["parse3DTileHeaderSync"])(tile, arrayBuffer, byteOffset, options);
  byteOffset = Object(_helpers_parse_3d_tile_tables__WEBPACK_IMPORTED_MODULE_5__["parse3DTileTablesHeaderSync"])(tile, arrayBuffer, byteOffset, options);
  byteOffset = Object(_helpers_parse_3d_tile_tables__WEBPACK_IMPORTED_MODULE_5__["parse3DTileTablesSync"])(tile, arrayBuffer, byteOffset, options);
  initializeTile(tile);

  const {featureTable, batchTable} = parsePointCloudTables(tile);

  await parseDraco(tile, featureTable, batchTable, options, context);

  parsePositions(tile, featureTable, options);
  parseColors(tile, featureTable, batchTable, options);
  parseNormals(tile, featureTable, options);

  return byteOffset;
}

// TODO - is there really a need for sync tile parsing?
function parsePointCloud3DTileSync(tile, arrayBuffer, byteOffset, options, context) {
  byteOffset = Object(_helpers_parse_3d_tile_header__WEBPACK_IMPORTED_MODULE_4__["parse3DTileHeaderSync"])(tile, arrayBuffer, byteOffset, options);
  byteOffset = Object(_helpers_parse_3d_tile_tables__WEBPACK_IMPORTED_MODULE_5__["parse3DTileTablesHeaderSync"])(tile, arrayBuffer, byteOffset, options);
  byteOffset = Object(_helpers_parse_3d_tile_tables__WEBPACK_IMPORTED_MODULE_5__["parse3DTileTablesSync"])(tile, arrayBuffer, byteOffset, options);

  initializeTile(tile);

  const {featureTable} = parsePointCloudTables(tile);

  // parseDracoSync(tile, featureTable, batchTable, options);

  parsePositions(tile, featureTable, options);
  parseColors(tile, featureTable, options);
  parseNormals(tile, featureTable, options);

  return byteOffset;
}

function initializeTile(tile) {
  // Initialize point cloud tile defaults
  tile.attributes = {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  };
  tile.isQuantized = false;
  tile.isTranslucent = false;
  tile.isRGB565 = false;
  tile.isOctEncoded16P = false;
}

function parsePointCloudTables(tile) {
  const featureTable = new _classes_tile_3d_feature_table__WEBPACK_IMPORTED_MODULE_2__["default"](tile.featureTableJson, tile.featureTableBinary);

  const pointsLength = featureTable.getGlobalProperty('POINTS_LENGTH');
  if (!Number.isFinite(pointsLength)) {
    throw new Error('POINTS_LENGTH must be defined');
  }
  featureTable.featuresLength = pointsLength;

  tile.featuresLength = pointsLength;
  tile.pointsLength = pointsLength;
  tile.pointCount = pointsLength;

  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', _loaders_gl_math__WEBPACK_IMPORTED_MODULE_1__["GL"].FLOAT, 3);

  const batchTable = parseBatchIds(tile, featureTable);

  return {featureTable, batchTable};
}

function parsePositions(tile, featureTable, options) {
  if (!tile.attributes.positions) {
    if (featureTable.hasProperty('POSITION')) {
      tile.attributes.positions = featureTable.getPropertyArray('POSITION', _loaders_gl_math__WEBPACK_IMPORTED_MODULE_1__["GL"].FLOAT, 3);
    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {
      const positions = featureTable.getPropertyArray('POSITION_QUANTIZED', _loaders_gl_math__WEBPACK_IMPORTED_MODULE_1__["GL"].UNSIGNED_SHORT, 3);

      tile.isQuantized = true;
      tile.quantizedRange = (1 << 16) - 1;

      tile.quantizedVolumeScale = featureTable.getGlobalProperty(
        'QUANTIZED_VOLUME_SCALE',
        _loaders_gl_math__WEBPACK_IMPORTED_MODULE_1__["GL"].FLOAT,
        3
      );
      if (!tile.quantizedVolumeScale) {
        throw new Error('QUANTIZED_VOLUME_SCALE must be defined for quantized positions.');
      }

      tile.quantizedVolumeOffset = featureTable.getGlobalProperty(
        'QUANTIZED_VOLUME_OFFSET',
        _loaders_gl_math__WEBPACK_IMPORTED_MODULE_1__["GL"].FLOAT,
        3
      );
      if (!tile.quantizedVolumeOffset) {
        throw new Error('QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.');
      }

      tile.attributes.positions = Object(_helpers_normalize_3d_tile_positions__WEBPACK_IMPORTED_MODULE_8__["normalize3DTilePositionAttribute"])(tile, positions, options);
    }
  }

  if (!tile.attributes.positions) {
    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');
  }
}

function parseColors(tile, featureTable, batchTable) {
  if (!tile.attributes.colors) {
    let colors = null;
    if (featureTable.hasProperty('RGBA')) {
      colors = featureTable.getPropertyArray('RGBA', _loaders_gl_math__WEBPACK_IMPORTED_MODULE_1__["GL"].UNSIGNED_BYTE, 4);
      tile.isTranslucent = true;
    } else if (featureTable.hasProperty('RGB')) {
      colors = featureTable.getPropertyArray('RGB', _loaders_gl_math__WEBPACK_IMPORTED_MODULE_1__["GL"].UNSIGNED_BYTE, 3);
    } else if (featureTable.hasProperty('RGB565')) {
      colors = featureTable.getPropertyArray('RGB565', _loaders_gl_math__WEBPACK_IMPORTED_MODULE_1__["GL"].UNSIGNED_SHORT, 1);
      tile.isRGB565 = true;
    }

    tile.attributes.colors = Object(_helpers_normalize_3d_tile_colors__WEBPACK_IMPORTED_MODULE_6__["normalize3DTileColorAttribute"])(tile, colors, batchTable);
  }

  if (featureTable.hasProperty('CONSTANT_RGBA')) {
    tile.constantRGBA = featureTable.getGlobalProperty('CONSTANT_RGBA', _loaders_gl_math__WEBPACK_IMPORTED_MODULE_1__["GL"].UNSIGNED_BYTE, 4);
  }
}

function parseNormals(tile, featureTable) {
  if (!tile.attributes.normals) {
    let normals = null;
    if (featureTable.hasProperty('NORMAL')) {
      normals = featureTable.getPropertyArray('NORMAL', _loaders_gl_math__WEBPACK_IMPORTED_MODULE_1__["GL"].FLOAT, 3);
    } else if (featureTable.hasProperty('NORMAL_OCT16P')) {
      normals = featureTable.getPropertyArray('NORMAL_OCT16P', _loaders_gl_math__WEBPACK_IMPORTED_MODULE_1__["GL"].UNSIGNED_BYTE, 2);
      tile.isOctEncoded16P = true;
    }

    tile.attributes.normals = Object(_helpers_normalize_3d_tile_normals__WEBPACK_IMPORTED_MODULE_7__["normalize3DTileNormalAttribute"])(tile, normals);
  }
}

function parseBatchIds(tile, featureTable) {
  let batchTable = null;
  if (!tile.batchIds && featureTable.hasProperty('BATCH_ID')) {
    tile.batchIds = featureTable.getPropertyArray('BATCH_ID', _loaders_gl_math__WEBPACK_IMPORTED_MODULE_1__["GL"].UNSIGNED_SHORT, 1);

    if (tile.batchIds) {
      const batchFeatureLength = featureTable.getGlobalProperty('BATCH_LENGTH');
      if (!batchFeatureLength) {
        throw new Error('Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.');
      }
      const {batchTableJson, batchTableBinary} = tile;
      batchTable = new _classes_tile_3d_batch_table__WEBPACK_IMPORTED_MODULE_3__["default"](batchTableJson, batchTableBinary, batchFeatureLength);
    }
  }
  return batchTable;
}

// eslint-disable-next-line complexity
async function parseDraco(tile, featureTable, batchTable, options, context) {
  let dracoBuffer;
  let dracoFeatureTableProperties;
  let dracoBatchTableProperties;
  const batchTableDraco = batchTable && batchTable.getExtension('3DTILES_draco_point_compression');
  if (batchTableDraco) {
    dracoBatchTableProperties = batchTableDraco.properties;
  }

  const featureTableDraco = featureTable.getExtension('3DTILES_draco_point_compression');
  if (featureTableDraco) {
    dracoFeatureTableProperties = featureTableDraco.properties;
    const dracoByteOffset = featureTableDraco.byteOffset;
    const dracoByteLength = featureTableDraco.byteLength;
    if (!dracoFeatureTableProperties || !Number.isFinite(dracoByteOffset) || !dracoByteLength) {
      throw new Error('Draco properties, byteOffset, and byteLength must be defined');
    }

    dracoBuffer = tile.featureTableBinary.slice(dracoByteOffset, dracoByteOffset + dracoByteLength);

    tile.hasPositions = Number.isFinite(dracoFeatureTableProperties.POSITION);
    tile.hasColors =
      Number.isFinite(dracoFeatureTableProperties.RGB) ||
      Number.isFinite(dracoFeatureTableProperties.RGBA);
    tile.hasNormals = Number.isFinite(dracoFeatureTableProperties.NORMAL);
    tile.hasBatchIds = Number.isFinite(dracoFeatureTableProperties.BATCH_ID);
    tile.isTranslucent = Number.isFinite(dracoFeatureTableProperties.RGBA);
  }

  if (dracoBuffer) {
    const dracoData = {
      buffer: dracoBuffer,
      properties: {...dracoFeatureTableProperties, ...dracoBatchTableProperties},
      featureTableProperties: dracoFeatureTableProperties,
      batchTableProperties: dracoBatchTableProperties,
      dequantizeInShader: false
    };

    await loadDraco(tile, dracoData, options, context);
  }
}

// eslint-disable-next-line complexity, max-statements
async function loadDraco(tile, dracoData, options, context) {
  const {parse} = context;
  const data = await parse(dracoData.buffer, options.DracoLoader);
  const decodedPositions = data.attributes.POSITION && data.attributes.POSITION.value;
  const decodedColors = data.attributes.COLOR_0 && data.attributes.COLOR_0.value;
  const decodedNormals = data.attributes.NORMAL && data.attributes.NORMAL.value;
  const decodedBatchIds = data.attributes.BATCH_ID && data.attributes.BATCH_ID.value;
  const isQuantizedDraco = decodedPositions && data.attributes.POSITION.value.quantization;
  const isOctEncodedDraco = decodedNormals && data.attributes.NORMAL.value.quantization;
  if (isQuantizedDraco) {
    // Draco quantization range == quantized volume scale - size in meters of the quantized volume
    // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc
    const quantization = data.POSITION.data.quantization;
    const range = quantization.range;
    tile.quantizedVolumeScale = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"](range, range, range);
    tile.quantizedVolumeOffset = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"](quantization.minValues);
    tile.quantizedRange = (1 << quantization.quantizationBits) - 1.0;
    tile.isQuantizedDraco = true;
  }
  if (isOctEncodedDraco) {
    tile.octEncodedRange = (1 << data.NORMAL.data.quantization.quantizationBits) - 1.0;
    tile.isOctEncodedDraco = true;
  }

  tile.attributes = {
    positions: decodedPositions,
    colors: Object(_helpers_normalize_3d_tile_colors__WEBPACK_IMPORTED_MODULE_6__["normalize3DTileColorAttribute"])(tile, decodedColors),
    normals: decodedNormals,
    batchIds: decodedBatchIds
  };
}

/*
  const batchTable = new Tile3DBatchTable(tile);

  // parseDracoBuffer(tile, featureTable, batchTable);

  if (!tile.attributes.positions) {
    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');
  }
}
/*

  if (!tile.attributes.positions) {
    if (featureTable.hasProperty('POSITION')) {
      tile.attributes.positions = featureTable.getPropertyArray('POSITION', GL.FLOAT, 3);
    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {
      tile.attributes.positions = featureTable.getPropertyArray('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3);


  if (!tile.colors) {
    if (featureTable.hasProperty('RGBA')) {
      tile.colors = featureTable.getPropertyArray('RGBA', GL.UNSIGNED_BYTE, 4);
      tile.isTranslucent = true;
    } else if (featureTable.hasProperty('RGB')) {
      tile.colors = featureTable.getPropertyArray('RGB', GL.UNSIGNED_BYTE, 3);
    } else if (featureTable.hasPropertry('RGB565')) {
      tile.colors = featureTable.getPropertyArray('RGB565', GL.UNSIGNED_SHORT, 1);
      tile.isRGB565 = true;
    }
  }

  if (!tile.attributes.normals) {
    if (featureTable.getPropertry('NORMAL')) {
      tile.attributes.normals = featureTable.getPropertyArray('NORMAL', GL.FLOAT, 3);
    } else if (featureTable.getProperty('NORMAL_OCT16P')) {
      tile.attributes.normals = featureTable.getPropertyArray('NORMAL_OCT16P', GL.UNSIGNED_BYTE, 2);
      tile.isOctEncoded16P = true;
    }
  }

  if (!tile.batchIds) {
    if (featureTable.hasProperty('BATCH_ID')) {
      tile.batchIds = featureTable.getPropertyArray('BATCH_ID', GL.UNSIGNED_SHORT, 1);
    }
  }

  if (!tile.attributes.positions) {
    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');
  }

  if (featureTable.getPropertry('CONSTANT_RGBA')) {
    tile.constantRGBA = featureTable.getGlobalProperty('CONSTANT_RGBA', GL.UNSIGNED_BYTE, 4);
  }

  if (tile.batchIds) {
    const batchLength = featureTable.getGlobalProperty('BATCH_LENGTH');
    if (!defined(batchLength)) {
      throw new Error('Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.');
    }

    if (defined(batchTableBinary)) {
      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed
      batchTableBinary = new Uint8Array(batchTableBinary);
    }

    if (defined(pointCloud._batchTableLoaded)) {
      pointCloud._batchTableLoaded(batchLength, batchTableJson, batchTableBinary);
    }
  }

  // If points are not batched and there are per-point properties, use these properties for styling purposes
  var styleableProperties;
  if (!hasBatchIds && defined(batchTableBinary)) {
    tile.styleableProperties = Cesium3DTileBatchTable.getBinaryProperties(
      pointsLength,
      batchTableJson,
      batchTableBinary
    );
  }

  tile.draco = draco;
}

// Separate parsing and decoding of Draco
export function parseDracoBuffer(tile, featureTable, batchTable) {
  let dracoBuffer;
  let dracoFeatureTableProperties;
  let dracoBatchTableProperties;

  const batchTableDraco = batchTable.getExtension('3DTILES_draco_point_compression');
  if (batchTableDraco) {
    dracoBatchTableProperties = batchTableDraco.properties;
  }

  const featureTableDraco = featureTable.getExtension('3DTILES_draco_point_compression');
  if (featureTableDraco) {
    dracoFeatureTableProperties = featureTableDraco.properties;
    const dracoByteOffset = featureTableDraco.byteOffset;
    const dracoByteLength = featureTableDraco.byteLength;
    if (!dracoFeatureTableProperties || !dracoByteOffset || !dracoByteLength) {
      throw new Error('Draco properties, byteOffset, and byteLength must be defined');
    }

    dracoBuffer = arraySlice(
      featureTableBinary,
      dracoByteOffset,
      dracoByteOffset + dracoByteLength
    );
    tile.hasPositions = dracoFeatureTableProperties.POSITION;
    tile.hasColors = dracoFeatureTableProperties.RGB || dracoFeatureTableProperties.RGBA;
    tile.hasNormals = dracoFeatureTableProperties.NORMAL;
    tile.hasBatchIds = dracoFeatureTableProperties.BATCH_ID;
    tile.isTranslucent = dracoFeatureTableProperties.RGBA;
  }

  if (dracoBuffer) {
    tile.draco = {
      buffer: dracoBuffer,
      properties: {...dracoFeatureTableProperties, ...dracoBatchTableProperties},
      featureTableProperties: dracoFeatureTableProperties,
      batchTableProperties: dracoBatchTableProperties,
      dequantizeInShader: false
    };

    tile.decodingState = DECODING_STATE.NEEDS_DECODE;
  }
}

/*
function decodeDraco(tile, context) {
  if (tile.decodingState === DECODING_STATE.READY) {
    return false;
  }
  if (tile.decodingState === DECODING_STATE.NEEDS_DECODE) {
    var parsedContent = tile._parsedContent;
    var draco = parsedContent.draco;
    var decodePromise = DracoLoader.decodePointCloud(draco, context);
    if (defined(decodePromise)) {
      tile.decodingState = DECODING_STATE.DECODING;
      decodePromise.then(function(result) {
        tile.decodingState = DECODING_STATE.READY;
        var decodedPositions = defined(result.POSITION) ? result.POSITION.array : undefined;
        var decodedRgb = defined(result.RGB) ? result.RGB.array : undefined;
        var decodedRgba = defined(result.RGBA) ? result.RGBA.array : undefined;
        var decodedNormals = defined(result.NORMAL) ? result.NORMAL.array : undefined;
        var decodedBatchIds = defined(result.BATCH_ID) ? result.BATCH_ID.array : undefined;
        var isQuantizedDraco = defined(decodedPositions) && defined(result.POSITION.data.quantization);
        var isOctEncodedDraco = defined(decodedNormals) && defined(result.NORMAL.data.quantization);
        if (isQuantizedDraco) {
          // Draco quantization range == quantized volume scale - size in meters of the quantized volume
          // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc
          var quantization = result.POSITION.data.quantization;
          var range = quantization.range;
          tile._quantizedVolumeScale = Cartesian3.fromElements(range, range, range);
          tile._quantizedVolumeOffset = Cartesian3.unpack(quantization.minValues);
          tile._quantizedRange = (1 << quantization.quantizationBits) - 1.0;
          tile._isQuantizedDraco = true;
        }
        if (isOctEncodedDraco) {
          tile._octEncodedRange = (1 << result.NORMAL.data.quantization.quantizationBits) - 1.0;
          tile._isOctEncodedDraco = true;
        }
        var styleableProperties = parsedContent.styleableProperties;
        var batchTableProperties = draco.batchTableProperties;
        for (var name in batchTableProperties) {
          if (batchTableProperties.hasOwnProperty(name)) {
            var property = result[name];
            if (!defined(styleableProperties)) {
              styleableProperties = {};
            }
            styleableProperties[name] = {
              typedArray : property.array,
              componentCount : property.data.componentsPerAttribute
            };
          }
        }
        parsedContent.positions = defaultValue(decodedPositions, parsedContent.positions);
        parsedContent.colors = defaultValue(defaultValue(decodedRgba, decodedRgb), parsedContent.colors);
        parsedContent.normals = defaultValue(decodedNormals, parsedContent.normals);
        parsedContent.batchIds = defaultValue(decodedBatchIds, parsedContent.batchIds);
        parsedContent.styleableProperties = styleableProperties;
      }).otherwise(function(error) {
        tile.decodingState = DECODING_STATE.FAILED;
        tile._readyPromise.reject(error);
      });
    }
  }
  return true;
}
*/


/***/ }),

/***/ "./src/parsers/parse-3d-tile.js":
/*!**************************************!*\
  !*** ./src/parsers/parse-3d-tile.js ***!
  \**************************************/
/*! exports provided: parse3DTile, parse3DTileSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse3DTile", function() { return parse3DTile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse3DTileSync", function() { return parse3DTileSync; });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants */ "./src/constants.js");
/* harmony import */ var _helpers_parse_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers/parse-utils */ "./src/parsers/helpers/parse-utils.js");
/* harmony import */ var _parse_3d_tile_point_cloud__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parse-3d-tile-point-cloud */ "./src/parsers/parse-3d-tile-point-cloud.js");
/* harmony import */ var _parse_3d_tile_batched_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parse-3d-tile-batched-model */ "./src/parsers/parse-3d-tile-batched-model.js");
/* harmony import */ var _parse_3d_tile_instanced_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parse-3d-tile-instanced-model */ "./src/parsers/parse-3d-tile-instanced-model.js");
/* harmony import */ var _parse_3d_tile_composite__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parse-3d-tile-composite */ "./src/parsers/parse-3d-tile-composite.js");
// This file is derived from the Cesium code base under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md









// Extracts
async function parse3DTile(arrayBuffer, byteOffset = 0, options, context, tile = {}) {
  tile.byteOffset = byteOffset;
  tile.type = Object(_helpers_parse_utils__WEBPACK_IMPORTED_MODULE_1__["getMagicString"])(arrayBuffer, byteOffset);

  switch (tile.type) {
    case _constants__WEBPACK_IMPORTED_MODULE_0__["TILE3D_TYPE"].COMPOSITE:
      // Note: We pass this function as argument so that embedded tiles can be parsed recursively
      return await Object(_parse_3d_tile_composite__WEBPACK_IMPORTED_MODULE_5__["parseComposite3DTile"])(
        tile,
        arrayBuffer,
        byteOffset,
        options,
        context,
        parse3DTile
      );

    case _constants__WEBPACK_IMPORTED_MODULE_0__["TILE3D_TYPE"].BATCHED_3D_MODEL:
      return await Object(_parse_3d_tile_batched_model__WEBPACK_IMPORTED_MODULE_3__["parseBatchedModel3DTile"])(tile, arrayBuffer, byteOffset, options, context);

    case _constants__WEBPACK_IMPORTED_MODULE_0__["TILE3D_TYPE"].INSTANCED_3D_MODEL:
      return await Object(_parse_3d_tile_instanced_model__WEBPACK_IMPORTED_MODULE_4__["parseInstancedModel3DTile"])(tile, arrayBuffer, byteOffset, options, context);

    case _constants__WEBPACK_IMPORTED_MODULE_0__["TILE3D_TYPE"].POINT_CLOUD:
      return await Object(_parse_3d_tile_point_cloud__WEBPACK_IMPORTED_MODULE_2__["parsePointCloud3DTile"])(tile, arrayBuffer, byteOffset, options, context);

    default:
      throw new Error(`3DTileLoader: unknown type ${tile.type}`); // eslint-disable-line
  }
}

function parse3DTileSync(arrayBuffer, byteOffset = 0, options, context, tile = {}) {
  tile.byteOffset = byteOffset;
  tile.type = Object(_helpers_parse_utils__WEBPACK_IMPORTED_MODULE_1__["getMagicString"])(arrayBuffer, byteOffset);

  switch (tile.type) {
    case _constants__WEBPACK_IMPORTED_MODULE_0__["TILE3D_TYPE"].COMPOSITE:
      // Note: We pass this function as argument so that embedded tiles can be parsed recursively
      return Object(_parse_3d_tile_composite__WEBPACK_IMPORTED_MODULE_5__["parseComposite3DTileSync"])(
        tile,
        arrayBuffer,
        byteOffset,
        options,
        context,
        parse3DTileSync
      );

    case _constants__WEBPACK_IMPORTED_MODULE_0__["TILE3D_TYPE"].BATCHED_3D_MODEL:
      return Object(_parse_3d_tile_batched_model__WEBPACK_IMPORTED_MODULE_3__["parseBatchedModel3DTileSync"])(tile, arrayBuffer, byteOffset, options, context);

    case _constants__WEBPACK_IMPORTED_MODULE_0__["TILE3D_TYPE"].INSTANCED_3D_MODEL:
      return Object(_parse_3d_tile_instanced_model__WEBPACK_IMPORTED_MODULE_4__["parseInstancedModel3DTileSync"])(tile, arrayBuffer, byteOffset, options, context);

    case _constants__WEBPACK_IMPORTED_MODULE_0__["TILE3D_TYPE"].POINT_CLOUD:
      return Object(_parse_3d_tile_point_cloud__WEBPACK_IMPORTED_MODULE_2__["parsePointCloud3DTileSync"])(tile, arrayBuffer, byteOffset, options, context);

    default:
      throw new Error(`3DTileLoader: unknown type ${tile.type}`); // eslint-disable-line
  }
}


/***/ }),

/***/ "./src/request-utils/request-scheduler.js":
/*!************************************************!*\
  !*** ./src/request-utils/request-scheduler.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RequestScheduler; });
/* harmony import */ var probe_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! probe.gl */ "../../node_modules/probe.gl/dist/esm/index.js");
// TODO - this should move to core when test cases are more complete

/* global setTimeout */


const STAT_QUEUED_REQUESTS = 'Queued Requests';
const STAT_ACTIVE_REQUESTS = 'Active Requests';
const STAT_CANCELLED_REQUESTS = 'Cancelled Requests';
const STAT_QUEUED_REQUESTS_EVER = 'Queued Requests Ever';
const STAT_ACTIVE_REQUESTS_EVER = 'Active Requests Ever';

const DEFAULT_PROPS = {
  id: 'request-scheduler',
  // Specifies if the request scheduler should throttle incoming requests, mainly for comparative testing
  throttleRequests: true,
  // The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit.
  maxRequests: 6
};

// The request scheduler does not actually issue requests, it just lets apps know
// when the request can be issued without overwhelming the server.
// The main use case is to let the app  reprioritize or cancel requests if
//  circumstances change before the request can be scheduled.
//
// TODO - Track requests globally, across multiple servers
class RequestScheduler {
  constructor(props = {}) {
    this.props = {...props, ...DEFAULT_PROPS};

    // Tracks the number of active requests and prioritizes/cancels queued requests.
    this.requestQueue = [];
    this.activeRequestCount = 0;

    // Returns the statistics used by the request scheduler.
    this.stats = new probe_gl__WEBPACK_IMPORTED_MODULE_0__["Stats"]({id: props.id});
    this.stats.get(STAT_QUEUED_REQUESTS);
    this.stats.get(STAT_ACTIVE_REQUESTS);
    this.stats.get(STAT_CANCELLED_REQUESTS);
    this.stats.get(STAT_QUEUED_REQUESTS_EVER);
    this.stats.get(STAT_ACTIVE_REQUESTS_EVER);
  }

  // Called by an application that wants to issue a request, without having it deeply queued
  // Parameter `callback` will be called when request "slots" open up,
  //    allowing the caller to update priority or cancel the request
  //    Highest priority executes first, priority < 0 cancels the request
  // Returns: a promise that resolves when the request can be issued without queueing,
  //    or rejects if the request has been cancelled (by the callback)
  scheduleRequest(handle, callback = () => 0) {
    // Allows throttling to be disabled
    if (!this.props.throttleRequests) {
      return Promise.resolve(handle);
    }

    const promise = new Promise((resolve, reject) => {
      this.requestQueue.push({handle, callback, resolve, reject});
    });

    this._issueNewRequests();
    return promise;
  }

  // Called by an application to mark that it is actively making a request
  startRequest(handle) {
    this.activeRequestCount++;
  }

  // Called by an application to mark that it is finished making a request
  endRequest(handle) {
    this.activeRequestCount--;
    this._issueNewRequests();
  }

  // Tracks a request promise, starting and then ending the request (triggering new slots).
  trackRequestPromise(handle, promise) {
    this.startRequest(handle);
    promise.then(() => this.endRequest(handle)).catch(() => this.endRequest(handle));
  }

  // PRIVATE

  // We check requests asynchronously, to prevent multiple updates
  _issueNewRequests() {
    this._updateNeeded = true;
    setTimeout(() => this._issueNewRequestsAsync(), 0);
  }

  // Refresh all requests and
  _issueNewRequestsAsync() {
    this._updateNeeded = false;

    const freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);

    if (freeSlots === 0) {
      return;
    }

    this._updateAllRequests();

    // Resolve pending promises for the top-priority requests
    for (let i = 0; i < freeSlots; ++i) {
      if (this.requestQueue.length > 0) {
        const request = this.requestQueue.shift();
        request.resolve(true);
      }
    }

    // Uncomment to debug
    // console.log(`${freeSlots} free slots, ${this.requestQueue.length} queued requests`);
  }

  // Ensure all requests have updated priorities, and that no longer valid requests are cancelled
  _updateAllRequests() {
    const requestQueue = this.requestQueue;
    for (let i = 0; i < requestQueue.length; ++i) {
      const request = requestQueue[i];
      if (!this._updateRequest(request)) {
        // Remove the element and make sure to adjust the counter to account for shortened array
        requestQueue.splice(i, 1);
        i--;
      }
    }

    // Sort the remaining requests based on priority
    requestQueue.sort((a, b) => a.priority - b.priority);
  }

  // Update a single request by calling the callback
  _updateRequest(request) {
    request.priority = request.callback(request.handle); // eslint-disable-line callback-return

    // by returning a negative priority, the callback cancels the request
    if (request.priority < 0) {
      request.resolve(false);
      return false;
    }
    return true;
  }
}


/***/ }),

/***/ "./src/tile-3d-loader.js":
/*!*******************************!*\
  !*** ./src/tile-3d-loader.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _parsers_parse_3d_tile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parsers/parse-3d-tile */ "./src/parsers/parse-3d-tile.js");


async function parse(arrayBuffer, options, context, loader) {
  const tile = {};
  const byteOffset = 0;
  await Object(_parsers_parse_3d_tile__WEBPACK_IMPORTED_MODULE_0__["parse3DTile"])(arrayBuffer, byteOffset, options, context, tile);
  return tile;
}

function parseSync(arrayBuffer, options, context, loader) {
  const tile = {};
  const byteOffset = 0;
  Object(_parsers_parse_3d_tile__WEBPACK_IMPORTED_MODULE_0__["parse3DTileSync"])(arrayBuffer, byteOffset, options, context, tile);
  return tile;
}

// Tile3DLoader
/* harmony default export */ __webpack_exports__["default"] = ({
  name: '3D Tiles',
  extensions: ['cmpt', 'pnts', 'b3dm', 'i3dm'],
  mimeType: 'application/octet-stream',
  test: ['cmpt', 'pnts', 'b3dm', 'i3dm'],
  parse,
  parseSync,
  binary: true
});


/***/ }),

/***/ "./src/tile-3d-writer.js":
/*!*******************************!*\
  !*** ./src/tile-3d-writer.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _encoders_encode_3d_tile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./encoders/encode-3d-tile */ "./src/encoders/encode-3d-tile.js");


// TODO - target writer structure not yet clear
/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'GLB',
  extensions: ['cmpt', 'pnts', 'b3dm', 'i3dm'],
  mimeType: 'application/octet-stream',
  encodeSync,
  binary: true
});

function encodeSync(tile, options) {
  return Object(_encoders_encode_3d_tile__WEBPACK_IMPORTED_MODULE_0__["default"])(tile, options);
}


/***/ }),

/***/ "./src/tileset-3d-loader.js":
/*!**********************************!*\
  !*** ./src/tileset-3d-loader.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* global TextDecoder */
/* harmony default export */ __webpack_exports__["default"] = ({
  name: '3D Tileset',
  extensions: ['json'],
  parse: async arrayBuffer => JSON.parse(new TextDecoder().decode(arrayBuffer)),
  parseTextSync: JSON.parse,
  testText: text => text.indexOf('asset' >= 0)
});


/***/ }),

/***/ "./src/tileset/helpers/bounding-volume.js":
/*!************************************************!*\
  !*** ./src/tileset/helpers/bounding-volume.js ***!
  \************************************************/
/*! exports provided: createBoundingVolume */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createBoundingVolume", function() { return createBoundingVolume; });
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");
/* harmony import */ var _math_gl_culling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @math.gl/culling */ "../../node_modules/@math.gl/culling/dist/esm/index.js");
/* harmony import */ var _math_gl_geospatial__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @math.gl/geospatial */ "../../node_modules/@math.gl/geospatial/dist/esm/index.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/assert */ "./src/utils/assert.js");
// This file is derived from the Cesium code base under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md

/* eslint-disable */





// const scratchProjectedBoundingSphere = new BoundingSphere();

const defined = x => x !== undefined;

const scratchMatrix = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix3"]();
const scratchScale = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const scratchCenter = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
// const scratchRectangle = new Rectangle();
// const scratchOrientedBoundingBox = new OrientedBoundingBox();
const scratchTransform = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();

/**
 * Create a bounding volume from the tile's bounding volume header.
 * @param {Object} boundingVolumeHeader The tile's bounding volume header.
 * @param {Matrix4} transform The transform to apply to the bounding volume.
 * @param {TileBoundingVolume} [result] The object onto which to store the result.
 * @returns {TileBoundingVolume} The modified result parameter or a new TileBoundingVolume instance if none was provided.
 */
function createBoundingVolume(boundingVolumeHeader, transform, result) {
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_3__["default"])(boundingVolumeHeader, '3D Tile: boundingVolume must be defined');
  if (boundingVolumeHeader.box) {
    return createBox(boundingVolumeHeader.box, transform, result);
  }
  if (boundingVolumeHeader.region) {
    // [west, south, east, north, minimum height, maximum height]
    // Latitudes and longitudes are in the WGS 84 datum as defined in EPSG 4979 and are in radians.
    // Heights are in meters above (or below) the WGS 84 ellipsoid.
    const [west, south, east, north, minHeight, maxHeight] = boundingVolumeHeader.region;

    const center = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"](
      Object(math_gl__WEBPACK_IMPORTED_MODULE_0__["degrees"])((west + east) / 2),
      Object(math_gl__WEBPACK_IMPORTED_MODULE_0__["degrees"])((north + south) / 2),
      (minHeight + maxHeight) / 2
    );

    const centerInCartesian = _math_gl_geospatial__WEBPACK_IMPORTED_MODULE_2__["Ellipsoid"].WGS84.cartographicToCartesian(center, scratchCenter);

    const northWest = _math_gl_geospatial__WEBPACK_IMPORTED_MODULE_2__["Ellipsoid"].WGS84.cartographicToCartesian([north, west, 0]);
    const northEast = _math_gl_geospatial__WEBPACK_IMPORTED_MODULE_2__["Ellipsoid"].WGS84.cartographicToCartesian([north, east, 0]);
    const southWest = _math_gl_geospatial__WEBPACK_IMPORTED_MODULE_2__["Ellipsoid"].WGS84.cartographicToCartesian([south, west, 0]);
    const radius =
      (Math.abs(northEast[0] - northWest[0]) + Math.abs(southWest[1] - northWest[1])) * 8;

    // TODO fix region boundingVolume
    // for now, create a fake big sphere as the boundingVolume
    return createSphere(
      [centerInCartesian[0], centerInCartesian[1], centerInCartesian[2], radius],
      new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]()
    );
  }

  if (boundingVolumeHeader.sphere) {
    return createSphere(boundingVolumeHeader.sphere, transform, result);
  }

  throw new Error('3D Tile: boundingVolume must contain a sphere, region, or box');
}

function createBox(box, transform, result) {
  const center = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"](box[0], box[1], box[2]);
  let halfAxes = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix3"](box.slice(3, box.length));

  transform.transform(center, center);

  halfAxes = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix3"](
    transform[0],
    transform[1],
    transform[2],
    transform[4],
    transform[5],
    transform[6],
    transform[8],
    transform[9],
    transform[10]
  ).multiplyRight(halfAxes);

  if (defined(result)) {
    result.center = center;
    result.halfAxes = halfAxes;
    return result;
  }

  return new _math_gl_culling__WEBPACK_IMPORTED_MODULE_1__["OrientedBoundingBox"](center, halfAxes);
}

function createBoxFromTransformedRegion(region, transform, initialTransform, result) {
  const rectangle = Rectangle.unpack(region, 0, scratchRectangle);
  const minimumHeight = region[4];
  const maximumHeight = region[5];

  const orientedBoundingBox = _math_gl_culling__WEBPACK_IMPORTED_MODULE_1__["OrientedBoundingBox"].fromRectangle(
    rectangle,
    minimumHeight,
    maximumHeight,
    _math_gl_geospatial__WEBPACK_IMPORTED_MODULE_2__["Ellipsoid"].WGS84,
    scratchOrientedBoundingBox
  );
  const center = orientedBoundingBox.center;
  const halfAxes = orientedBoundingBox.halfAxes;

  // A region bounding volume is not transformed by the transform in the tileset JSON,
  // but may be transformed by additional transforms applied in Cesium.
  // This is why the transform is calculated as the difference between the initial transform and the current transform.
  transform = math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix4"].multiplyTransformation(
    transform,
    math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix4"].inverseTransformation(initialTransform, scratchTransform),
    scratchTransform
  );
  center = math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix4"].multiplyByPoint(transform, center, center);
  const rotationScale = math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix4"].getRotation(transform, scratchMatrix);
  halfAxes = math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix3"].multiply(rotationScale, halfAxes, halfAxes);

  if (defined(result) && result instanceof TileOrientedBoundingBox) {
    result.update(center, halfAxes);
    return result;
  }

  return new TileOrientedBoundingBox(center, halfAxes);
}

function createRegion(region, transform, initialTransform, result) {
  if (!math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix4"].equalsEpsilon(transform, initialTransform, CesiumMath.EPSILON8)) {
    return createBoxFromTransformedRegion(region, transform, initialTransform, result);
  }

  if (defined(result)) {
    return result;
  }

  const rectangleRegion = Rectangle.unpack(region, 0, scratchRectangle);

  return new TileBoundingRegion({
    rectangle: rectangleRegion,
    minimumHeight: region[4],
    maximumHeight: region[5]
  });
}

function createSphere(sphere, transform, result) {
  // Find the transformed center
  const center = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"](sphere[0], sphere[1], sphere[2]);
  transform.transform(center, center);
  const scale = transform.getScale(scratchScale);

  const uniformScale = Math.max(Math.max(scale[0], scale[1]), scale[2]);
  const radius = sphere[3] * uniformScale;

  if (defined(result)) {
    result.center = center;
    result.radius = radius;
    return result;
  }

  return new _math_gl_culling__WEBPACK_IMPORTED_MODULE_1__["BoundingSphere"](center, radius);
}


/***/ }),

/***/ "./src/tileset/helpers/transform-utils.js":
/*!************************************************!*\
  !*** ./src/tileset/helpers/transform-utils.js ***!
  \************************************************/
/*! exports provided: calculateTransformProps */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateTransformProps", function() { return calculateTransformProps; });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../loader-utils/src/index.js");
/* harmony import */ var _math_gl_geospatial__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @math.gl/geospatial */ "../../node_modules/@math.gl/geospatial/dist/esm/index.js");
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");




function calculateTransformProps(tileHeader, tile) {
  Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(tileHeader);
  Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(tile);

  const {rtcCenter, rotateYtoZ} = tile;
  const {
    computedTransform,
    _boundingVolume: {center}
  } = tileHeader;

  let modelMatrix = new math_gl__WEBPACK_IMPORTED_MODULE_2__["Matrix4"](computedTransform);

  // Translate if appropriate
  if (rtcCenter) {
    modelMatrix.translate(rtcCenter);
  }

  // glTF models need to be rotated from Y to Z up
  // https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#y-up-to-z-up
  if (rotateYtoZ) {
    const rotation = new math_gl__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]().rotateX(Math.PI / 2);
    modelMatrix = modelMatrix.multiplyRight(rotation);
  }

  // Scale/offset positions if normalized integers
  if (tile.isQuantized) {
    modelMatrix.translate(tile.quantizedVolumeOffset).scale(tile.quantizedVolumeScale);
  }

  // Option 1: Cartesian matrix and origin
  const cartesianOrigin = new math_gl__WEBPACK_IMPORTED_MODULE_2__["Vector3"](center);

  tile.cartesianModelMatrix = modelMatrix;
  tile.cartesianOrigin = cartesianOrigin;

  // Option 2: Cartographic matrix and origin
  const cartographicOrigin = _math_gl_geospatial__WEBPACK_IMPORTED_MODULE_1__["Ellipsoid"].WGS84.cartesianToCartographic(
    cartesianOrigin,
    new math_gl__WEBPACK_IMPORTED_MODULE_2__["Vector3"]()
  );
  const fromFixedFrameMatrix = _math_gl_geospatial__WEBPACK_IMPORTED_MODULE_1__["Ellipsoid"].WGS84.eastNorthUpToFixedFrame(cartesianOrigin);
  const toFixedFrameMatrix = fromFixedFrameMatrix.invert();

  tile.cartographicModelMatrix = toFixedFrameMatrix.multiplyRight(modelMatrix);
  tile.cartographicOrigin = cartographicOrigin;

  // Deprecated, drop
  tile.modelMatrix = tile.cartographicModelMatrix;
}


/***/ }),

/***/ "./src/tileset/tile-3d-header.js":
/*!***************************************!*\
  !*** ./src/tileset/tile-3d-header.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Tile3DHeader; });
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");
/* harmony import */ var _math_gl_culling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @math.gl/culling */ "../../node_modules/@math.gl/culling/dist/esm/index.js");
/* harmony import */ var _loaders_gl_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @loaders.gl/core */ "../core/src/index.js");
/* harmony import */ var _tile_3d_loader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tile-3d-loader */ "./src/tile-3d-loader.js");
/* harmony import */ var _tileset_3d_loader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tileset-3d-loader */ "./src/tileset-3d-loader.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants */ "./src/constants.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/assert */ "./src/utils/assert.js");
/* harmony import */ var _helpers_bounding_volume__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./helpers/bounding-volume */ "./src/tileset/helpers/bounding-volume.js");
// This file is derived from the Cesium code base under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md
// import {TILE3D_REFINEMENT, TILE3D_OPTIMIZATION_HINT} from '../constants';









const defined = x => x !== undefined && x !== null;

/* eslint-disable */
const scratchDate = new Date();
const scratchCommandList = [];
const scratchToTileCenter = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

// TODO: Remove
const scratchPlane = new _math_gl_culling__WEBPACK_IMPORTED_MODULE_1__["Plane"]();


function computeVisibilityWithPlaneMask(cullingVolume, boundingVolume, parentPlaneMask) {
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_6__["default"])(boundingVolume, 'boundingVolume is required.');
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_6__["default"])(Number.isFinite(parentPlaneMask), 'parentPlaneMask is required.');

  if (
    parentPlaneMask === _math_gl_culling__WEBPACK_IMPORTED_MODULE_1__["CullingVolume"].MASK_OUTSIDE ||
    parentPlaneMask === _math_gl_culling__WEBPACK_IMPORTED_MODULE_1__["CullingVolume"].MASK_INSIDE
  ) {
    // parent is completely outside or completely inside, so this child is as well.
    return parentPlaneMask;
  }

  // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.
  // (Because if there are fewer than 31 planes, the upper bits wont be changed.)
  let mask = _math_gl_culling__WEBPACK_IMPORTED_MODULE_1__["CullingVolume"].MASK_INSIDE;

  const planes = cullingVolume.planes;
  for (let k = 0; k < cullingVolume.planes.length; ++k) {
    // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.
    const flag = k < 31 ? 1 << k : 0;
    if (k < 31 && (parentPlaneMask & flag) === 0) {
      // boundingVolume is known to be INSIDE this plane.
      continue;
    }

    const plane = scratchPlane.fromNormalDistance(planes[k].normal, planes[k].distance);
    const result = boundingVolume.intersectPlane(plane);

    if (result === _math_gl_culling__WEBPACK_IMPORTED_MODULE_1__["Intersect"].OUTSIDE) {
      return _math_gl_culling__WEBPACK_IMPORTED_MODULE_1__["CullingVolume"].MASK_OUTSIDE;
    } else if (result === _math_gl_culling__WEBPACK_IMPORTED_MODULE_1__["Intersect"].INTERSECTING) {
      mask |= flag;
    }
  }

  return mask;
}

// A Tile3DHeader represents a tile a Tileset3D. When a tile is first created, its content is not loaded;
// the content is loaded on-demand when needed based on the view.
// Do not construct this directly, instead access tiles through {@link Tileset3D#tileVisible}.
class Tile3DHeader {
  constructor(tileset, header, parentHeader, basePath) {
    // assert(tileset._asset);
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_6__["default"])(typeof header === 'object');

    this._tileset = tileset;
    this._header = header;
    this._basePath = basePath;
    this._content = null;
    this._contentState = _constants__WEBPACK_IMPORTED_MODULE_5__["TILE3D_CONTENT_STATE"].UNLOADED;
    this._gpuMemoryUsageInBytes = 0;

    // This tile's parent or `undefined` if this tile is the root.
    this.parent = parentHeader;
    // The tile's children.
    this.children = [];
    // Specifies the type of refine that is used when traversing this tile for rendering.
    this.refine = this._getRefine(header.refine);
    this.cacheNode = undefined;
    this.userData = {};

    // The error, in meters, introduced if this tile is rendered and its children are not.
    // This is used to compute screen space error, i.e., the error measured in pixels.
    if ('geometricError' in header) {
      this.geometricError = header.geometricError;
    } else {
      this.geometricError = (this.parent && this.parent.geometricError) || tileset.geometricError;
      console.warn('3D Tile: Required prop geometricError is undefined. Using parent error');
    }

    this._initializeTransforms(header);
    this._initializeBoundingVolumes(header);
    this._initializeContent(header);
    this._initializeCache(header);

    // Marks whether the tile's children bounds are fully contained within the tile's bounds
    // @type {TILE3D_OPTIMIZATION_HINT}
    this._optimChildrenWithinParent = _constants__WEBPACK_IMPORTED_MODULE_5__["TILE3D_OPTIMIZATION_HINT"].NOT_COMPUTED;

    this._initializeRenderingState();

    Object.seal(this);
  }

  destroy() {
    this._header = null;
  }

  isDestroyed() {
    return this._header === null;
  }

  // The tileset containing this tile.
  get gpuMemoryUsageInBytes() {
    return this._gpuMemoryUsageInBytes;
  }

  // The tileset containing this tile.
  get tileset() {
    return this._tileset;
  }

  // The depth of the tile in the tileset tree.
  get depth() {
    return this._depth;
  }

  // The most recent frame that the tile was selected
  get selectedFrame() {
    return this._selectedFrame;
  }

  get isVisibleAndInRequestVolume() {
    return this._visible && this._inRequestVolume;
  }

  // The tile's content.  This represents the actual tile's payload,
  // not the content's metadata in the tileset JSON file.
  get content() {
    return this._content;
  }

  // Determines if the tile's content is ready. This is automatically `true` for
  // tile's with empty content.
  get contentReady() {
    return this._contentState === _constants__WEBPACK_IMPORTED_MODULE_5__["TILE3D_CONTENT_STATE"].READY;
  }

  // Returns true if tile is not an empty tile and not an external tileset
  get hasRenderContent() {
    return !this.hasEmptyContent && !this.hasTilesetContent;
  }

  // Determines if the tile has available content to render.  `true` if the tile's
  // content is ready or if it has expired content this renders while new content loads; otherwise,
  get contentAvailable() {
    return (
      (this.contentReady && this.hasRenderContent) ||
      (defined(this._expiredContent) && !this.contentFailed)
    );
  }

  // Returns true if tile has renderable content but it's unloaded
  get hasUnloadedContent() {
    return this.hasRenderContent && this.contentUnloaded;
  }

  // Determines if the tile's content has not be requested. `true` if tile's
  // content has not be requested; otherwise, `false`.
  get contentUnloaded() {
    return this._contentState === _constants__WEBPACK_IMPORTED_MODULE_5__["TILE3D_CONTENT_STATE"].UNLOADED;
  }

  // Determines if the tile's content is expired. `true` if tile's
  // content is expired; otherwise, `false`.
  get contentExpired() {
    return this._contentState === _constants__WEBPACK_IMPORTED_MODULE_5__["TILE3D_CONTENT_STATE"].EXPIRED;
  }

  // Determines if the tile's content failed to load.  `true` if the tile's
  // content failed to load; otherwise, `false`.
  get contentFailed() {
    return this._contentState === _constants__WEBPACK_IMPORTED_MODULE_5__["TILE3D_CONTENT_STATE"].FAILED;
  }

  get url() {
    return this.tileset.getTileUrl(this.contentUri, this._basePath);
  }

  get uri() {
    return this.tileset.getTileUrl(this.contentUri, this._basePath);
  }

  // Get the tile's bounding volume.
  get boundingVolume() {
    return this._boundingVolume;
  }

  // Get the bounding volume of the tile's contents.  This defaults to the
  // tile's bounding volume when the content's bounding volume is `undefined`.
  get contentBoundingVolume() {
    return this._contentBoundingVolume || this._boundingVolume;
  }

  // Get the bounding sphere derived from the tile's bounding volume.
  get boundingSphere() {
    return this._boundingVolume.boundingSphere;
  }

  // Returns the `extras` property in the tileset JSON for this tile, which contains application specific metadata.
  // Returns `undefined` if `extras` does not exist.
  // @see {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#specifying-extensions-and-application-specific-extras|Extras in the 3D Tiles specification.}
  get extras() {
    return this._header.extras;
  }

  get depth() {
    return this._depth;
  }

  // Get the tile's screen space error.
  getScreenSpaceError(frameState, useParentGeometricError) {
    const tileset = this._tileset;
    const parentGeometricError =
      (this.parent && this.parent.geometricError) || tileset.geometricError;
    const geometricError = useParentGeometricError ? parentGeometricError : this.geometricError;

    // Leaf tiles do not have any error so save the computation
    if (geometricError === 0.0) {
      return 0.0;
    }

    // TODO: Orthographic Frustum needs special treatment?
    // this._getOrthograhicScreenSpaceError();

    // Avoid divide by zero when viewer is inside the tile
    const distance = Math.max(this._distanceToCamera, 1e-7);
    const {height, sseDenominator} = frameState;
    let error = (geometricError * height) / (distance * sseDenominator);

    error -= this._getDynamicScreenSpaceError(distance);

    return error;
  }

  // TODO: Refined screen space error that minimizes tiles in non-first-person
  _getDynamicScreenSpaceError(distance) {
    function fog(distanceToCamera, density) {
      const scalar = distanceToCamera * density;
      return 1.0 - Math.exp(-(scalar * scalar));
    }

    const tileset = this._tileset;

    if (tileset.dynamicScreenSpaceError && tileset._dynamicScreenSpaceErrorComputedDensity) {
      const density = tileset._dynamicScreenSpaceErrorComputedDensity;
      const factor = tileset.dynamicScreenSpaceErrorFactor;
      const dynamicError = fog(distance, density) * factor;
      return dynamicError;
    }

    return 0;
  }

  // Requests the tile's content.
  // The request may not be made if the Request Scheduler can't prioritize it.
  async loadContent() {
    if (this.hasEmptyContent) {
      return false;
    }

    if (this._content) {
      return true;
    }

    const expired = this.contentExpired;

    // Append a query parameter of the tile expiration date to prevent caching
    // if (expired) {
    //   expired: this.expireDate.toString()
    // const request = new Request({
    //   throttle: true,
    //   throttleByServer: true,
    //   type: RequestType.TILES3D,
    //   priorityFunction: createPriorityFunction(this),
    //   serverKey: this._serverKey
    // });

    if (expired) {
      this.expireDate = undefined;
    }

    this._contentState = _constants__WEBPACK_IMPORTED_MODULE_5__["TILE3D_CONTENT_STATE"].LOADING;

    function updatePriority(tile) {
      // Check if any reason to abort
      if (!tile._visible) {
        return -1;
      }
      if (tile._contentState === _constants__WEBPACK_IMPORTED_MODULE_5__["TILE3D_CONTENT_STATE"].UNLOADED) {
        return -1;
      }
      return Math.max(1e7 - tile._priority, 0) || 0;
    }

    const cancelled = !(await this.tileset._requestScheduler.scheduleRequest(this, updatePriority));

    if (cancelled) {
      this._contentState = _constants__WEBPACK_IMPORTED_MODULE_5__["TILE3D_CONTENT_STATE"].UNLOADED;
      return false;
    }

    try {
      const contentUri = this.uri;

      let response;
      try {
        this.tileset._requestScheduler.startRequest(this);
        response = await Object(_loaders_gl_core__WEBPACK_IMPORTED_MODULE_2__["fetchFile"])(contentUri, this.tileset.options.fetchOptions);
      } finally {
        this.tileset._requestScheduler.endRequest(this);
      }

      // The content can be a binary tile ot a JSON tileset
      this._content = await Object(_loaders_gl_core__WEBPACK_IMPORTED_MODULE_2__["parse"])(response, [_tile_3d_loader__WEBPACK_IMPORTED_MODULE_3__["default"], _tileset_3d_loader__WEBPACK_IMPORTED_MODULE_4__["default"]]);
      // if (Tile3D.isTile(content)) {
      //   new Tileset3D(content, contentUri);

      if (contentUri.indexOf('.json') !== -1) {
        // Add tile headers for the nested tilset's subtree
        // Async update of the tree should be fine since there would never be edits to the same node
        // TODO - we need to capture the child tileset's URL
        this._tileset._initializeTileHeaders(this._content, this, _loaders_gl_core__WEBPACK_IMPORTED_MODULE_2__["path"].dirname(this.uri));
      }

      this._contentState = _constants__WEBPACK_IMPORTED_MODULE_5__["TILE3D_CONTENT_STATE"].READY;
      this._contentLoaded();
      return true;
    } catch (error) {
      // Tile is unloaded before the content finishes loading
      this._contentState = _constants__WEBPACK_IMPORTED_MODULE_5__["TILE3D_CONTENT_STATE"].FAILED;
      throw error;
    }
  }

  // Unloads the tile's content.
  unloadContent() {
    if (!this.hasRenderContent) {
      return false;
    }
    if (this._content && this._content.destroy) {
      this._content.destroy();
    }
    this._content = null;
    this._contentState = _constants__WEBPACK_IMPORTED_MODULE_5__["TILE3D_CONTENT_STATE"].UNLOADED;
    return true;
  }

  // _getOrthograhicScreenSpaceError() {
  // if (frustum instanceof OrthographicFrustum) {
  //   const pixelSize = Math.max(frustum.top - frustum.bottom, frustum.right - frustum.left) / Math.max(width, height);
  //   error = geometricError / pixelSize;
  // }

  // Update the tile's visibility.
  updateVisibility(frameState) {
    const tileset = this._tileset;
    if (this._updatedVisibilityFrame === tileset._updatedVisibilityFrame) {
      // Return early if visibility has already been checked during the traversal.
      // The visibility may have already been checked if the cullWithChildrenBounds optimization is used.
      return;
    }

    const parent = this.parent;
    const parentTransform = parent ? parent.computedTransform : this._tileset.modelMatrix;
    const parentVisibilityPlaneMask = parent
      ? parent._visibilityPlaneMask
      : _math_gl_culling__WEBPACK_IMPORTED_MODULE_1__["CullingVolume"].MASK_INDETERMINATE;
    this._updateTransform(parentTransform);
    this._distanceToCamera = this.distanceToTile(frameState);
    // this._centerZDepth = this.cameraSpaceZDepth(frameState);
    this._screenSpaceError = this.getScreenSpaceError(frameState, false);
    this._visibilityPlaneMask = this.visibility(frameState, parentVisibilityPlaneMask); // Use parent's plane mask to speed up visibility test
    this._visible = this._visibilityPlaneMask !== _math_gl_culling__WEBPACK_IMPORTED_MODULE_1__["CullingVolume"].MASK_OUTSIDE;
    this._inRequestVolume = this.insideViewerRequestVolume(frameState);

    this._updatedVisibilityFrame = tileset._updatedVisibilityFrame;
  }

  // Update whether the tile has expired.
  updateExpiration() {
    if (defined(this.expireDate) && this.contentReady && !this.hasEmptyContent) {
      const now = Date.now(scratchDate);
      if (Date.lessThan(this.expireDate, now)) {
        this._contentState = _constants__WEBPACK_IMPORTED_MODULE_5__["TILE3D_CONTENT_STATE"].EXPIRED;
        this._expiredContent = this._content;
      }
    }
  }

  // Determines whether the tile's bounding volume intersects the culling volume.
  // @param {FrameState} frameState The frame state.
  // @param {Number} parentVisibilityPlaneMask The parent's plane mask to speed up the visibility check.
  // @returns {Number} A plane mask as described above in {@link CullingVolume#computeVisibilityWithPlaneMask}.
  visibility(frameState, parentVisibilityPlaneMask) {
    const {cullingVolume} = frameState;
    const {boundingVolume, tileset} = this;

    const {clippingPlanes, clippingPlanesOriginMatrix} = tileset;
    if (clippingPlanes && clippingPlanes.enabled) {
      const intersection = clippingPlanes.computeIntersectionWithBoundingVolume(
        boundingVolume,
        clippingPlanesOriginMatrix
      );
      this._isClipped = intersection !== _math_gl_culling__WEBPACK_IMPORTED_MODULE_1__["Intersect"].INSIDE;
      if (intersection === _math_gl_culling__WEBPACK_IMPORTED_MODULE_1__["Intersect"].OUTSIDE) {
        return _math_gl_culling__WEBPACK_IMPORTED_MODULE_1__["CullingVolume"].MASK_OUTSIDE;
      }
    }

    // return cullingVolume.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);
    return computeVisibilityWithPlaneMask(cullingVolume, boundingVolume, parentVisibilityPlaneMask);
  }

  // Assuming the tile's bounding volume intersects the culling volume, determines
  // whether the tile's content's bounding volume intersects the culling volume.
  // @param {FrameState} frameState The frame state.
  // @returns {Intersect} The result of the intersection: the tile's content is completely outside, completely inside, or intersecting the culling volume.
  contentVisibility(frameState) {
    return true;
    /*
    // Assumes the tile's bounding volume intersects the culling volume already, so
    // just return Intersect.INSIDE if there is no content bounding volume.
    if (!defined(this._contentBoundingVolume)) {
      return Intersect.INSIDE;
    }

    if (this._visibilityPlaneMask === CullingVolume.MASK_INSIDE) {
      // The tile's bounding volume is completely inside the culling volume so
      // the content bounding volume must also be inside.
      return Intersect.INSIDE;
    }

    // PERFORMANCE_IDEA: is it possible to burn less CPU on this test since we know the
    // tile's (not the content's) bounding volume intersects the culling volume?
    const cullingVolume = frameState.cullingVolume;
    const boundingVolume = tile._contentBoundingVolume;

    const tileset = this._tileset;
    const clippingPlanes = tileset.clippingPlanes;
    if (defined(clippingPlanes) && clippingPlanes.enabled) {
      const intersection = clippingPlanes.computeIntersectionWithBoundingVolume(
        boundingVolume,
        tileset.clippingPlanesOriginMatrix
      );
      this._isClipped = intersection !== Intersect.INSIDE;
      if (intersection === Intersect.OUTSIDE) {
        return Intersect.OUTSIDE;
      }
    }

    return cullingVolume.computeVisibility(boundingVolume);
    */
  }

  // Computes the (potentially approximate) distance from the closest point of the tile's bounding volume to the camera.
  // @param {FrameState} frameState The frame state.
  // @returns {Number} The distance, in meters, or zero if the camera is inside the bounding volume.
  distanceToTile(frameState) {
    const boundingVolume = this._boundingVolume;
    return Math.sqrt(boundingVolume.distanceSquaredTo(frameState.camera.position));
  }

  // Computes the tile's camera-space z-depth.
  // @param {FrameState} frameState The frame state.
  // @returns {Number} The distance, in meters.
  cameraSpaceZDepth({camera}) {
    const boundingVolume = this.boundingVolume; // Gets the underlying OrientedBoundingBox or BoundingSphere
    scratchToTileCenter.subVectors(boundingVolume.center, camera.position);
    return camera.direction.dot(scratchToTileCenter);
  }

  /**
   * Checks if the camera is inside the viewer request volume.
   * @param {FrameState} frameState The frame state.
   * @returns {Boolean} Whether the camera is inside the volume.
   */
  insideViewerRequestVolume(frameState) {
    const viewerRequestVolume = this._viewerRequestVolume;
    return !viewerRequestVolume || viewerRequestVolume.distanceToCamera(frameState) === 0.0;
  }

  // PRIVATE

  _initializeCache(header) {
    // The node in the tileset's LRU cache, used to determine when to unload a tile's content.
    this.cacheNode = undefined;

    let expire = header.expire;
    let expireDuration;
    let expireDate;
    if (expire) {
      expireDuration = expire.duration;
      if (expire.date) {
        expireDate = Date.fromIso8601(expire.date);
      }
    }

    // The time in seconds after the tile's content is ready when the content expires and new content is requested.
    // @type {Number}
    this.expireDuration = expireDuration;

    // The date when the content expires and new content is requested.
    // @type {Date}
    this.expireDate = expireDate;
  }

  _initializeTransforms(tileHeader) {
    // The local transform of this tile.
    this.transform = tileHeader.transform ? new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix4"](tileHeader.transform) : new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();

    const parent = this.parent;
    const tileset = this._tileset;

    const parentTransform =
      parent && parent.computedTransform
        ? parent.computedTransform.clone()
        : tileset.modelMatrix.clone();
    this.computedTransform = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix4"](parentTransform).multiplyRight(this.transform);

    const parentInitialTransform =
      parent && parent._initialTransform ? parent._initialTransform.clone() : new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
    this._initialTransform = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix4"](parentInitialTransform).multiplyRight(this.transform);
  }

  _initializeBoundingVolumes(tileHeader) {
    this._boundingVolume = Object(_helpers_bounding_volume__WEBPACK_IMPORTED_MODULE_7__["createBoundingVolume"])(tileHeader.boundingVolume, this.computedTransform);

    this._contentBoundingVolume = null;
    this._viewerRequestVolume = null;

    // Non-leaf tiles may have a content bounding-volume, which is a tight-fit bounding volume
    // around only the features in the tile. This box is useful for culling for rendering,
    // but not for culling for traversing the tree since it does not guarantee spatial coherence, i.e.,
    // since it only bounds features in the tile, not the entire tile, children may be
    // outside of this box.
    if (tileHeader.content && tileHeader.content.boundingVolume) {
      this._contentBoundingVolume = Object(_helpers_bounding_volume__WEBPACK_IMPORTED_MODULE_7__["createBoundingVolume"])(
        tileHeader.boundingVolume,
        this.computedTransform
      );
    }

    if (tileHeader.viewerRequestVolume) {
      this._viewerRequestVolume = Object(_helpers_bounding_volume__WEBPACK_IMPORTED_MODULE_7__["createBoundingVolume"])(
        tileHeader.viewerRequestVolume,
        this.computedTransform
      );
    }
  }

  _initializeContent(tileHeader) {
    // Empty tile by default
    this._content = {_tileset: this._tileset, _tile: this};
    this.hasEmptyContent = true;
    this.contentState = _constants__WEBPACK_IMPORTED_MODULE_5__["TILE3D_CONTENT_STATE"].UNLOADED;
    this._expiredContent = undefined;
    this._serverKey = null;

    // When `true`, the tile's content points to an external tileset.
    // This is `false` until the tile's content is loaded.
    this.hasTilesetContent = false;

    // If a content tileHeader
    if (tileHeader.content) {
      this.contentUri = tileHeader.content.uri || tileHeader.content.url;
      if ('url' in tileHeader) {
        console.warn('Tileset 3D: "content.url" property deprecated. Use "content.uri" instead.');
        this.contentUri = tileHeader.url;
      }
      this._content = null;
      this.hasEmptyContent = false;
      this.contentState = _constants__WEBPACK_IMPORTED_MODULE_5__["TILE3D_CONTENT_STATE"].UNLOADED;
      this.fullUri = this._basePath + '/' + this.contentUri;
      // this.serverKey = RequestScheduler.getServerKey(contentResource.getUrlComponent());
    }
  }

  // TODO - remove anything not related to basic visibility detection
  _initializeRenderingState() {
    // Members this are updated every frame for tree traversal and rendering optimizations:
    this._distanceToCamera = 0;
    this._centerZDepth = 0;
    this._screenSpaceError = 0;
    this._visibilityPlaneMask = _math_gl_culling__WEBPACK_IMPORTED_MODULE_1__["CullingVolume"].MASK_INDETERMINATE;
    this._visible = false;
    this._inRequestVolume = false;

    this._finalResolution = true;
    this._depth = 0;
    this._stackLength = 0;
    this._selectionDepth = 0;

    this._updatedVisibilityFrame = 0;
    this._touchedFrame = 0;
    this._visitedFrame = 0;
    this._selectedFrame = 0;
    this._requestedFrame = 0;
    this._ancestorWithContent = undefined;
    this._ancestorWithContentAvailable = undefined;
    this._refines = false;
    this._shouldSelect = false;
    this._priority = 0.0;
  }

  _getRefine(refine) {
    switch (refine) {
      case 'REPLACE':
      case 'replace':
        return _constants__WEBPACK_IMPORTED_MODULE_5__["TILE3D_REFINEMENT"].REPLACE;
      case 'ADD':
      case 'add':
        return _constants__WEBPACK_IMPORTED_MODULE_5__["TILE3D_REFINEMENT"].ADD;
      default:
        // Inherit from parent tile if omitted.
        return this.parent ? this.parent.refine : _constants__WEBPACK_IMPORTED_MODULE_5__["TILE3D_REFINEMENT"].REPLACE;
    }
  }

  _isTileset(content) {
    return Boolean(content.asset);
  }

  _contentLoaded() {
    // Vector and Geometry tile rendering do not support the skip LOD optimization.
    switch (this._content && this._content.type) {
      case 'vctr':
      case 'geom':
        tileset.traverser.disableSkipLevelOfDetail = true;
      default:
    }

    // The content may be tileset json
    if (this._isTileset(this._content)) {
      this.hasTilesetContent = true;
    }
  }

  // Update the tile's transform. The transform is applied to the tile's bounding volumes.
  _updateTransform(parentTransform = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]()) {
    const computedTransform = parentTransform.clone().multiplyRight(this.transform);
    const didTransformChange = !computedTransform.equals(this.computedTransform);

    if (!didTransformChange) {
      return;
    }

    this.computedTransform = computedTransform;

    // Matrix4.clone(computedTransform, this.computedTransform);

    // Update the bounding volumes
    const header = this._header;

    const content = this._header.content;
    this._boundingVolume = Object(_helpers_bounding_volume__WEBPACK_IMPORTED_MODULE_7__["createBoundingVolume"])(
      header.boundingVolume,
      this.computedTransform,
      this._boundingVolume
    );
    if (this._contentBoundingVolume) {
      this._contentBoundingVolume = Object(_helpers_bounding_volume__WEBPACK_IMPORTED_MODULE_7__["createBoundingVolume"])(
        content.boundingVolume,
        this.computedTransform,
        this._contentBoundingVolume
      );
    }
    if (this._viewerRequestVolume) {
      this._viewerRequestVolume = Object(_helpers_bounding_volume__WEBPACK_IMPORTED_MODULE_7__["createBoundingVolume"])(
        header.viewerRequestVolume,
        this.computedTransform,
        this._viewerRequestVolume
      );
    }
  }
}

function updateContent(tile, tileset, frameState) {
  const content = tile._content;
  const expiredContent = tile._expiredContent;

  if (expiredContent) {
    if (!tile.contentReady) {
      // Render the expired content while the content loads
      expiredContent.update(tileset, frameState);
      return;
    }

    // New content is ready, destroy expired content
    tile._expiredContent.destroy();
    tile._expiredContent = undefined;
  }

  content.update(tileset, frameState);
}

function updateExpireDate(tile) {
  if (defined(tile.expireDuration)) {
    const expireDurationDate = Date.now(scratchDate);
    Date.addSeconds(expireDurationDate, tile.expireDuration, expireDurationDate);

    if (defined(tile.expireDate)) {
      if (Date.lessThan(tile.expireDate, expireDurationDate)) {
        Date.clone(expireDurationDate, tile.expireDate);
      }
    } else {
      tile.expireDate = Date.clone(expireDurationDate);
    }
  }
}

function createPriorityFunction(tile) {
  return function() {
    return tile._priority;
  };
}


/***/ }),

/***/ "./src/tileset/tileset-3d-cache.js":
/*!*****************************************!*\
  !*** ./src/tileset/tileset-3d-cache.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Tileset3DCache; });
/* harmony import */ var _utils_doubly_linked_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/doubly-linked-list */ "./src/utils/doubly-linked-list.js");
// This file is derived from the Cesium code base under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md


const defined = x => x !== undefined;

/**
 * Stores tiles with content loaded.
 *
 * @private
 */
class Tileset3DCache {
  constructor() {
    // [head, sentinel) -> tiles that weren't selected this frame and may be removed from the cache
    // (sentinel, tail] -> tiles that were selected this frame
    this._list = new _utils_doubly_linked_list__WEBPACK_IMPORTED_MODULE_0__["default"]();
    this._sentinel = this._list.add();
    this._trimTiles = false;
  }

  reset() {
    // Move sentinel node to the tail so, at the start of the frame, all tiles
    // may be potentially replaced.  Tiles are moved to the right of the sentinel
    // when they are selected so they will not be replaced.
    this._list.splice(this._list.tail, this._sentinel);
  }

  touch(tile) {
    const node = tile.cacheNode;
    if (defined(node)) {
      this._list.splice(this._sentinel, node);
    }
  }

  add(tileset, tile, addCallback) {
    if (!defined(tile.cacheNode)) {
      tile.cacheNode = this._list.add(tile);

      if (addCallback) {
        addCallback(tileset, tile);
      }
    }
  }

  unloadTile(tileset, tile, unloadCallback) {
    const node = tile.cacheNode;
    if (!defined(node)) {
      return;
    }

    this._list.remove(node);
    tile.cacheNode = undefined;
    if (unloadCallback) {
      unloadCallback(tileset, tile);
    }
  }

  unloadTiles(tileset, unloadCallback) {
    const trimTiles = this._trimTiles;
    this._trimTiles = false;

    const list = this._list;

    const maximumMemoryUsageInBytes = tileset.maximumMemoryUsage * 1024 * 1024;

    // Traverse the list only to the sentinel since tiles/nodes to the
    // right of the sentinel were used this frame.
    // The sub-list to the left of the sentinel is ordered from LRU to MRU.
    const sentinel = this._sentinel;
    let node = list.head;

    while (
      node !== sentinel &&
      (tileset.gpuMemoryUsageInBytes > maximumMemoryUsageInBytes || trimTiles)
    ) {
      const tile = node.item;
      node = node.next;
      this.unloadTile(tileset, tile, unloadCallback);
    }
  }

  trim() {
    this._trimTiles = true;
  }
}


/***/ }),

/***/ "./src/tileset/tileset-3d-traverser.js":
/*!*********************************************!*\
  !*** ./src/tileset/tileset-3d-traverser.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Tileset3DTraverser; });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants */ "./src/constants.js");
/* harmony import */ var _utils_managed_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/managed-array */ "./src/utils/managed-array.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/assert */ "./src/utils/assert.js");
// import {TILE3D_REFINEMENT, TILE3D_OPTIMIZATION_HINT} from '../constants';



// This file is derived from the Cesium code base under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md

class Tileset3DTraverser {
  constructor() {
    this.traversal = {
      stack: new _utils_managed_array__WEBPACK_IMPORTED_MODULE_1__["default"](),
      stackMaximumLength: 0
    };

    this.emptyTraversal = {
      stack: new _utils_managed_array__WEBPACK_IMPORTED_MODULE_1__["default"](),
      stackMaximumLength: 0
    };

    this.result = {
      _requestedTiles: [],
      selectedTiles: [],
      _emptyTiles: [],
      _hasMixedContent: false
    };

    // Optimization option. Determines if level of detail skipping should be applied during the traversal.
    this._disableSkipLevelOfDetail = false;
  }

  traverse(root, frameState, options) {
    this.root = root; // for root screen space error
    this.options = options;

    this.result._requestedTiles.length = 0;
    this.result.selectedTiles.length = 0;
    this.result._emptyTiles.length = 0;
    // this.result._selectedTilesToStyle.length = 0;
    this.result._hasMixedContent = false;

    this.updateTile(root, frameState);

    // The root tile is not visible
    if (!root.isVisibleAndInRequestVolume) {
      return false;
    }

    // The this doesn't meet the SSE requirement, therefore the tree does not need to be rendered
    // The alwaysLoadRoot is better solved by moving the camera to the newly selected asset.
    if (root.getScreenSpaceError(frameState, true) <= options.maximumScreenSpaceError) {
      return false;
    }

    const baseScreenSpaceError = options.maximumScreenSpaceError;
    this.executeTraversal(root, baseScreenSpaceError, frameState);

    this.traversal.stack.trim(this.traversal.stackMaximumLength);
    this.emptyTraversal.stack.trim(this.emptyTraversal.stackMaximumLength);

    return true;
  }

  selectTile(tile, frameState) {
    tile._selectedFrame = frameState.frameNumber;
    this.result.selectedTiles.push(tile);

    // if (tile.contentVisibility(frameState) !== Intersect.OUTSIDE) {
    //   if (tile.content.featurePropertiesDirty) {
    //     // A feature's property in this tile changed, the tile needs to be re-styled.
    //     tile.content.featurePropertiesDirty = false;
    //     tile.lastStyleTime = 0; // Force applying the style to this tile
    //     tileset._selectedTilesToStyle.push(tile);
    //   } else if (tile._selectedFrame < frameState.frameNumber - 1) {
    //     // Tile is newly selected; it is selected this frame, but was not selected last frame.
    //     tileset._selectedTilesToStyle.push(tile);
    //   }
    //   tile._selectedFrame = frameState.frameNumber;
    //   tileset.selectedTiles.push(tile);
    // }
  }

  selectDesiredTile(tile, frameState) {
    if (!this.options.skipLevelOfDetail) {
      if (tile.contentAvailable) {
        // The tile can be selected right away and does not require traverseAndSelect
        this.selectTile(tile, frameState);
      }
      return;
    }

    // If this tile is not loaded attempt to select its ancestor instead
    const loadedTile = tile.contentAvailable ? tile : tile._ancestorWithContentAvailable;
    if (loadedTile) {
      // Tiles will actually be selected in traverseAndSelect
      loadedTile._shouldSelect = true;
    } else {
      // If no ancestors are ready traverse down and select tiles to minimize empty regions.
      // This happens often for immediatelyLoadDesiredLevelOfDetail where parent tiles
      // are not necessarily loaded before zooming out.
      this.selectDescendants(tile, frameState);
    }
  }

  visitTile(tileset, tile, frameState) {
    ++tileset._statistics.visited;
    tile._visitedFrame = frameState.frameNumber;
  }

  touchTile(tile, frameState) {
    // TODO need a better frameNumber since it can be the same between updates
    // Until then this needs to be commented out
    // if (tile._touchedFrame === frameState.frameNumber) {
    //   // Prevents another pass from touching the frame again
    //   return;
    // }
    // TODO: add function to tile that te
    tile.tileset._cache.touch(tile);
    tile._touchedFrame = frameState.frameNumber;
  }

  // If skipLevelOfDetail is off try to load child tiles as soon as possible so that their parent can refine sooner.
  // Additive tiles are prioritized by distance because it subjectively looks better.
  // Replacement tiles are prioritized by screen space error.
  // A tileset that has both additive and replacement tiles may not prioritize tiles as effectively since SSE and distance
  // are different types of values. Maybe all priorities need to be normalized to 0-1 range.
  getPriority(tile, options) {
    switch (tile.refine) {
      case _constants__WEBPACK_IMPORTED_MODULE_0__["TILE3D_REFINEMENT"].ADD:
        return tile._distanceToCamera;

      case _constants__WEBPACK_IMPORTED_MODULE_0__["TILE3D_REFINEMENT"].REPLACE:
        const {parent} = tile;
        const useParentScreenSpaceError =
          parent &&
          (!options.skipLevelOfDetail ||
            tile._screenSpaceError === 0.0 ||
            parent.hasTilesetContent);
        const screenSpaceError = useParentScreenSpaceError
          ? parent._screenSpaceError
          : tile._screenSpaceError;
        const rootScreenSpaceError = this.root._screenSpaceError;
        return rootScreenSpaceError - screenSpaceError; // Map higher SSE to lower values (e.g. root tile is highest priority)

      default:
        return Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(false);
    }
  }

  loadTile(tile, frameState) {
    if (tile.hasUnloadedContent || tile.contentExpired) {
      tile._requestedFrame = frameState.frameNumber;
      tile._priority = this.getPriority(tile, this.options);
      this.result._requestedTiles.push(tile);
    }
  }

  // anyChildrenVisible(tileset, tile, frameState) {
  //   let anyVisible = false;
  //   for (const child of tile.children) {
  //     child.updateVisibility(frameState);
  //     anyVisible = anyVisible || child.isVisibleAndInRequestVolume;
  //   }
  //   return anyVisible;
  // }

  // meetsScreenSpaceErrorEarly(tileset, tile, frameState) {
  //   const {parent} = tile;
  //   if (!parent || parent.hasTilesetContent || parent.refine !== TILE3D_REFINEMENT.ADD) {
  //     return false;
  //   }
  //
  //   // Use parent's geometric error with child's box to see if the tile already meet the SSE
  //   return tile.getScreenSpaceError(frameState, true) <= tileset.maximumScreenSpaceError;
  // }

  updateTileVisibility(tile, frameState) {
    tile.updateVisibility(frameState);

    // //  Optimization - if none of the tile's children are visible then this tile isn't visible
    // if (!tile.isVisibleAndInRequestVolume) {
    //   return;
    // }
    //
    // const hasChildren = tile.children.length > 0;
    // if (tile.hasTilesetContent && hasChildren) {
    //   // Use the root tile's visibility instead of this tile's visibility.
    //   // The root tile may be culled by the children bounds optimization in which
    //   // case this tile should also be culled.
    //   const firstChild = tile.children[0];
    //   this.updateTileVisibility(tileset, firstChild, frameState);
    //   tile._visible = firstChild._visible;
    //   return;
    // }
    //
    // if (this.meetsScreenSpaceErrorEarly(tileset, tile, frameState)) {
    //   tile._visible = false;
    //   return;
    // }
    //
    // const replace = tile.refine === TILE3D_REFINEMENT.REPLACE;
    // const useOptimization =
    //   tile._optimChildrenWithinParent === TILE3D_OPTIMIZATION_HINT.USE_OPTIMIZATION;
    // if (replace && useOptimization && hasChildren) {
    //   if (!this.anyChildrenVisible(tileset, tile, frameState)) {
    //     ++tileset._statistics.numberOfTilesCulledWithChildrenUnion;
    //     tile._visible = false;
    //     return;
    //   }
    // }
  }

  updateTile(tile, frameState) {
    this.updateTileVisibility(tile, frameState);
    tile.updateExpiration();
  }

  // eslint-disable-next-line complexity
  updateAndPushChildren(tile, stack, frameState) {
    const {children} = tile;

    for (const child of children) {
      this.updateTile(child, frameState);
      stack.push(child);
    }
    return true;

    // for (const child of children) {
    //   this.updateTile(child, frameState);
    // }
    //
    // function compareDistanceToCamera(a, b) {
    //   // Sort by farthest child first since this is going on a stack
    //   return b._distanceToCamera === 0 && a._distanceToCamera === 0
    //     ? b._centerZDepth - a._centerZDepth
    //     : b._distanceToCamera - a._distanceToCamera;
    // }
    //
    // // Sort by distance to take advantage of early Z and reduce artifacts for skipLevelOfDetail
    // children.sort(compareDistanceToCamera);
    //
    // // For traditional replacement refinement only refine if all children are loaded.
    // // Empty tiles are exempt since it looks better if children stream in as they are loaded to fill the empty space.
    // const checkRefines = !options.skipLevelOfDetail && tile.refine === TILE3D_REFINEMENT.REPLACE && tile.hasRenderContent
    // let refines = true;
    //
    // let anyChildrenVisible = false;
    // for (const child of children) {
    //   if (child.isVisibleAndInRequestVolume) {
    //     stack.push(child);
    //     anyChildrenVisible = true;
    //   } else if (checkRefines || options.loadSiblings) {
    //     // Keep non-visible children loaded since they are still needed before the parent can refine.
    //     // Or loadSiblings is true so always load tiles regardless of visibility.
    //     this.loadTile(child, frameState);
    //     this.touchTile(child, frameState);
    //   }
    //   if (checkRefines) {
    //     let childRefines;
    //     if (!child._inRequestVolume) {
    //       childRefines = false;
    //     } else if (!child.hasRenderContent) {
    //       childRefines = this.executeEmptyTraversal(child, frameState);
    //     } else {
    //       childRefines = child.contentAvailable;
    //     }
    //     refines = refines && childRefines;
    //   }
    // }
    //
    // if (!anyChildrenVisible) {
    //   refines = false;
    // }
    //
    // return refines;
  }

  canTraverse(tile, options) {
    // TODO: remove the depthLimit check once real sse is working
    if (tile.children.length === 0 || options.depthLimit < tile.depth) {
      return false;
    }

    if (tile.hasTilesetContent) {
      // Traverse external this to visit its root tile
      // Don't traverse if the subtree is expired because it will be destroyed
      return !tile.contentExpired;
    }

    return tile._screenSpaceError > options.maximumScreenSpaceError;
  }

  // Depth-first traversal that traverses all visible tiles and marks tiles for selection.
  // If skipLevelOfDetail is off then a tile does not refine until all children are loaded.
  // This is the traditional replacement refinement approach and is called the base traversal.
  // Tiles that have a greater screen space error than the base screen space error are part of the base traversal,
  // all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree
  // and rendering children and parent tiles simultaneously.

  // eslint-disable-next-line max-statements, complexity
  executeTraversal(root, baseScreenSpaceError, frameState) {
    const {traversal} = this;
    const {stack} = traversal;
    stack.push(root);

    while (stack.length > 0) {
      traversal.stackMaximumLength = Math.max(traversal.stackMaximumLength, stack.length);

      const tile = stack.pop();
      const add = tile.refine === _constants__WEBPACK_IMPORTED_MODULE_0__["TILE3D_REFINEMENT"].ADD;
      const replace = tile.refine === _constants__WEBPACK_IMPORTED_MODULE_0__["TILE3D_REFINEMENT"].REPLACE;
      const parent = tile.parent;
      const parentRefines = !parent || parent._refines;
      let refines = false;

      if (this.canTraverse(tile, this.options)) {
        refines = this.updateAndPushChildren(tile, stack, frameState) && parentRefines;
      }

      const stoppedRefining = !refines && parentRefines;

      if (!tile.hasRenderContent) {
        // Add empty tile just to show its debug bounding volume
        // If the tile has this content load the external this
        // If the tile cannot refine further select its nearest loaded ancestor
        this.result._emptyTiles.push(tile);
        this.loadTile(tile, frameState);
        if (stoppedRefining) {
          this.selectDesiredTile(tile, frameState);
        }
      } else if (add) {
        // Additive tiles are always loaded and selected
        this.loadTile(tile, frameState);
        this.selectDesiredTile(tile, frameState);
      } else if (replace) {
        // Always load tiles in the base traversal
        // Select tiles that can't refine further
        this.loadTile(tile, frameState);
        if (stoppedRefining) {
          this.selectDesiredTile(tile, frameState);
        }
      }

      // this.visitTile(tileset, tile, frameState);
      this.touchTile(tile, frameState);
      tile._refines = refines;
    }
  }

  // Depth-first traversal that checks if all nearest descendants with content are loaded. Ignores visibility.
  // executeEmptyTraversal(root, frameState) {
  //   const allDescendantsLoaded = true;
  //   const stack = emptyTraversal.stack;
  //   stack.push(root);
  //
  //   while (stack.length > 0) {
  //     emptyTraversal.stackMaximumLength = Math.max(emptyTraversal.stackMaximumLength, stack.length);
  //
  //     const tile = stack.pop();
  //     const children = tile.children;
  //     const childrenLength = children.length;
  //
  //     // Only traverse if the tile is empty - traversal stop at descendants with content
  //     const traverse = !tile.hasRenderContent && this.canTraverse(tile);
  //
  //     // Traversal stops but the tile does not have content yet.
  //     // There will be holes if the parent tries to refine to its children, so don't refine.
  //     if (!traverse && !tile.contentAvailable) {
  //       allDescendantsLoaded = false;
  //     }
  //
  //     this.updateTile(tile, frameState);
  //     if (!tile.isVisibleAndInRequestVolume) {
  //       // Load tiles that aren't visible since they are still needed for the parent to refine
  //       this.loadTile(tile, frameState);
  //       this.touchTile(tile, frameState);
  //     }
  //
  //     if (traverse) {
  //       for (const child of this.children) {
  //         stack.push(child);
  //       }
  //     }
  //   }
  //
  //   return allDescendantsLoaded;
  // }
}


/***/ }),

/***/ "./src/tileset/tileset-3d.js":
/*!***********************************!*\
  !*** ./src/tileset/tileset-3d.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Tileset3D; });
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");
/* harmony import */ var _math_gl_geospatial__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @math.gl/geospatial */ "../../node_modules/@math.gl/geospatial/dist/esm/index.js");
/* harmony import */ var probe_gl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! probe.gl */ "../../node_modules/probe.gl/dist/esm/index.js");
/* harmony import */ var _loaders_gl_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @loaders.gl/core */ "../core/src/index.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/assert */ "./src/utils/assert.js");
/* harmony import */ var _request_utils_request_scheduler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../request-utils/request-scheduler */ "./src/request-utils/request-scheduler.js");
/* harmony import */ var _helpers_transform_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./helpers/transform-utils */ "./src/tileset/helpers/transform-utils.js");
/* harmony import */ var _tile_3d_header__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tile-3d-header */ "./src/tileset/tile-3d-header.js");
/* harmony import */ var _tileset_3d_traverser__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./tileset-3d-traverser */ "./src/tileset/tileset-3d-traverser.js");
/* harmony import */ var _tileset_3d_cache__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./tileset-3d-cache */ "./src/tileset/tileset-3d-cache.js");
// This file is derived from the Cesium code base under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md














// Tracked Stats
const TILES_TOTAL = 'Tiles In Tileset(s)';
const TILES_IN_MEMORY = 'Tiles In Memory';
const TILES_IN_VIEW = 'Tiles In View';
const TILES_RENDERABLE = 'Tiles To Render';
const TILES_LOADED = 'Tiles Loaded';
const TILES_LOADING = 'Tiles Loading';
const TILES_UNLOADED = 'Tiles Unloaded';
const TILES_LOAD_FAILED = 'Failed Tile Loads';
const POINTS_COUNT = 'Points';
const TILES_GPU_MEMORY = 'Tile Memory Use';

// TODO move to Math library?
const WGS84_RADIUS_X = 6378137.0;
const WGS84_RADIUS_Y = 6378137.0;
const WGS84_RADIUS_Z = 6356752.3142451793;

function getZoom(boundingVolume) {
  const {halfAxes, radius, width, height} = boundingVolume;

  if (halfAxes) {
    // OrientedBoundingBox
    const [x, , , , y, , , , z] = halfAxes;
    const zoomX = Math.log2(WGS84_RADIUS_X / x / 2);
    const zoomY = Math.log2(WGS84_RADIUS_Y / y / 2);
    const zoomZ = Math.log2(WGS84_RADIUS_Z / z / 2);
    return (zoomX + zoomY + zoomZ) / 3;
  } else if (radius) {
    // BoundingSphere
    return Math.log2(WGS84_RADIUS_Z / radius);
  } else if (height && width) {
    // BoundingRectangle
    const zoomX = Math.log2(WGS84_RADIUS_X / width);
    const zoomY = Math.log2(WGS84_RADIUS_Y / height);

    return (zoomX + zoomY) / 2;
  }

  return 18;
}

const DEFAULT_OPTIONS = {
  basePath: '',

  ellipsoid: _math_gl_geospatial__WEBPACK_IMPORTED_MODULE_1__["Ellipsoid"].WGS84,
  // A 4x4 transformation matrix this transforms the entire tileset.
  modelMatrix: new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix4"](),

  // Set to true to enable experimental request throttling, for improved performance
  throttleRequests: false,

  // The maximum screen space error used to drive level of detail refinement.
  maximumScreenSpaceError: 16,
  maximumMemoryUsage: 32,

  // default props
  dynamicScreenSpaceError: false,
  dynamicScreenSpaceErrorDensity: 0.00278,
  dynamicScreenSpaceErrorFactor: 4.0,

  // Optimization option. Determines if level of detail skipping should be applied during the traversal.
  skipLevelOfDetail: false,
  // The screen space error this must be reached before skipping levels of detail.
  baseScreenSpaceError: 1024,

  onTileLoad: () => {}, // Indicates this a tile's content was loaded
  onTileUnload: () => {}, // Indicates this a tile's content was unloaded
  onTileLoadFail: (tile, message, url) =>
    console.error(`A 3D tile failed to load: ${url} ${message}`) // eslint-disable-line
};

function getQueryParamString(queryParams) {
  const queryParamStrings = [];
  for (const key of Object.keys(queryParams)) {
    queryParamStrings.push(`${key}=${queryParams[key]}`);
  }
  switch (queryParamStrings.length) {
    case 0:
      return '';
    case 1:
      return `?${queryParamStrings[0]}`;
    default:
      return `?${queryParamStrings.join('&')}`;
  }
}

class Tileset3D {
  // eslint-disable-next-line max-statements
  constructor(json, url, options = {}) {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_4__["default"])(json);

    // PUBLIC MEMBERS
    this.options = {...DEFAULT_OPTIONS, ...options};
    this.url = url; // The url to a tileset JSON file.
    this.basePath = _loaders_gl_core__WEBPACK_IMPORTED_MODULE_3__["path"].dirname(url); // base path that non-absolute paths in tileset are relative to.
    this.modelMatrix = this.options.modelMatrix;
    this.stats = new probe_gl__WEBPACK_IMPORTED_MODULE_2__["Stats"]({id: url});
    this._initializeStats();

    this.gpuMemoryUsageInBytes = 0; // The total amount of GPU memory in bytes used by the tileset.
    this.geometricError = undefined; // Geometric error when the tree is not rendered at all
    this.userData = {};

    // HELPER OBJECTS
    this._queryParams = {};
    this._requestScheduler = new _request_utils_request_scheduler__WEBPACK_IMPORTED_MODULE_5__["default"]({
      throttleRequests: this.options.throttleRequests
    });
    this._traverser = new _tileset_3d_traverser__WEBPACK_IMPORTED_MODULE_8__["default"]();
    this._cache = new _tileset_3d_cache__WEBPACK_IMPORTED_MODULE_9__["default"]();

    // HOLD TRAVERSAL RESULTS
    this._processingQueue = [];
    this.selectedTiles = [];
    this._emptyTiles = [];
    this._requestedTiles = [];
    this._selectedTilesToStyle = [];

    this.asset = {}; // Metadata for the entire tileset
    this.credits = {};

    // EXTRACTED FROM TILESET
    this._root = undefined;
    this._properties = undefined; // Metadata for per-model/point/etc properties
    this._extensionsUsed = undefined;
    this._gltfUpAxis = undefined;

    this._loadTimestamp = undefined;
    this._timeSinceLoad = 0.0;
    this._updatedVisibilityFrame = 0;
    this._extras = undefined;

    this._allTilesAdditive = true;
    this._hasMixedContent = false;
    this._maximumScreenSpaceError = options.maximumScreenSpaceError;
    this._maximumMemoryUsage = options.maximumMemoryUsage;

    this._tilesLoaded = false;
    this._initialTilesLoaded = false;

    this._readyPromise = Promise.resolve();

    this._classificationType = this.options.classificationType;
    this._ellipsoid = this.options.ellipsoid;

    this._dynamicScreenSpaceErrorComputedDensity = 0.0; // Updated based on the camera position and direction

    this._initializeTileSet(json, this.options);
  }

  destroy() {
    this._destroy();
  }

  // Gets the tileset's asset object property, which contains metadata about the tileset.
  // get asset() {
  //   return this._asset;
  // }

  // Gets the tileset's properties dictionary object, which contains metadata about per-feature properties.
  get properties() {
    return this._properties;
  }

  // When <code>true</code>, the tileset's root tile is loaded and the tileset is ready to render.
  get ready() {
    return Boolean(this._root);
  }

  // Gets the promise this will be resolved when the tileset's root tile is loaded and the tileset is ready to render.
  // This promise is resolved at the end of the frame before the first frame the tileset is rendered in.
  get readyPromise() {
    return this._readyPromise.promise;
  }

  // When <code>true</code>, all tiles this meet the screen space error this frame are loaded.
  get tilesLoaded() {
    return this._tilesLoaded;
  }

  get queryParams() {
    return getQueryParamString(this._queryParams);
  }

  // The root tile header.
  get root() {
    return this._root;
  }

  // The tileset's bounding sphere.
  get boundingSphere() {
    this._checkReady();
    this._root.updateTransform(this.modelMatrix);
    return this._root.boundingSphere;
  }

  // Returns the time, in milliseconds, since the tileset was loaded and first updated.
  get timeSinceLoad() {
    return this._timeSinceLoad;
  }

  // The maximum amount of GPU memory (in MB) that may be used to cache tiles.
  // Tiles not in view are unloaded to enforce this.
  get maximumMemoryUsage() {
    return this._maximumMemoryUsage;
  }

  set maximumMemoryUsage(value) {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_4__["default"])(value > 0);
    this._maximumMemoryUsage = value;
  }

  // Gets an ellipsoid describing the shape of the globe.
  get ellipsoid() {
    return this.options.ellipsoid;
  }

  // Returns the extras property at the top of the tileset JSON (application specific metadata).
  get extras() {
    return this._extras;
  }

  getTileUrl(tilePath, basePath) {
    const isDataUrl = url => url.startsWith('data:');
    return isDataUrl(tilePath)
      ? tilePath
      : `${basePath || this.basePath}/${tilePath}${this.queryParams}`;
  }

  // true if the tileset JSON file lists the extension in extensionsUsed
  hasExtension(extensionName) {
    return Boolean(this._extensionsUsed && this._extensionsUsed.indexOf(extensionName) > -1);
  }

  update(frameState) {
    this._updatedVisibilityFrame++; // TODO: only update when camera or culling volume from last update moves (could be render camera change or prefetch camera)
    this._cache.reset();

    this._traverser.traverse(this.root, frameState, this.options);
    Object.assign(this, this._traverser.result); // Hack during refactor

    const requestedTiles = this._requestedTiles;
    // Sort requests by priority before making any requests.
    // This makes it less likely this requests will be cancelled after being issued.
    // requestedTiles.sort((a, b) => a._priority - b._priority);
    for (const tile of requestedTiles) {
      this._loadTile(tile);
    }

    this._unloadTiles();

    let tilesRenderable = 0;
    let pointsRenderable = 0;
    for (const tile of this.selectedTiles) {
      if (tile.contentAvailable) {
        tilesRenderable++;
        if (tile.content.pointCount) {
          pointsRenderable += tile.content.pointCount;
        }
      }
    }

    this.stats.get(TILES_IN_VIEW).count = this.selectedTiles.length;
    this.stats.get(TILES_RENDERABLE).count = tilesRenderable;
    this.stats.get(POINTS_COUNT).count = pointsRenderable;
  }

  // TODO - why are these public methods? For testing?

  // Unloads all tiles this weren't selected the previous frame.  This can be used to
  trimLoadedTiles() {
    this._cache.trim();
  }

  // Add to the tile cache. Previously expired tiles are already in the cache and won't get re-added.
  addTileToCache(tile) {
    this._cache.add(this, tile, (tileset, tileToAdd) => tileset._addTileToCache(tileToAdd));
  }

  // PRIVATE

  // eslint-disable-next-line max-statements
  _initializeTileSet(tilesetJson, options) {
    this.asset = tilesetJson.asset;
    if (!this.asset) {
      throw new Error('Tileset must have an asset property.');
    }
    if (this.asset.version !== '0.0' && this.asset.version !== '1.0') {
      throw new Error('The tileset must be 3D Tiles version 0.0 or 1.0.');
    }

    // Note: `asset.tilesetVersion` is version of the tileset itself (not the version of the 3D TILES standard)
    // We add this version as a `v=1.0` query param to fetch the right version and not get an older cached version
    if ('tilesetVersion' in this.asset) {
      this._queryParams.v = this.asset.tilesetVersion;
    }

    // TODO - ion resources have a credits property we can use for additional attribution.
    this.credits = {
      attributions: options.attributions || []
    };

    this._properties = tilesetJson.properties;
    this.geometricError = tilesetJson.geometricError;
    this._extensionsUsed = tilesetJson.extensionsUsed;
    this._extras = tilesetJson.extras;

    // TODO - handle configurable glTF up axis
    // const gltfUpAxis = defined(tilesetJson.asset.gltfUpAxis)
    //   ? Axis.fromName(tilesetJson.asset.gltfUpAxis)
    //   : Axis.Y;

    this._root = this._initializeTileHeaders(tilesetJson, null, this.basePath);

    // Calculate cartographicCenter & zoom props to help apps center view on tileset
    this._calculateViewProps();

    // TODO - Do we need this?
    // Save the original, untransformed bounding volume position so we can apply
    // the tile transform and model matrix at run time
    // const boundingVolume = this._root.createBoundingVolume(
    //   tilesetJson.root.boundingVolume,
    //   Matrix4.IDENTITY
    // );
    // const clippingPlanesOrigin = boundingVolume.boundingSphere.center;
    // If this origin is above the surface of the earth
    // we want to apply an ENU orientation as our best guess of orientation.
    // Otherwise, we assume it gets its position/orientation completely from the
    // root tile transform and the tileset's model matrix
    // const originCartographic = this._ellipsoid.cartesianToCartographic(clippingPlanesOrigin);
    // if (
    //   originCartographic &&
    //   originCartographic.height > ApproximateTerrainHeights._defaultMinTerrainHeight
    // ) {
    //   this._initialClippingPlanesOriginMatrix = Transforms.eastNorthUpToFixedFrame(
    //     clippingPlanesOrigin
    //   );
    // }

    // this._clippingPlanesOriginMatrix = Matrix4.clone(this._initialClippingPlanesOriginMatrix);
    // this._readyPromise.resolve(this);
  }

  // Called during intializeTileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.
  _calculateViewProps() {
    const root = this._root;
    const {center} = root.boundingVolume;
    // TODO - handle all cases
    if (!center) {
      // eslint-disable-next-line
      console.warn('center was not pre-calculated for the root tile');
      this.cartographicCenter = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
      this.zoom = 16;
      return;
    }
    this.cartographicCenter = _math_gl_geospatial__WEBPACK_IMPORTED_MODULE_1__["Ellipsoid"].WGS84.cartesianToCartographic(center, new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]());
    this.zoom = getZoom(root.boundingVolume);
  }

  _initializeStats() {
    this.stats.get(TILES_TOTAL);
    this.stats.get(TILES_LOADING);
    this.stats.get(TILES_IN_MEMORY);
    this.stats.get(TILES_IN_VIEW);
    this.stats.get(TILES_RENDERABLE);
    this.stats.get(TILES_LOADED);
    this.stats.get(TILES_UNLOADED);
    this.stats.get(TILES_LOAD_FAILED);
    this.stats.get(POINTS_COUNT, 'memory');
    this.stats.get(TILES_GPU_MEMORY, 'memory');
  }

  // Installs the main tileset JSON file or a tileset JSON file referenced from a tile.
  // eslint-disable-next-line max-statements
  _initializeTileHeaders(tilesetJson, parentTileHeader, basePath) {
    // A tileset JSON file referenced from a tile may exist in a different directory than the root tileset.
    // Get the basePath relative to the external tileset.
    const rootTile = new _tile_3d_header__WEBPACK_IMPORTED_MODULE_7__["default"](this, tilesetJson.root, parentTileHeader, basePath); // resource

    // If there is a parentTileHeader, add the root of the currently loading tileset
    // to parentTileHeader's children, and update its _depth.
    if (parentTileHeader) {
      parentTileHeader.children.push(rootTile);
      rootTile._depth = parentTileHeader._depth + 1;
    }

    const stack = [];
    stack.push(rootTile);

    while (stack.length > 0) {
      const tile = stack.pop();
      this.stats.get(TILES_TOTAL).incrementCount();
      // this._allTilesAdditive = this._allTilesAdditive && tile.refine === TILE_3D_REFINE.ADD;

      const children = tile._header.children || [];
      for (const childHeader of children) {
        const childTile = new _tile_3d_header__WEBPACK_IMPORTED_MODULE_7__["default"](this, childHeader, tile, basePath);
        tile.children.push(childTile);
        childTile._depth = tile._depth + 1;
        stack.push(childTile);
      }

      // TODO:
      // if (this.options.cullWithChildrenBounds) {
      //   Tile3DOptimizations.checkChildrenWithinParent(tile);
      // }
    }

    return rootTile;
  }

  _destroyTileHeaders(parentTile) {
    this._destroySubtree(parentTile);
  }

  async _loadTile(tile) {
    // TODO - support tile expiration
    // const expired = tile.contentExpired;
    // if (expired) {
    //   if (tile.hasTilesetContent) {
    //     this._destroySubtree(tile);
    //   }
    // }

    let loaded;

    this.stats.get(TILES_LOADING).incrementCount();
    try {
      loaded = await tile.loadContent();
    } catch (error) {
      this.stats.get(TILES_LOADING).decrementCount();
      this.stats.get(TILES_LOAD_FAILED).incrementCount();
      this.options.onTileLoadFail(tile, error.message || error.toString(), tile.url);
      return;
    }
    this.stats.get(TILES_LOADING).decrementCount();

    if (!loaded) {
      return;
    }

    // add coordinateOrigin and modelMatrix to tile
    if (tile && tile._content) {
      Object(_helpers_transform_utils__WEBPACK_IMPORTED_MODULE_6__["calculateTransformProps"])(tile, tile._content);
    }

    this.options.onTileLoad(tile);
  }

  _addTileToCache(tile) {
    this.stats.get(TILES_LOADED).incrementCount();
    this.stats.get(TILES_IN_MEMORY).incrementCount();

    // Good enough? Just use the raw binary ArrayBuffer's byte length.
    this.gpuMemoryUsageInBytes += tile._content.byteLength || 0;
    this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;
  }

  _unloadTile(tile) {
    this.stats.get(TILES_IN_MEMORY).decrementCount();
    this.stats.get(TILES_UNLOADED).incrementCount();

    this.gpuMemoryUsageInBytes -= tile._content.byteLength || 0;
    this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;

    this.options.onTileUnload(tile);
    tile.unloadContent();
  }

  _unloadTiles() {
    this._cache.unloadTiles(this, (tileset, tile) => tileset._unloadTile(tile));
  }

  // Traverse the tree and destroy all tiles
  _destroy() {
    const stack = [];
    if (this._root) {
      stack.push(this._root);
    }
    while (stack.length > 0) {
      for (const child of tile.children) {
        stack.push(child);
      }
      const tile = stack.pop();

      // TODO - Use this._destroyTile(tile); ?
      tile.destroy();
    }
    this._root = null;
  }

  // Traverse the tree and destroy all sub tiles
  _destroySubtree(tile) {
    const root = tile;
    const stack = [];
    stack.push(root);
    while (stack.length > 0) {
      tile = stack.pop();
      for (const child of tile.children) {
        stack.push(child);
      }
      if (tile !== root) {
        this._destroyTile(tile);
      }
    }
    root.children = [];
  }

  _destroyTile(tile) {
    this._cache.unloadTile(this, tile);
    this._unloadTile(tile);
    tile.destroy();
  }
}


/***/ }),

/***/ "./src/utils/assert.js":
/*!*****************************!*\
  !*** ./src/utils/assert.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
// Replacement for the external assert method to reduce bundle size
// Note: We don't use the second "message" argument in calling code,
// so no need to support it here
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || '3d-tile loader: assertion failed.');
  }
}


/***/ }),

/***/ "./src/utils/doubly-linked-list-node.js":
/*!**********************************************!*\
  !*** ./src/utils/doubly-linked-list-node.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DoublyLinkedListNode; });
// This file is derived from the Cesium code base under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md

/**
 * Doubly linked list node
 *
 * @private
 */
class DoublyLinkedListNode {
  constructor(item, previous, next) {
    this.item = item;
    this.previous = previous;
    this.next = next;
  }
}


/***/ }),

/***/ "./src/utils/doubly-linked-list.js":
/*!*****************************************!*\
  !*** ./src/utils/doubly-linked-list.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DoublyLinkedList; });
/* harmony import */ var _utils_doubly_linked_list_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/doubly-linked-list-node */ "./src/utils/doubly-linked-list-node.js");
// This file is derived from the Cesium code base under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md



const defined = x => x !== undefined;

/**
 * Doubly linked list
 *
 * @private
 */
class DoublyLinkedList {
  constructor() {
    this.head = undefined;
    this.tail = undefined;
    this._length = 0;
  }

  get length() {
    return this._length;
  }

  /**
   * Adds the item to the end of the list
   * @param {*} [item]
   * @return {DoublyLinkedListNode}
   */
  add(item) {
    const node = new _utils_doubly_linked_list_node__WEBPACK_IMPORTED_MODULE_0__["default"](item, this.tail, undefined);

    if (defined(this.tail)) {
      this.tail.next = node;
      this.tail = node;
    } else {
      this.head = node;
      this.tail = node;
    }

    ++this._length;

    return node;
  }

  /**
   * Removes the given node from the list
   * @param {DoublyLinkedListNode} node
   */
  remove(node) {
    if (!defined(node)) {
      return;
    }

    if (defined(node.previous) && defined(node.next)) {
      node.previous.next = node.next;
      node.next.previous = node.previous;
    } else if (defined(node.previous)) {
      // Remove last node
      node.previous.next = undefined;
      this.tail = node.previous;
    } else if (defined(node.next)) {
      // Remove first node
      node.next.previous = undefined;
      this.head = node.next;
    } else {
      // Remove last node in the linked list
      this.head = undefined;
      this.tail = undefined;
    }

    node.next = undefined;
    node.previous = undefined;

    --this._length;
  }

  /**
   * Moves nextNode after node
   * @param {DoublyLinkedListNode} node
   * @param {DoublyLinkedListNode} nextNode
   */
  splice(node, nextNode) {
    if (node === nextNode) {
      return;
    }

    // Remove nextNode, then insert after node
    this.remove(nextNode);

    const oldNodeNext = node.next;
    node.next = nextNode;

    // Tail check
    if (this.tail === node) {
      this.tail = nextNode;
    } else {
      oldNodeNext.previous = nextNode;
    }

    nextNode.next = oldNodeNext;
    nextNode.previous = node;
  }
}


/***/ }),

/***/ "./src/utils/managed-array.js":
/*!************************************!*\
  !*** ./src/utils/managed-array.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ManagedArray; });
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert */ "./src/utils/assert.js");
// This file is derived from the Cesium code base under Apache 2 license
// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md



/**
 * A wrapper around arrays so that the internal length of the array can be manually managed.
 *
 * @alias ManagedArray
 * @constructor
 * @private
 *
 * @param {Number} [length=0] The initial length of the array.
 */
class ManagedArray {
  constructor(length = 0) {
    this._array = new Array(length);
    this._length = length;
  }

  /**
   * Gets or sets the length of the array.
   * If the set length is greater than the length of the internal array, the internal array is resized.
   *
   * @memberof ManagedArray.prototype
   * @type Number
   */
  get length() {
    return this._length;
  }

  set length(length) {
    this._length = length;
    if (length > this._array.length) {
      this._array.length = length;
    }
  }

  /**
   * Gets the internal array.
   *
   * @memberof ManagedArray.prototype
   * @type Array
   * @readonly
   */
  get values() {
    return this._array;
  }

  /**
   * Gets the element at an index.
   *
   * @param {Number} index The index to get.
   */
  get(index) {
    Object(_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(index < this._array.length);
    return this._array[index];
  }

  /**
   * Sets the element at an index. Resizes the array if index is greater than the length of the array.
   *
   * @param {Number} index The index to set.
   * @param {*} element The element to set at index.
   */
  set(index, element) {
    Object(_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(index >= 0);

    if (index >= this.length) {
      this.length = index + 1;
    }
    this._array[index] = element;
  }

  /**
   * Returns the last element in the array without modifying the array.
   *
   * @returns {*} The last element in the array.
   */
  peek() {
    return this._array[this._length - 1];
  }

  /**
   * Push an element into the array.
   *
   * @param {*} element The element to push.
   */
  push(element) {
    const index = this.length++;
    this._array[index] = element;
  }

  /**
   * Pop an element from the array.
   *
   * @returns {*} The last element in the array.
   */
  pop() {
    return this._array[--this.length];
  }

  /**
   * Resize the internal array if length > _array.length.
   *
   * @param {Number} length The length.
   */
  reserve(length) {
    Object(_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(length >= 0);

    if (length > this._array.length) {
      this._array.length = length;
    }
  }

  /**
   * Resize the array.
   *
   * @param {Number} length The length.
   */
  resize(length) {
    Object(_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(length >= 0);

    this.length = length;
  }

  /**
   * Trim the internal array to the specified length. Defaults to the current length.
   *
   * @param {Number} [length] The length.
   */
  trim(length = this.length) {
    this._array.length = length;
  }
}


/***/ }),

/***/ 0:
/*!*******************************!*\
  !*** asciify-image (ignored) ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1:
/*!****************************************************!*\
  !*** ../node/utils/to-array-buffer.node (ignored) ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 2:
/*!************************************************!*\
  !*** ../../node/read-file-sync.node (ignored) ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 3:
/*!********************************************!*\
  !*** ../../node/write-file.node (ignored) ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
});