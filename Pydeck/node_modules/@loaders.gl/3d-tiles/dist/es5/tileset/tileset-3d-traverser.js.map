{"version":3,"sources":["../../../src/tileset/tileset-3d-traverser.js"],"names":["Tileset3DTraverser","traversal","stack","ManagedArray","stackMaximumLength","emptyTraversal","result","_requestedTiles","selectedTiles","_emptyTiles","_hasMixedContent","_disableSkipLevelOfDetail","root","frameState","options","length","updateTile","isVisibleAndInRequestVolume","getScreenSpaceError","maximumScreenSpaceError","baseScreenSpaceError","executeTraversal","trim","tile","_selectedFrame","frameNumber","push","skipLevelOfDetail","contentAvailable","selectTile","loadedTile","_ancestorWithContentAvailable","_shouldSelect","selectDescendants","tileset","_statistics","visited","_visitedFrame","_cache","touch","_touchedFrame","refine","TILE3D_REFINEMENT","ADD","_distanceToCamera","REPLACE","parent","useParentScreenSpaceError","_screenSpaceError","hasTilesetContent","screenSpaceError","rootScreenSpaceError","hasUnloadedContent","contentExpired","_requestedFrame","_priority","getPriority","updateVisibility","updateTileVisibility","updateExpiration","children","child","depthLimit","depth","Math","max","pop","add","replace","parentRefines","_refines","refines","canTraverse","updateAndPushChildren","stoppedRefining","hasRenderContent","loadTile","selectDesiredTile","touchTile"],"mappings":"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","sourcesContent":["// import {TILE3D_REFINEMENT, TILE3D_OPTIMIZATION_HINT} from '../constants';\nimport {TILE3D_REFINEMENT} from '../constants';\nimport ManagedArray from '../utils/managed-array';\nimport assert from '../utils/assert';\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nexport default class Tileset3DTraverser {\n  constructor() {\n    this.traversal = {\n      stack: new ManagedArray(),\n      stackMaximumLength: 0\n    };\n\n    this.emptyTraversal = {\n      stack: new ManagedArray(),\n      stackMaximumLength: 0\n    };\n\n    this.result = {\n      _requestedTiles: [],\n      selectedTiles: [],\n      _emptyTiles: [],\n      _hasMixedContent: false\n    };\n\n    // Optimization option. Determines if level of detail skipping should be applied during the traversal.\n    this._disableSkipLevelOfDetail = false;\n  }\n\n  traverse(root, frameState, options) {\n    this.root = root; // for root screen space error\n    this.options = options;\n\n    this.result._requestedTiles.length = 0;\n    this.result.selectedTiles.length = 0;\n    this.result._emptyTiles.length = 0;\n    // this.result._selectedTilesToStyle.length = 0;\n    this.result._hasMixedContent = false;\n\n    this.updateTile(root, frameState);\n\n    // The root tile is not visible\n    if (!root.isVisibleAndInRequestVolume) {\n      return false;\n    }\n\n    // The this doesn't meet the SSE requirement, therefore the tree does not need to be rendered\n    // The alwaysLoadRoot is better solved by moving the camera to the newly selected asset.\n    if (root.getScreenSpaceError(frameState, true) <= options.maximumScreenSpaceError) {\n      return false;\n    }\n\n    const baseScreenSpaceError = options.maximumScreenSpaceError;\n    this.executeTraversal(root, baseScreenSpaceError, frameState);\n\n    this.traversal.stack.trim(this.traversal.stackMaximumLength);\n    this.emptyTraversal.stack.trim(this.emptyTraversal.stackMaximumLength);\n\n    return true;\n  }\n\n  selectTile(tile, frameState) {\n    tile._selectedFrame = frameState.frameNumber;\n    this.result.selectedTiles.push(tile);\n\n    // if (tile.contentVisibility(frameState) !== Intersect.OUTSIDE) {\n    //   if (tile.content.featurePropertiesDirty) {\n    //     // A feature's property in this tile changed, the tile needs to be re-styled.\n    //     tile.content.featurePropertiesDirty = false;\n    //     tile.lastStyleTime = 0; // Force applying the style to this tile\n    //     tileset._selectedTilesToStyle.push(tile);\n    //   } else if (tile._selectedFrame < frameState.frameNumber - 1) {\n    //     // Tile is newly selected; it is selected this frame, but was not selected last frame.\n    //     tileset._selectedTilesToStyle.push(tile);\n    //   }\n    //   tile._selectedFrame = frameState.frameNumber;\n    //   tileset.selectedTiles.push(tile);\n    // }\n  }\n\n  selectDesiredTile(tile, frameState) {\n    if (!this.options.skipLevelOfDetail) {\n      if (tile.contentAvailable) {\n        // The tile can be selected right away and does not require traverseAndSelect\n        this.selectTile(tile, frameState);\n      }\n      return;\n    }\n\n    // If this tile is not loaded attempt to select its ancestor instead\n    const loadedTile = tile.contentAvailable ? tile : tile._ancestorWithContentAvailable;\n    if (loadedTile) {\n      // Tiles will actually be selected in traverseAndSelect\n      loadedTile._shouldSelect = true;\n    } else {\n      // If no ancestors are ready traverse down and select tiles to minimize empty regions.\n      // This happens often for immediatelyLoadDesiredLevelOfDetail where parent tiles\n      // are not necessarily loaded before zooming out.\n      this.selectDescendants(tile, frameState);\n    }\n  }\n\n  visitTile(tileset, tile, frameState) {\n    ++tileset._statistics.visited;\n    tile._visitedFrame = frameState.frameNumber;\n  }\n\n  touchTile(tile, frameState) {\n    // TODO need a better frameNumber since it can be the same between updates\n    // Until then this needs to be commented out\n    // if (tile._touchedFrame === frameState.frameNumber) {\n    //   // Prevents another pass from touching the frame again\n    //   return;\n    // }\n    // TODO: add function to tile that te\n    tile.tileset._cache.touch(tile);\n    tile._touchedFrame = frameState.frameNumber;\n  }\n\n  // If skipLevelOfDetail is off try to load child tiles as soon as possible so that their parent can refine sooner.\n  // Additive tiles are prioritized by distance because it subjectively looks better.\n  // Replacement tiles are prioritized by screen space error.\n  // A tileset that has both additive and replacement tiles may not prioritize tiles as effectively since SSE and distance\n  // are different types of values. Maybe all priorities need to be normalized to 0-1 range.\n  getPriority(tile, options) {\n    switch (tile.refine) {\n      case TILE3D_REFINEMENT.ADD:\n        return tile._distanceToCamera;\n\n      case TILE3D_REFINEMENT.REPLACE:\n        const {parent} = tile;\n        const useParentScreenSpaceError =\n          parent &&\n          (!options.skipLevelOfDetail ||\n            tile._screenSpaceError === 0.0 ||\n            parent.hasTilesetContent);\n        const screenSpaceError = useParentScreenSpaceError\n          ? parent._screenSpaceError\n          : tile._screenSpaceError;\n        const rootScreenSpaceError = this.root._screenSpaceError;\n        return rootScreenSpaceError - screenSpaceError; // Map higher SSE to lower values (e.g. root tile is highest priority)\n\n      default:\n        return assert(false);\n    }\n  }\n\n  loadTile(tile, frameState) {\n    if (tile.hasUnloadedContent || tile.contentExpired) {\n      tile._requestedFrame = frameState.frameNumber;\n      tile._priority = this.getPriority(tile, this.options);\n      this.result._requestedTiles.push(tile);\n    }\n  }\n\n  // anyChildrenVisible(tileset, tile, frameState) {\n  //   let anyVisible = false;\n  //   for (const child of tile.children) {\n  //     child.updateVisibility(frameState);\n  //     anyVisible = anyVisible || child.isVisibleAndInRequestVolume;\n  //   }\n  //   return anyVisible;\n  // }\n\n  // meetsScreenSpaceErrorEarly(tileset, tile, frameState) {\n  //   const {parent} = tile;\n  //   if (!parent || parent.hasTilesetContent || parent.refine !== TILE3D_REFINEMENT.ADD) {\n  //     return false;\n  //   }\n  //\n  //   // Use parent's geometric error with child's box to see if the tile already meet the SSE\n  //   return tile.getScreenSpaceError(frameState, true) <= tileset.maximumScreenSpaceError;\n  // }\n\n  updateTileVisibility(tile, frameState) {\n    tile.updateVisibility(frameState);\n\n    // //  Optimization - if none of the tile's children are visible then this tile isn't visible\n    // if (!tile.isVisibleAndInRequestVolume) {\n    //   return;\n    // }\n    //\n    // const hasChildren = tile.children.length > 0;\n    // if (tile.hasTilesetContent && hasChildren) {\n    //   // Use the root tile's visibility instead of this tile's visibility.\n    //   // The root tile may be culled by the children bounds optimization in which\n    //   // case this tile should also be culled.\n    //   const firstChild = tile.children[0];\n    //   this.updateTileVisibility(tileset, firstChild, frameState);\n    //   tile._visible = firstChild._visible;\n    //   return;\n    // }\n    //\n    // if (this.meetsScreenSpaceErrorEarly(tileset, tile, frameState)) {\n    //   tile._visible = false;\n    //   return;\n    // }\n    //\n    // const replace = tile.refine === TILE3D_REFINEMENT.REPLACE;\n    // const useOptimization =\n    //   tile._optimChildrenWithinParent === TILE3D_OPTIMIZATION_HINT.USE_OPTIMIZATION;\n    // if (replace && useOptimization && hasChildren) {\n    //   if (!this.anyChildrenVisible(tileset, tile, frameState)) {\n    //     ++tileset._statistics.numberOfTilesCulledWithChildrenUnion;\n    //     tile._visible = false;\n    //     return;\n    //   }\n    // }\n  }\n\n  updateTile(tile, frameState) {\n    this.updateTileVisibility(tile, frameState);\n    tile.updateExpiration();\n  }\n\n  // eslint-disable-next-line complexity\n  updateAndPushChildren(tile, stack, frameState) {\n    const {children} = tile;\n\n    for (const child of children) {\n      this.updateTile(child, frameState);\n      stack.push(child);\n    }\n    return true;\n\n    // for (const child of children) {\n    //   this.updateTile(child, frameState);\n    // }\n    //\n    // function compareDistanceToCamera(a, b) {\n    //   // Sort by farthest child first since this is going on a stack\n    //   return b._distanceToCamera === 0 && a._distanceToCamera === 0\n    //     ? b._centerZDepth - a._centerZDepth\n    //     : b._distanceToCamera - a._distanceToCamera;\n    // }\n    //\n    // // Sort by distance to take advantage of early Z and reduce artifacts for skipLevelOfDetail\n    // children.sort(compareDistanceToCamera);\n    //\n    // // For traditional replacement refinement only refine if all children are loaded.\n    // // Empty tiles are exempt since it looks better if children stream in as they are loaded to fill the empty space.\n    // const checkRefines = !options.skipLevelOfDetail && tile.refine === TILE3D_REFINEMENT.REPLACE && tile.hasRenderContent\n    // let refines = true;\n    //\n    // let anyChildrenVisible = false;\n    // for (const child of children) {\n    //   if (child.isVisibleAndInRequestVolume) {\n    //     stack.push(child);\n    //     anyChildrenVisible = true;\n    //   } else if (checkRefines || options.loadSiblings) {\n    //     // Keep non-visible children loaded since they are still needed before the parent can refine.\n    //     // Or loadSiblings is true so always load tiles regardless of visibility.\n    //     this.loadTile(child, frameState);\n    //     this.touchTile(child, frameState);\n    //   }\n    //   if (checkRefines) {\n    //     let childRefines;\n    //     if (!child._inRequestVolume) {\n    //       childRefines = false;\n    //     } else if (!child.hasRenderContent) {\n    //       childRefines = this.executeEmptyTraversal(child, frameState);\n    //     } else {\n    //       childRefines = child.contentAvailable;\n    //     }\n    //     refines = refines && childRefines;\n    //   }\n    // }\n    //\n    // if (!anyChildrenVisible) {\n    //   refines = false;\n    // }\n    //\n    // return refines;\n  }\n\n  canTraverse(tile, options) {\n    // TODO: remove the depthLimit check once real sse is working\n    if (tile.children.length === 0 || options.depthLimit < tile.depth) {\n      return false;\n    }\n\n    if (tile.hasTilesetContent) {\n      // Traverse external this to visit its root tile\n      // Don't traverse if the subtree is expired because it will be destroyed\n      return !tile.contentExpired;\n    }\n\n    return tile._screenSpaceError > options.maximumScreenSpaceError;\n  }\n\n  // Depth-first traversal that traverses all visible tiles and marks tiles for selection.\n  // If skipLevelOfDetail is off then a tile does not refine until all children are loaded.\n  // This is the traditional replacement refinement approach and is called the base traversal.\n  // Tiles that have a greater screen space error than the base screen space error are part of the base traversal,\n  // all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree\n  // and rendering children and parent tiles simultaneously.\n\n  // eslint-disable-next-line max-statements, complexity\n  executeTraversal(root, baseScreenSpaceError, frameState) {\n    const {traversal} = this;\n    const {stack} = traversal;\n    stack.push(root);\n\n    while (stack.length > 0) {\n      traversal.stackMaximumLength = Math.max(traversal.stackMaximumLength, stack.length);\n\n      const tile = stack.pop();\n      const add = tile.refine === TILE3D_REFINEMENT.ADD;\n      const replace = tile.refine === TILE3D_REFINEMENT.REPLACE;\n      const parent = tile.parent;\n      const parentRefines = !parent || parent._refines;\n      let refines = false;\n\n      if (this.canTraverse(tile, this.options)) {\n        refines = this.updateAndPushChildren(tile, stack, frameState) && parentRefines;\n      }\n\n      const stoppedRefining = !refines && parentRefines;\n\n      if (!tile.hasRenderContent) {\n        // Add empty tile just to show its debug bounding volume\n        // If the tile has this content load the external this\n        // If the tile cannot refine further select its nearest loaded ancestor\n        this.result._emptyTiles.push(tile);\n        this.loadTile(tile, frameState);\n        if (stoppedRefining) {\n          this.selectDesiredTile(tile, frameState);\n        }\n      } else if (add) {\n        // Additive tiles are always loaded and selected\n        this.loadTile(tile, frameState);\n        this.selectDesiredTile(tile, frameState);\n      } else if (replace) {\n        // Always load tiles in the base traversal\n        // Select tiles that can't refine further\n        this.loadTile(tile, frameState);\n        if (stoppedRefining) {\n          this.selectDesiredTile(tile, frameState);\n        }\n      }\n\n      // this.visitTile(tileset, tile, frameState);\n      this.touchTile(tile, frameState);\n      tile._refines = refines;\n    }\n  }\n\n  // Depth-first traversal that checks if all nearest descendants with content are loaded. Ignores visibility.\n  // executeEmptyTraversal(root, frameState) {\n  //   const allDescendantsLoaded = true;\n  //   const stack = emptyTraversal.stack;\n  //   stack.push(root);\n  //\n  //   while (stack.length > 0) {\n  //     emptyTraversal.stackMaximumLength = Math.max(emptyTraversal.stackMaximumLength, stack.length);\n  //\n  //     const tile = stack.pop();\n  //     const children = tile.children;\n  //     const childrenLength = children.length;\n  //\n  //     // Only traverse if the tile is empty - traversal stop at descendants with content\n  //     const traverse = !tile.hasRenderContent && this.canTraverse(tile);\n  //\n  //     // Traversal stops but the tile does not have content yet.\n  //     // There will be holes if the parent tries to refine to its children, so don't refine.\n  //     if (!traverse && !tile.contentAvailable) {\n  //       allDescendantsLoaded = false;\n  //     }\n  //\n  //     this.updateTile(tile, frameState);\n  //     if (!tile.isVisibleAndInRequestVolume) {\n  //       // Load tiles that aren't visible since they are still needed for the parent to refine\n  //       this.loadTile(tile, frameState);\n  //       this.touchTile(tile, frameState);\n  //     }\n  //\n  //     if (traverse) {\n  //       for (const child of this.children) {\n  //         stack.push(child);\n  //       }\n  //     }\n  //   }\n  //\n  //   return allDescendantsLoaded;\n  // }\n}\n"],"file":"tileset-3d-traverser.js"}