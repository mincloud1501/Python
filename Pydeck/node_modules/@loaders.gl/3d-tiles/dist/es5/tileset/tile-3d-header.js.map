{"version":3,"sources":["../../../src/tileset/tile-3d-header.js"],"names":["defined","x","undefined","scratchDate","Date","scratchCommandList","scratchToTileCenter","Vector3","scratchPlane","Plane","computeVisibilityWithPlaneMask","cullingVolume","boundingVolume","parentPlaneMask","Number","isFinite","CullingVolume","MASK_OUTSIDE","MASK_INSIDE","mask","planes","k","length","flag","plane","fromNormalDistance","normal","distance","result","intersectPlane","Intersect","OUTSIDE","INTERSECTING","Tile3DHeader","tileset","header","parentHeader","basePath","_tileset","_header","_basePath","_content","_contentState","TILE3D_CONTENT_STATE","UNLOADED","_gpuMemoryUsageInBytes","parent","children","refine","_getRefine","cacheNode","userData","geometricError","console","warn","_initializeTransforms","_initializeBoundingVolumes","_initializeContent","_initializeCache","_optimChildrenWithinParent","TILE3D_OPTIMIZATION_HINT","NOT_COMPUTED","_initializeRenderingState","Object","seal","frameState","useParentGeometricError","parentGeometricError","Math","max","_distanceToCamera","height","sseDenominator","error","_getDynamicScreenSpaceError","fog","distanceToCamera","density","scalar","exp","dynamicScreenSpaceError","_dynamicScreenSpaceErrorComputedDensity","factor","dynamicScreenSpaceErrorFactor","dynamicError","updatePriority","tile","_visible","_priority","hasEmptyContent","expired","contentExpired","expireDate","LOADING","_requestScheduler","scheduleRequest","cancelled","contentUri","uri","startRequest","options","fetchOptions","response","endRequest","Tile3DLoader","Tileset3DLoader","indexOf","_initializeTileHeaders","path","dirname","READY","_contentLoaded","FAILED","hasRenderContent","destroy","_updatedVisibilityFrame","parentTransform","computedTransform","modelMatrix","parentVisibilityPlaneMask","_visibilityPlaneMask","MASK_INDETERMINATE","_updateTransform","distanceToTile","_screenSpaceError","getScreenSpaceError","visibility","_inRequestVolume","insideViewerRequestVolume","contentReady","now","lessThan","EXPIRED","_expiredContent","clippingPlanes","clippingPlanesOriginMatrix","enabled","intersection","computeIntersectionWithBoundingVolume","_isClipped","INSIDE","_boundingVolume","sqrt","distanceSquaredTo","camera","position","subVectors","center","direction","dot","viewerRequestVolume","_viewerRequestVolume","expire","expireDuration","duration","date","fromIso8601","tileHeader","transform","Matrix4","clone","multiplyRight","parentInitialTransform","_initialTransform","_contentBoundingVolume","content","_tile","contentState","_serverKey","hasTilesetContent","url","fullUri","_centerZDepth","_finalResolution","_depth","_stackLength","_selectionDepth","_touchedFrame","_visitedFrame","_selectedFrame","_requestedFrame","_ancestorWithContent","_ancestorWithContentAvailable","_refines","_shouldSelect","TILE3D_REFINEMENT","REPLACE","ADD","Boolean","asset","type","traverser","disableSkipLevelOfDetail","_isTileset","didTransformChange","equals","contentFailed","contentUnloaded","getTileUrl","boundingSphere","extras","updateContent","expiredContent","update","updateExpireDate","expireDurationDate","addSeconds","createPriorityFunction"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n// import {TILE3D_REFINEMENT, TILE3D_OPTIMIZATION_HINT} from '../constants';\nimport {Vector3, Matrix4} from 'math.gl';\nimport {CullingVolume} from '@math.gl/culling';\nimport {parse, fetchFile, path} from '@loaders.gl/core';\nimport Tile3DLoader from '../tile-3d-loader';\nimport Tileset3DLoader from '../tileset-3d-loader';\nimport {TILE3D_REFINEMENT, TILE3D_CONTENT_STATE, TILE3D_OPTIMIZATION_HINT} from '../constants';\nimport assert from '../utils/assert';\nimport {createBoundingVolume} from './helpers/bounding-volume';\n\nconst defined = x => x !== undefined && x !== null;\n\n/* eslint-disable */\nconst scratchDate = new Date();\nconst scratchCommandList = [];\nconst scratchToTileCenter = new Vector3();\n\n// TODO: Remove\nconst scratchPlane = new Plane();\nimport {INTERSECT, Intersect, Plane} from '@math.gl/culling';\n\nfunction computeVisibilityWithPlaneMask(cullingVolume, boundingVolume, parentPlaneMask) {\n  assert(boundingVolume, 'boundingVolume is required.');\n  assert(Number.isFinite(parentPlaneMask), 'parentPlaneMask is required.');\n\n  if (\n    parentPlaneMask === CullingVolume.MASK_OUTSIDE ||\n    parentPlaneMask === CullingVolume.MASK_INSIDE\n  ) {\n    // parent is completely outside or completely inside, so this child is as well.\n    return parentPlaneMask;\n  }\n\n  // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.\n  // (Because if there are fewer than 31 planes, the upper bits wont be changed.)\n  let mask = CullingVolume.MASK_INSIDE;\n\n  const planes = cullingVolume.planes;\n  for (let k = 0; k < cullingVolume.planes.length; ++k) {\n    // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.\n    const flag = k < 31 ? 1 << k : 0;\n    if (k < 31 && (parentPlaneMask & flag) === 0) {\n      // boundingVolume is known to be INSIDE this plane.\n      continue;\n    }\n\n    const plane = scratchPlane.fromNormalDistance(planes[k].normal, planes[k].distance);\n    const result = boundingVolume.intersectPlane(plane);\n\n    if (result === Intersect.OUTSIDE) {\n      return CullingVolume.MASK_OUTSIDE;\n    } else if (result === Intersect.INTERSECTING) {\n      mask |= flag;\n    }\n  }\n\n  return mask;\n}\n\n// A Tile3DHeader represents a tile a Tileset3D. When a tile is first created, its content is not loaded;\n// the content is loaded on-demand when needed based on the view.\n// Do not construct this directly, instead access tiles through {@link Tileset3D#tileVisible}.\nexport default class Tile3DHeader {\n  constructor(tileset, header, parentHeader, basePath) {\n    // assert(tileset._asset);\n    assert(typeof header === 'object');\n\n    this._tileset = tileset;\n    this._header = header;\n    this._basePath = basePath;\n    this._content = null;\n    this._contentState = TILE3D_CONTENT_STATE.UNLOADED;\n    this._gpuMemoryUsageInBytes = 0;\n\n    // This tile's parent or `undefined` if this tile is the root.\n    this.parent = parentHeader;\n    // The tile's children.\n    this.children = [];\n    // Specifies the type of refine that is used when traversing this tile for rendering.\n    this.refine = this._getRefine(header.refine);\n    this.cacheNode = undefined;\n    this.userData = {};\n\n    // The error, in meters, introduced if this tile is rendered and its children are not.\n    // This is used to compute screen space error, i.e., the error measured in pixels.\n    if ('geometricError' in header) {\n      this.geometricError = header.geometricError;\n    } else {\n      this.geometricError = (this.parent && this.parent.geometricError) || tileset.geometricError;\n      console.warn('3D Tile: Required prop geometricError is undefined. Using parent error');\n    }\n\n    this._initializeTransforms(header);\n    this._initializeBoundingVolumes(header);\n    this._initializeContent(header);\n    this._initializeCache(header);\n\n    // Marks whether the tile's children bounds are fully contained within the tile's bounds\n    // @type {TILE3D_OPTIMIZATION_HINT}\n    this._optimChildrenWithinParent = TILE3D_OPTIMIZATION_HINT.NOT_COMPUTED;\n\n    this._initializeRenderingState();\n\n    Object.seal(this);\n  }\n\n  destroy() {\n    this._header = null;\n  }\n\n  isDestroyed() {\n    return this._header === null;\n  }\n\n  // The tileset containing this tile.\n  get gpuMemoryUsageInBytes() {\n    return this._gpuMemoryUsageInBytes;\n  }\n\n  // The tileset containing this tile.\n  get tileset() {\n    return this._tileset;\n  }\n\n  // The depth of the tile in the tileset tree.\n  get depth() {\n    return this._depth;\n  }\n\n  // The most recent frame that the tile was selected\n  get selectedFrame() {\n    return this._selectedFrame;\n  }\n\n  get isVisibleAndInRequestVolume() {\n    return this._visible && this._inRequestVolume;\n  }\n\n  // The tile's content.  This represents the actual tile's payload,\n  // not the content's metadata in the tileset JSON file.\n  get content() {\n    return this._content;\n  }\n\n  // Determines if the tile's content is ready. This is automatically `true` for\n  // tile's with empty content.\n  get contentReady() {\n    return this._contentState === TILE3D_CONTENT_STATE.READY;\n  }\n\n  // Returns true if tile is not an empty tile and not an external tileset\n  get hasRenderContent() {\n    return !this.hasEmptyContent && !this.hasTilesetContent;\n  }\n\n  // Determines if the tile has available content to render.  `true` if the tile's\n  // content is ready or if it has expired content this renders while new content loads; otherwise,\n  get contentAvailable() {\n    return (\n      (this.contentReady && this.hasRenderContent) ||\n      (defined(this._expiredContent) && !this.contentFailed)\n    );\n  }\n\n  // Returns true if tile has renderable content but it's unloaded\n  get hasUnloadedContent() {\n    return this.hasRenderContent && this.contentUnloaded;\n  }\n\n  // Determines if the tile's content has not be requested. `true` if tile's\n  // content has not be requested; otherwise, `false`.\n  get contentUnloaded() {\n    return this._contentState === TILE3D_CONTENT_STATE.UNLOADED;\n  }\n\n  // Determines if the tile's content is expired. `true` if tile's\n  // content is expired; otherwise, `false`.\n  get contentExpired() {\n    return this._contentState === TILE3D_CONTENT_STATE.EXPIRED;\n  }\n\n  // Determines if the tile's content failed to load.  `true` if the tile's\n  // content failed to load; otherwise, `false`.\n  get contentFailed() {\n    return this._contentState === TILE3D_CONTENT_STATE.FAILED;\n  }\n\n  get url() {\n    return this.tileset.getTileUrl(this.contentUri, this._basePath);\n  }\n\n  get uri() {\n    return this.tileset.getTileUrl(this.contentUri, this._basePath);\n  }\n\n  // Get the tile's bounding volume.\n  get boundingVolume() {\n    return this._boundingVolume;\n  }\n\n  // Get the bounding volume of the tile's contents.  This defaults to the\n  // tile's bounding volume when the content's bounding volume is `undefined`.\n  get contentBoundingVolume() {\n    return this._contentBoundingVolume || this._boundingVolume;\n  }\n\n  // Get the bounding sphere derived from the tile's bounding volume.\n  get boundingSphere() {\n    return this._boundingVolume.boundingSphere;\n  }\n\n  // Returns the `extras` property in the tileset JSON for this tile, which contains application specific metadata.\n  // Returns `undefined` if `extras` does not exist.\n  // @see {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#specifying-extensions-and-application-specific-extras|Extras in the 3D Tiles specification.}\n  get extras() {\n    return this._header.extras;\n  }\n\n  get depth() {\n    return this._depth;\n  }\n\n  // Get the tile's screen space error.\n  getScreenSpaceError(frameState, useParentGeometricError) {\n    const tileset = this._tileset;\n    const parentGeometricError =\n      (this.parent && this.parent.geometricError) || tileset.geometricError;\n    const geometricError = useParentGeometricError ? parentGeometricError : this.geometricError;\n\n    // Leaf tiles do not have any error so save the computation\n    if (geometricError === 0.0) {\n      return 0.0;\n    }\n\n    // TODO: Orthographic Frustum needs special treatment?\n    // this._getOrthograhicScreenSpaceError();\n\n    // Avoid divide by zero when viewer is inside the tile\n    const distance = Math.max(this._distanceToCamera, 1e-7);\n    const {height, sseDenominator} = frameState;\n    let error = (geometricError * height) / (distance * sseDenominator);\n\n    error -= this._getDynamicScreenSpaceError(distance);\n\n    return error;\n  }\n\n  // TODO: Refined screen space error that minimizes tiles in non-first-person\n  _getDynamicScreenSpaceError(distance) {\n    function fog(distanceToCamera, density) {\n      const scalar = distanceToCamera * density;\n      return 1.0 - Math.exp(-(scalar * scalar));\n    }\n\n    const tileset = this._tileset;\n\n    if (tileset.dynamicScreenSpaceError && tileset._dynamicScreenSpaceErrorComputedDensity) {\n      const density = tileset._dynamicScreenSpaceErrorComputedDensity;\n      const factor = tileset.dynamicScreenSpaceErrorFactor;\n      const dynamicError = fog(distance, density) * factor;\n      return dynamicError;\n    }\n\n    return 0;\n  }\n\n  // Requests the tile's content.\n  // The request may not be made if the Request Scheduler can't prioritize it.\n  async loadContent() {\n    if (this.hasEmptyContent) {\n      return false;\n    }\n\n    if (this._content) {\n      return true;\n    }\n\n    const expired = this.contentExpired;\n\n    // Append a query parameter of the tile expiration date to prevent caching\n    // if (expired) {\n    //   expired: this.expireDate.toString()\n    // const request = new Request({\n    //   throttle: true,\n    //   throttleByServer: true,\n    //   type: RequestType.TILES3D,\n    //   priorityFunction: createPriorityFunction(this),\n    //   serverKey: this._serverKey\n    // });\n\n    if (expired) {\n      this.expireDate = undefined;\n    }\n\n    this._contentState = TILE3D_CONTENT_STATE.LOADING;\n\n    function updatePriority(tile) {\n      // Check if any reason to abort\n      if (!tile._visible) {\n        return -1;\n      }\n      if (tile._contentState === TILE3D_CONTENT_STATE.UNLOADED) {\n        return -1;\n      }\n      return Math.max(1e7 - tile._priority, 0) || 0;\n    }\n\n    const cancelled = !(await this.tileset._requestScheduler.scheduleRequest(this, updatePriority));\n\n    if (cancelled) {\n      this._contentState = TILE3D_CONTENT_STATE.UNLOADED;\n      return false;\n    }\n\n    try {\n      const contentUri = this.uri;\n\n      let response;\n      try {\n        this.tileset._requestScheduler.startRequest(this);\n        response = await fetchFile(contentUri, this.tileset.options.fetchOptions);\n      } finally {\n        this.tileset._requestScheduler.endRequest(this);\n      }\n\n      // The content can be a binary tile ot a JSON tileset\n      this._content = await parse(response, [Tile3DLoader, Tileset3DLoader]);\n      // if (Tile3D.isTile(content)) {\n      //   new Tileset3D(content, contentUri);\n\n      if (contentUri.indexOf('.json') !== -1) {\n        // Add tile headers for the nested tilset's subtree\n        // Async update of the tree should be fine since there would never be edits to the same node\n        // TODO - we need to capture the child tileset's URL\n        this._tileset._initializeTileHeaders(this._content, this, path.dirname(this.uri));\n      }\n\n      this._contentState = TILE3D_CONTENT_STATE.READY;\n      this._contentLoaded();\n      return true;\n    } catch (error) {\n      // Tile is unloaded before the content finishes loading\n      this._contentState = TILE3D_CONTENT_STATE.FAILED;\n      throw error;\n    }\n  }\n\n  // Unloads the tile's content.\n  unloadContent() {\n    if (!this.hasRenderContent) {\n      return false;\n    }\n    if (this._content && this._content.destroy) {\n      this._content.destroy();\n    }\n    this._content = null;\n    this._contentState = TILE3D_CONTENT_STATE.UNLOADED;\n    return true;\n  }\n\n  // _getOrthograhicScreenSpaceError() {\n  // if (frustum instanceof OrthographicFrustum) {\n  //   const pixelSize = Math.max(frustum.top - frustum.bottom, frustum.right - frustum.left) / Math.max(width, height);\n  //   error = geometricError / pixelSize;\n  // }\n\n  // Update the tile's visibility.\n  updateVisibility(frameState) {\n    const tileset = this._tileset;\n    if (this._updatedVisibilityFrame === tileset._updatedVisibilityFrame) {\n      // Return early if visibility has already been checked during the traversal.\n      // The visibility may have already been checked if the cullWithChildrenBounds optimization is used.\n      return;\n    }\n\n    const parent = this.parent;\n    const parentTransform = parent ? parent.computedTransform : this._tileset.modelMatrix;\n    const parentVisibilityPlaneMask = parent\n      ? parent._visibilityPlaneMask\n      : CullingVolume.MASK_INDETERMINATE;\n    this._updateTransform(parentTransform);\n    this._distanceToCamera = this.distanceToTile(frameState);\n    // this._centerZDepth = this.cameraSpaceZDepth(frameState);\n    this._screenSpaceError = this.getScreenSpaceError(frameState, false);\n    this._visibilityPlaneMask = this.visibility(frameState, parentVisibilityPlaneMask); // Use parent's plane mask to speed up visibility test\n    this._visible = this._visibilityPlaneMask !== CullingVolume.MASK_OUTSIDE;\n    this._inRequestVolume = this.insideViewerRequestVolume(frameState);\n\n    this._updatedVisibilityFrame = tileset._updatedVisibilityFrame;\n  }\n\n  // Update whether the tile has expired.\n  updateExpiration() {\n    if (defined(this.expireDate) && this.contentReady && !this.hasEmptyContent) {\n      const now = Date.now(scratchDate);\n      if (Date.lessThan(this.expireDate, now)) {\n        this._contentState = TILE3D_CONTENT_STATE.EXPIRED;\n        this._expiredContent = this._content;\n      }\n    }\n  }\n\n  // Determines whether the tile's bounding volume intersects the culling volume.\n  // @param {FrameState} frameState The frame state.\n  // @param {Number} parentVisibilityPlaneMask The parent's plane mask to speed up the visibility check.\n  // @returns {Number} A plane mask as described above in {@link CullingVolume#computeVisibilityWithPlaneMask}.\n  visibility(frameState, parentVisibilityPlaneMask) {\n    const {cullingVolume} = frameState;\n    const {boundingVolume, tileset} = this;\n\n    const {clippingPlanes, clippingPlanesOriginMatrix} = tileset;\n    if (clippingPlanes && clippingPlanes.enabled) {\n      const intersection = clippingPlanes.computeIntersectionWithBoundingVolume(\n        boundingVolume,\n        clippingPlanesOriginMatrix\n      );\n      this._isClipped = intersection !== Intersect.INSIDE;\n      if (intersection === Intersect.OUTSIDE) {\n        return CullingVolume.MASK_OUTSIDE;\n      }\n    }\n\n    // return cullingVolume.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);\n    return computeVisibilityWithPlaneMask(cullingVolume, boundingVolume, parentVisibilityPlaneMask);\n  }\n\n  // Assuming the tile's bounding volume intersects the culling volume, determines\n  // whether the tile's content's bounding volume intersects the culling volume.\n  // @param {FrameState} frameState The frame state.\n  // @returns {Intersect} The result of the intersection: the tile's content is completely outside, completely inside, or intersecting the culling volume.\n  contentVisibility(frameState) {\n    return true;\n    /*\n    // Assumes the tile's bounding volume intersects the culling volume already, so\n    // just return Intersect.INSIDE if there is no content bounding volume.\n    if (!defined(this._contentBoundingVolume)) {\n      return Intersect.INSIDE;\n    }\n\n    if (this._visibilityPlaneMask === CullingVolume.MASK_INSIDE) {\n      // The tile's bounding volume is completely inside the culling volume so\n      // the content bounding volume must also be inside.\n      return Intersect.INSIDE;\n    }\n\n    // PERFORMANCE_IDEA: is it possible to burn less CPU on this test since we know the\n    // tile's (not the content's) bounding volume intersects the culling volume?\n    const cullingVolume = frameState.cullingVolume;\n    const boundingVolume = tile._contentBoundingVolume;\n\n    const tileset = this._tileset;\n    const clippingPlanes = tileset.clippingPlanes;\n    if (defined(clippingPlanes) && clippingPlanes.enabled) {\n      const intersection = clippingPlanes.computeIntersectionWithBoundingVolume(\n        boundingVolume,\n        tileset.clippingPlanesOriginMatrix\n      );\n      this._isClipped = intersection !== Intersect.INSIDE;\n      if (intersection === Intersect.OUTSIDE) {\n        return Intersect.OUTSIDE;\n      }\n    }\n\n    return cullingVolume.computeVisibility(boundingVolume);\n    */\n  }\n\n  // Computes the (potentially approximate) distance from the closest point of the tile's bounding volume to the camera.\n  // @param {FrameState} frameState The frame state.\n  // @returns {Number} The distance, in meters, or zero if the camera is inside the bounding volume.\n  distanceToTile(frameState) {\n    const boundingVolume = this._boundingVolume;\n    return Math.sqrt(boundingVolume.distanceSquaredTo(frameState.camera.position));\n  }\n\n  // Computes the tile's camera-space z-depth.\n  // @param {FrameState} frameState The frame state.\n  // @returns {Number} The distance, in meters.\n  cameraSpaceZDepth({camera}) {\n    const boundingVolume = this.boundingVolume; // Gets the underlying OrientedBoundingBox or BoundingSphere\n    scratchToTileCenter.subVectors(boundingVolume.center, camera.position);\n    return camera.direction.dot(scratchToTileCenter);\n  }\n\n  /**\n   * Checks if the camera is inside the viewer request volume.\n   * @param {FrameState} frameState The frame state.\n   * @returns {Boolean} Whether the camera is inside the volume.\n   */\n  insideViewerRequestVolume(frameState) {\n    const viewerRequestVolume = this._viewerRequestVolume;\n    return !viewerRequestVolume || viewerRequestVolume.distanceToCamera(frameState) === 0.0;\n  }\n\n  // PRIVATE\n\n  _initializeCache(header) {\n    // The node in the tileset's LRU cache, used to determine when to unload a tile's content.\n    this.cacheNode = undefined;\n\n    let expire = header.expire;\n    let expireDuration;\n    let expireDate;\n    if (expire) {\n      expireDuration = expire.duration;\n      if (expire.date) {\n        expireDate = Date.fromIso8601(expire.date);\n      }\n    }\n\n    // The time in seconds after the tile's content is ready when the content expires and new content is requested.\n    // @type {Number}\n    this.expireDuration = expireDuration;\n\n    // The date when the content expires and new content is requested.\n    // @type {Date}\n    this.expireDate = expireDate;\n  }\n\n  _initializeTransforms(tileHeader) {\n    // The local transform of this tile.\n    this.transform = tileHeader.transform ? new Matrix4(tileHeader.transform) : new Matrix4();\n\n    const parent = this.parent;\n    const tileset = this._tileset;\n\n    const parentTransform =\n      parent && parent.computedTransform\n        ? parent.computedTransform.clone()\n        : tileset.modelMatrix.clone();\n    this.computedTransform = new Matrix4(parentTransform).multiplyRight(this.transform);\n\n    const parentInitialTransform =\n      parent && parent._initialTransform ? parent._initialTransform.clone() : new Matrix4();\n    this._initialTransform = new Matrix4(parentInitialTransform).multiplyRight(this.transform);\n  }\n\n  _initializeBoundingVolumes(tileHeader) {\n    this._boundingVolume = createBoundingVolume(tileHeader.boundingVolume, this.computedTransform);\n\n    this._contentBoundingVolume = null;\n    this._viewerRequestVolume = null;\n\n    // Non-leaf tiles may have a content bounding-volume, which is a tight-fit bounding volume\n    // around only the features in the tile. This box is useful for culling for rendering,\n    // but not for culling for traversing the tree since it does not guarantee spatial coherence, i.e.,\n    // since it only bounds features in the tile, not the entire tile, children may be\n    // outside of this box.\n    if (tileHeader.content && tileHeader.content.boundingVolume) {\n      this._contentBoundingVolume = createBoundingVolume(\n        tileHeader.boundingVolume,\n        this.computedTransform\n      );\n    }\n\n    if (tileHeader.viewerRequestVolume) {\n      this._viewerRequestVolume = createBoundingVolume(\n        tileHeader.viewerRequestVolume,\n        this.computedTransform\n      );\n    }\n  }\n\n  _initializeContent(tileHeader) {\n    // Empty tile by default\n    this._content = {_tileset: this._tileset, _tile: this};\n    this.hasEmptyContent = true;\n    this.contentState = TILE3D_CONTENT_STATE.UNLOADED;\n    this._expiredContent = undefined;\n    this._serverKey = null;\n\n    // When `true`, the tile's content points to an external tileset.\n    // This is `false` until the tile's content is loaded.\n    this.hasTilesetContent = false;\n\n    // If a content tileHeader\n    if (tileHeader.content) {\n      this.contentUri = tileHeader.content.uri || tileHeader.content.url;\n      if ('url' in tileHeader) {\n        console.warn('Tileset 3D: \"content.url\" property deprecated. Use \"content.uri\" instead.');\n        this.contentUri = tileHeader.url;\n      }\n      this._content = null;\n      this.hasEmptyContent = false;\n      this.contentState = TILE3D_CONTENT_STATE.UNLOADED;\n      this.fullUri = this._basePath + '/' + this.contentUri;\n      // this.serverKey = RequestScheduler.getServerKey(contentResource.getUrlComponent());\n    }\n  }\n\n  // TODO - remove anything not related to basic visibility detection\n  _initializeRenderingState() {\n    // Members this are updated every frame for tree traversal and rendering optimizations:\n    this._distanceToCamera = 0;\n    this._centerZDepth = 0;\n    this._screenSpaceError = 0;\n    this._visibilityPlaneMask = CullingVolume.MASK_INDETERMINATE;\n    this._visible = false;\n    this._inRequestVolume = false;\n\n    this._finalResolution = true;\n    this._depth = 0;\n    this._stackLength = 0;\n    this._selectionDepth = 0;\n\n    this._updatedVisibilityFrame = 0;\n    this._touchedFrame = 0;\n    this._visitedFrame = 0;\n    this._selectedFrame = 0;\n    this._requestedFrame = 0;\n    this._ancestorWithContent = undefined;\n    this._ancestorWithContentAvailable = undefined;\n    this._refines = false;\n    this._shouldSelect = false;\n    this._priority = 0.0;\n  }\n\n  _getRefine(refine) {\n    switch (refine) {\n      case 'REPLACE':\n      case 'replace':\n        return TILE3D_REFINEMENT.REPLACE;\n      case 'ADD':\n      case 'add':\n        return TILE3D_REFINEMENT.ADD;\n      default:\n        // Inherit from parent tile if omitted.\n        return this.parent ? this.parent.refine : TILE3D_REFINEMENT.REPLACE;\n    }\n  }\n\n  _isTileset(content) {\n    return Boolean(content.asset);\n  }\n\n  _contentLoaded() {\n    // Vector and Geometry tile rendering do not support the skip LOD optimization.\n    switch (this._content && this._content.type) {\n      case 'vctr':\n      case 'geom':\n        tileset.traverser.disableSkipLevelOfDetail = true;\n      default:\n    }\n\n    // The content may be tileset json\n    if (this._isTileset(this._content)) {\n      this.hasTilesetContent = true;\n    }\n  }\n\n  // Update the tile's transform. The transform is applied to the tile's bounding volumes.\n  _updateTransform(parentTransform = new Matrix4()) {\n    const computedTransform = parentTransform.clone().multiplyRight(this.transform);\n    const didTransformChange = !computedTransform.equals(this.computedTransform);\n\n    if (!didTransformChange) {\n      return;\n    }\n\n    this.computedTransform = computedTransform;\n\n    // Matrix4.clone(computedTransform, this.computedTransform);\n\n    // Update the bounding volumes\n    const header = this._header;\n\n    const content = this._header.content;\n    this._boundingVolume = createBoundingVolume(\n      header.boundingVolume,\n      this.computedTransform,\n      this._boundingVolume\n    );\n    if (this._contentBoundingVolume) {\n      this._contentBoundingVolume = createBoundingVolume(\n        content.boundingVolume,\n        this.computedTransform,\n        this._contentBoundingVolume\n      );\n    }\n    if (this._viewerRequestVolume) {\n      this._viewerRequestVolume = createBoundingVolume(\n        header.viewerRequestVolume,\n        this.computedTransform,\n        this._viewerRequestVolume\n      );\n    }\n  }\n}\n\nfunction updateContent(tile, tileset, frameState) {\n  const content = tile._content;\n  const expiredContent = tile._expiredContent;\n\n  if (expiredContent) {\n    if (!tile.contentReady) {\n      // Render the expired content while the content loads\n      expiredContent.update(tileset, frameState);\n      return;\n    }\n\n    // New content is ready, destroy expired content\n    tile._expiredContent.destroy();\n    tile._expiredContent = undefined;\n  }\n\n  content.update(tileset, frameState);\n}\n\nfunction updateExpireDate(tile) {\n  if (defined(tile.expireDuration)) {\n    const expireDurationDate = Date.now(scratchDate);\n    Date.addSeconds(expireDurationDate, tile.expireDuration, expireDurationDate);\n\n    if (defined(tile.expireDate)) {\n      if (Date.lessThan(tile.expireDate, expireDurationDate)) {\n        Date.clone(expireDurationDate, tile.expireDate);\n      }\n    } else {\n      tile.expireDate = Date.clone(expireDurationDate);\n    }\n  }\n}\n\nfunction createPriorityFunction(tile) {\n  return function() {\n    return tile._priority;\n  };\n}\n"],"file":"tile-3d-header.js"}