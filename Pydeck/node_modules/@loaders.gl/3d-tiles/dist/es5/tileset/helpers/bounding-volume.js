"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createBoundingVolume = createBoundingVolume;

var _readOnlyError2 = _interopRequireDefault(require("@babel/runtime/helpers/readOnlyError"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _math = require("math.gl");

var _culling = require("@math.gl/culling");

var _geospatial = require("@math.gl/geospatial");

var _assert = _interopRequireDefault(require("../../utils/assert"));

var defined = function defined(x) {
  return x !== undefined;
};

var scratchMatrix = new _math.Matrix3();
var scratchScale = new _math.Vector3();
var scratchCenter = new _math.Vector3();
var scratchTransform = new _math.Matrix4();

function createBoundingVolume(boundingVolumeHeader, transform, result) {
  (0, _assert["default"])(boundingVolumeHeader, '3D Tile: boundingVolume must be defined');

  if (boundingVolumeHeader.box) {
    return createBox(boundingVolumeHeader.box, transform, result);
  }

  if (boundingVolumeHeader.region) {
    var _boundingVolumeHeader = (0, _slicedToArray2["default"])(boundingVolumeHeader.region, 6),
        west = _boundingVolumeHeader[0],
        south = _boundingVolumeHeader[1],
        east = _boundingVolumeHeader[2],
        north = _boundingVolumeHeader[3],
        minHeight = _boundingVolumeHeader[4],
        maxHeight = _boundingVolumeHeader[5];

    var center = new _math.Vector3((0, _math.degrees)((west + east) / 2), (0, _math.degrees)((north + south) / 2), (minHeight + maxHeight) / 2);

    var centerInCartesian = _geospatial.Ellipsoid.WGS84.cartographicToCartesian(center, scratchCenter);

    var northWest = _geospatial.Ellipsoid.WGS84.cartographicToCartesian([north, west, 0]);

    var northEast = _geospatial.Ellipsoid.WGS84.cartographicToCartesian([north, east, 0]);

    var southWest = _geospatial.Ellipsoid.WGS84.cartographicToCartesian([south, west, 0]);

    var radius = (Math.abs(northEast[0] - northWest[0]) + Math.abs(southWest[1] - northWest[1])) * 8;
    return createSphere([centerInCartesian[0], centerInCartesian[1], centerInCartesian[2], radius], new _math.Matrix4());
  }

  if (boundingVolumeHeader.sphere) {
    return createSphere(boundingVolumeHeader.sphere, transform, result);
  }

  throw new Error('3D Tile: boundingVolume must contain a sphere, region, or box');
}

function createBox(box, transform, result) {
  var center = new _math.Vector3(box[0], box[1], box[2]);
  var halfAxes = new _math.Matrix3(box.slice(3, box.length));
  transform.transform(center, center);
  halfAxes = new _math.Matrix3(transform[0], transform[1], transform[2], transform[4], transform[5], transform[6], transform[8], transform[9], transform[10]).multiplyRight(halfAxes);

  if (defined(result)) {
    result.center = center;
    result.halfAxes = halfAxes;
    return result;
  }

  return new _culling.OrientedBoundingBox(center, halfAxes);
}

function createBoxFromTransformedRegion(region, transform, initialTransform, result) {
  var rectangle = Rectangle.unpack(region, 0, scratchRectangle);
  var minimumHeight = region[4];
  var maximumHeight = region[5];

  var orientedBoundingBox = _culling.OrientedBoundingBox.fromRectangle(rectangle, minimumHeight, maximumHeight, _geospatial.Ellipsoid.WGS84, scratchOrientedBoundingBox);

  var center = orientedBoundingBox.center;
  var halfAxes = orientedBoundingBox.halfAxes;
  transform = _math.Matrix4.multiplyTransformation(transform, _math.Matrix4.inverseTransformation(initialTransform, scratchTransform), scratchTransform);
  center = ((0, _readOnlyError2["default"])("center"), _math.Matrix4.multiplyByPoint(transform, center, center));

  var rotationScale = _math.Matrix4.getRotation(transform, scratchMatrix);

  halfAxes = ((0, _readOnlyError2["default"])("halfAxes"), _math.Matrix3.multiply(rotationScale, halfAxes, halfAxes));

  if (defined(result) && result instanceof TileOrientedBoundingBox) {
    result.update(center, halfAxes);
    return result;
  }

  return new TileOrientedBoundingBox(center, halfAxes);
}

function createRegion(region, transform, initialTransform, result) {
  if (!_math.Matrix4.equalsEpsilon(transform, initialTransform, CesiumMath.EPSILON8)) {
    return createBoxFromTransformedRegion(region, transform, initialTransform, result);
  }

  if (defined(result)) {
    return result;
  }

  var rectangleRegion = Rectangle.unpack(region, 0, scratchRectangle);
  return new TileBoundingRegion({
    rectangle: rectangleRegion,
    minimumHeight: region[4],
    maximumHeight: region[5]
  });
}

function createSphere(sphere, transform, result) {
  var center = new _math.Vector3(sphere[0], sphere[1], sphere[2]);
  transform.transform(center, center);
  var scale = transform.getScale(scratchScale);
  var uniformScale = Math.max(Math.max(scale[0], scale[1]), scale[2]);
  var radius = sphere[3] * uniformScale;

  if (defined(result)) {
    result.center = center;
    result.radius = radius;
    return result;
  }

  return new _culling.BoundingSphere(center, radius);
}
//# sourceMappingURL=bounding-volume.js.map