import { TILE3D_OPTIMIZATION_HINT } from '../constants';
const scratchAxis = new Cartesian3();
export function checkChildrenWithinParent(tile) {
  assert(tile);
  const children = tile.children;
  const length = children.length;
  const boundingVolume = tile.boundingVolume;

  if (boundingVolume instanceof TileOrientedBoundingBox || boundingVolume instanceof TileBoundingRegion) {
    const orientedBoundingBox = boundingVolume._orientedBoundingBox;
    tile._optimChildrenWithinParent = TILE3D_OPTIMIZATION_HINT.USE_OPTIMIZATION;

    for (const i = 0; i < length; ++i) {
      const child = children[i];
      const childBoundingVolume = child.boundingVolume;

      if (!(childBoundingVolume instanceof TileOrientedBoundingBox || childBoundingVolume instanceof TileBoundingRegion)) {
        tile._optimChildrenWithinParent = TILE3D_OPTIMIZATION_HINT.SKIP_OPTIMIZATION;
        break;
      }

      const childOrientedBoundingBox = childBoundingVolume._orientedBoundingBox;
      const axis = Cartesian3.subtract(childOrientedBoundingBox.center, orientedBoundingBox.center, scratchAxis);
      const axisLength = Cartesian3.magnitude(axis);
      Cartesian3.divideByScalar(axis, axisLength, axis);
      const proj1 = Math.abs(orientedBoundingBox.halfAxes[0] * axis.x) + Math.abs(orientedBoundingBox.halfAxes[1] * axis.y) + Math.abs(orientedBoundingBox.halfAxes[2] * axis.z) + Math.abs(orientedBoundingBox.halfAxes[3] * axis.x) + Math.abs(orientedBoundingBox.halfAxes[4] * axis.y) + Math.abs(orientedBoundingBox.halfAxes[5] * axis.z) + Math.abs(orientedBoundingBox.halfAxes[6] * axis.x) + Math.abs(orientedBoundingBox.halfAxes[7] * axis.y) + Math.abs(orientedBoundingBox.halfAxes[8] * axis.z);
      const proj2 = Math.abs(childOrientedBoundingBox.halfAxes[0] * axis.x) + Math.abs(childOrientedBoundingBox.halfAxes[1] * axis.y) + Math.abs(childOrientedBoundingBox.halfAxes[2] * axis.z) + Math.abs(childOrientedBoundingBox.halfAxes[3] * axis.x) + Math.abs(childOrientedBoundingBox.halfAxes[4] * axis.y) + Math.abs(childOrientedBoundingBox.halfAxes[5] * axis.z) + Math.abs(childOrientedBoundingBox.halfAxes[6] * axis.x) + Math.abs(childOrientedBoundingBox.halfAxes[7] * axis.y) + Math.abs(childOrientedBoundingBox.halfAxes[8] * axis.z);

      if (proj1 <= proj2 + axisLength) {
        tile._optimChildrenWithinParent = TILE3D_OPTIMIZATION_HINT.SKIP_OPTIMIZATION;
        break;
      }
    }
  }

  return tile._optimChildrenWithinParent === TILE3D_OPTIMIZATION_HINT.USE_OPTIMIZATION;
}
//# sourceMappingURL=tileset-3d-optimizations.js.map