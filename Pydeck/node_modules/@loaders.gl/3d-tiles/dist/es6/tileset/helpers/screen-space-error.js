import { Matrix4, Vector3, clamp } from 'math.gl';
const scratchPositionNormal = new Vector3();
const scratchCartographic = new Cartographic();
const scratchMatrix = new Matrix4();
const scratchCenter = new Vector3();
const scratchPosition = new Vector3();
const scratchDirection = new Vector3();
export function calculateDynamicScreenSpaceError(root, {
  camera,
  mapProjection
}, options = {}) {
  const {
    dynamicScreenSpaceErrorHeightFalloff = 0.25,
    dynamicScreenSpaceErrorDensity = 0.00278
  } = options;
  let up;
  let direction;
  let height;
  let minimumHeight;
  let maximumHeight;
  const tileBoundingVolume = root.contentBoundingVolume;

  if (tileBoundingVolume instanceof TileBoundingRegion) {
    up = Cartesian3.normalize(camera.positionWC, scratchPositionNormal);
    direction = camera.directionWC;
    height = camera.positionCartographic.height;
    minimumHeight = tileBoundingVolume.minimumHeight;
    maximumHeight = tileBoundingVolume.maximumHeight;
  } else {
    const transformLocal = Matrix4.inverseTransformation(root.computedTransform, scratchMatrix);
    const ellipsoid = mapProjection.ellipsoid;
    const boundingVolume = tileBoundingVolume.boundingVolume;
    const centerLocal = Matrix4.multiplyByPoint(transformLocal, boundingVolume.center, scratchCenter);

    if (Cartesian3.magnitude(centerLocal) > ellipsoid.minimumRadius) {
      const centerCartographic = Cartographic.fromCartesian(centerLocal, ellipsoid, scratchCartographic);
      up = Cartesian3.normalize(camera.positionWC, scratchPositionNormal);
      direction = camera.directionWC;
      height = camera.positionCartographic.height;
      minimumHeight = 0.0;
      maximumHeight = centerCartographic.height * 2.0;
    } else {
      const positionLocal = Matrix4.multiplyByPoint(transformLocal, camera.positionWC, scratchPosition);
      up = Cartesian3.UNIT_Z;
      direction = Matrix4.multiplyByPointAsVector(transformLocal, camera.directionWC, scratchDirection);
      direction = Cartesian3.normalize(direction, direction);
      height = positionLocal.z;

      if (tileBoundingVolume instanceof TileOrientedBoundingBox) {
        const boxHeight = root._header.boundingVolume.box[11];
        minimumHeight = centerLocal.z - boxHeight;
        maximumHeight = centerLocal.z + boxHeight;
      } else if (tileBoundingVolume instanceof TileBoundingSphere) {
        const radius = boundingVolume.radius;
        minimumHeight = centerLocal.z - radius;
        maximumHeight = centerLocal.z + radius;
      }
    }
  }

  const heightFalloff = dynamicScreenSpaceErrorHeightFalloff;
  const heightClose = minimumHeight + (maximumHeight - minimumHeight) * heightFalloff;
  const heightFar = maximumHeight;
  const t = clamp((height - heightClose) / (heightFar - heightClose), 0.0, 1.0);
  const dot = Math.abs(Cartesian3.dot(direction, up));
  let horizonFactor = 1.0 - dot;
  horizonFactor = horizonFactor * (1.0 - t);
  return dynamicScreenSpaceErrorDensity * horizonFactor;
}
//# sourceMappingURL=screen-space-error.js.map