import { TILE3D_REFINEMENT } from '../constants';
import ManagedArray from '../utils/managed-array';
import assert from '../utils/assert';
export default class Tileset3DTraverser {
  constructor() {
    this.traversal = {
      stack: new ManagedArray(),
      stackMaximumLength: 0
    };
    this.emptyTraversal = {
      stack: new ManagedArray(),
      stackMaximumLength: 0
    };
    this.result = {
      _requestedTiles: [],
      selectedTiles: [],
      _emptyTiles: [],
      _hasMixedContent: false
    };
    this._disableSkipLevelOfDetail = false;
  }

  traverse(root, frameState, options) {
    this.root = root;
    this.options = options;
    this.result._requestedTiles.length = 0;
    this.result.selectedTiles.length = 0;
    this.result._emptyTiles.length = 0;
    this.result._hasMixedContent = false;
    this.updateTile(root, frameState);

    if (!root.isVisibleAndInRequestVolume) {
      return false;
    }

    if (root.getScreenSpaceError(frameState, true) <= options.maximumScreenSpaceError) {
      return false;
    }

    const baseScreenSpaceError = options.maximumScreenSpaceError;
    this.executeTraversal(root, baseScreenSpaceError, frameState);
    this.traversal.stack.trim(this.traversal.stackMaximumLength);
    this.emptyTraversal.stack.trim(this.emptyTraversal.stackMaximumLength);
    return true;
  }

  selectTile(tile, frameState) {
    tile._selectedFrame = frameState.frameNumber;
    this.result.selectedTiles.push(tile);
  }

  selectDesiredTile(tile, frameState) {
    if (!this.options.skipLevelOfDetail) {
      if (tile.contentAvailable) {
        this.selectTile(tile, frameState);
      }

      return;
    }

    const loadedTile = tile.contentAvailable ? tile : tile._ancestorWithContentAvailable;

    if (loadedTile) {
      loadedTile._shouldSelect = true;
    } else {
      this.selectDescendants(tile, frameState);
    }
  }

  visitTile(tileset, tile, frameState) {
    ++tileset._statistics.visited;
    tile._visitedFrame = frameState.frameNumber;
  }

  touchTile(tile, frameState) {
    tile.tileset._cache.touch(tile);

    tile._touchedFrame = frameState.frameNumber;
  }

  getPriority(tile, options) {
    switch (tile.refine) {
      case TILE3D_REFINEMENT.ADD:
        return tile._distanceToCamera;

      case TILE3D_REFINEMENT.REPLACE:
        const {
          parent
        } = tile;
        const useParentScreenSpaceError = parent && (!options.skipLevelOfDetail || tile._screenSpaceError === 0.0 || parent.hasTilesetContent);
        const screenSpaceError = useParentScreenSpaceError ? parent._screenSpaceError : tile._screenSpaceError;
        const rootScreenSpaceError = this.root._screenSpaceError;
        return rootScreenSpaceError - screenSpaceError;

      default:
        return assert(false);
    }
  }

  loadTile(tile, frameState) {
    if (tile.hasUnloadedContent || tile.contentExpired) {
      tile._requestedFrame = frameState.frameNumber;
      tile._priority = this.getPriority(tile, this.options);

      this.result._requestedTiles.push(tile);
    }
  }

  updateTileVisibility(tile, frameState) {
    tile.updateVisibility(frameState);
  }

  updateTile(tile, frameState) {
    this.updateTileVisibility(tile, frameState);
    tile.updateExpiration();
  }

  updateAndPushChildren(tile, stack, frameState) {
    const {
      children
    } = tile;

    for (const child of children) {
      this.updateTile(child, frameState);
      stack.push(child);
    }

    return true;
  }

  canTraverse(tile, options) {
    if (tile.children.length === 0 || options.depthLimit < tile.depth) {
      return false;
    }

    if (tile.hasTilesetContent) {
      return !tile.contentExpired;
    }

    return tile._screenSpaceError > options.maximumScreenSpaceError;
  }

  executeTraversal(root, baseScreenSpaceError, frameState) {
    const {
      traversal
    } = this;
    const {
      stack
    } = traversal;
    stack.push(root);

    while (stack.length > 0) {
      traversal.stackMaximumLength = Math.max(traversal.stackMaximumLength, stack.length);
      const tile = stack.pop();
      const add = tile.refine === TILE3D_REFINEMENT.ADD;
      const replace = tile.refine === TILE3D_REFINEMENT.REPLACE;
      const parent = tile.parent;
      const parentRefines = !parent || parent._refines;
      let refines = false;

      if (this.canTraverse(tile, this.options)) {
        refines = this.updateAndPushChildren(tile, stack, frameState) && parentRefines;
      }

      const stoppedRefining = !refines && parentRefines;

      if (!tile.hasRenderContent) {
        this.result._emptyTiles.push(tile);

        this.loadTile(tile, frameState);

        if (stoppedRefining) {
          this.selectDesiredTile(tile, frameState);
        }
      } else if (add) {
        this.loadTile(tile, frameState);
        this.selectDesiredTile(tile, frameState);
      } else if (replace) {
        this.loadTile(tile, frameState);

        if (stoppedRefining) {
          this.selectDesiredTile(tile, frameState);
        }
      }

      this.touchTile(tile, frameState);
      tile._refines = refines;
    }
  }

}
//# sourceMappingURL=tileset-3d-traverser.js.map