{"version":3,"sources":["../../../src/tileset/tileset-3d-traverser.js"],"names":["TILE3D_REFINEMENT","ManagedArray","assert","Tileset3DTraverser","constructor","traversal","stack","stackMaximumLength","emptyTraversal","result","_requestedTiles","selectedTiles","_emptyTiles","_hasMixedContent","_disableSkipLevelOfDetail","traverse","root","frameState","options","length","updateTile","isVisibleAndInRequestVolume","getScreenSpaceError","maximumScreenSpaceError","baseScreenSpaceError","executeTraversal","trim","selectTile","tile","_selectedFrame","frameNumber","push","selectDesiredTile","skipLevelOfDetail","contentAvailable","loadedTile","_ancestorWithContentAvailable","_shouldSelect","selectDescendants","visitTile","tileset","_statistics","visited","_visitedFrame","touchTile","_cache","touch","_touchedFrame","getPriority","refine","ADD","_distanceToCamera","REPLACE","parent","useParentScreenSpaceError","_screenSpaceError","hasTilesetContent","screenSpaceError","rootScreenSpaceError","loadTile","hasUnloadedContent","contentExpired","_requestedFrame","_priority","updateTileVisibility","updateVisibility","updateExpiration","updateAndPushChildren","children","child","canTraverse","depthLimit","depth","Math","max","pop","add","replace","parentRefines","_refines","refines","stoppedRefining","hasRenderContent"],"mappings":"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","sourcesContent":["// import {TILE3D_REFINEMENT, TILE3D_OPTIMIZATION_HINT} from '../constants';\nimport {TILE3D_REFINEMENT} from '../constants';\nimport ManagedArray from '../utils/managed-array';\nimport assert from '../utils/assert';\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nexport default class Tileset3DTraverser {\n  constructor() {\n    this.traversal = {\n      stack: new ManagedArray(),\n      stackMaximumLength: 0\n    };\n\n    this.emptyTraversal = {\n      stack: new ManagedArray(),\n      stackMaximumLength: 0\n    };\n\n    this.result = {\n      _requestedTiles: [],\n      selectedTiles: [],\n      _emptyTiles: [],\n      _hasMixedContent: false\n    };\n\n    // Optimization option. Determines if level of detail skipping should be applied during the traversal.\n    this._disableSkipLevelOfDetail = false;\n  }\n\n  traverse(root, frameState, options) {\n    this.root = root; // for root screen space error\n    this.options = options;\n\n    this.result._requestedTiles.length = 0;\n    this.result.selectedTiles.length = 0;\n    this.result._emptyTiles.length = 0;\n    // this.result._selectedTilesToStyle.length = 0;\n    this.result._hasMixedContent = false;\n\n    this.updateTile(root, frameState);\n\n    // The root tile is not visible\n    if (!root.isVisibleAndInRequestVolume) {\n      return false;\n    }\n\n    // The this doesn't meet the SSE requirement, therefore the tree does not need to be rendered\n    // The alwaysLoadRoot is better solved by moving the camera to the newly selected asset.\n    if (root.getScreenSpaceError(frameState, true) <= options.maximumScreenSpaceError) {\n      return false;\n    }\n\n    const baseScreenSpaceError = options.maximumScreenSpaceError;\n    this.executeTraversal(root, baseScreenSpaceError, frameState);\n\n    this.traversal.stack.trim(this.traversal.stackMaximumLength);\n    this.emptyTraversal.stack.trim(this.emptyTraversal.stackMaximumLength);\n\n    return true;\n  }\n\n  selectTile(tile, frameState) {\n    tile._selectedFrame = frameState.frameNumber;\n    this.result.selectedTiles.push(tile);\n\n    // if (tile.contentVisibility(frameState) !== Intersect.OUTSIDE) {\n    //   if (tile.content.featurePropertiesDirty) {\n    //     // A feature's property in this tile changed, the tile needs to be re-styled.\n    //     tile.content.featurePropertiesDirty = false;\n    //     tile.lastStyleTime = 0; // Force applying the style to this tile\n    //     tileset._selectedTilesToStyle.push(tile);\n    //   } else if (tile._selectedFrame < frameState.frameNumber - 1) {\n    //     // Tile is newly selected; it is selected this frame, but was not selected last frame.\n    //     tileset._selectedTilesToStyle.push(tile);\n    //   }\n    //   tile._selectedFrame = frameState.frameNumber;\n    //   tileset.selectedTiles.push(tile);\n    // }\n  }\n\n  selectDesiredTile(tile, frameState) {\n    if (!this.options.skipLevelOfDetail) {\n      if (tile.contentAvailable) {\n        // The tile can be selected right away and does not require traverseAndSelect\n        this.selectTile(tile, frameState);\n      }\n      return;\n    }\n\n    // If this tile is not loaded attempt to select its ancestor instead\n    const loadedTile = tile.contentAvailable ? tile : tile._ancestorWithContentAvailable;\n    if (loadedTile) {\n      // Tiles will actually be selected in traverseAndSelect\n      loadedTile._shouldSelect = true;\n    } else {\n      // If no ancestors are ready traverse down and select tiles to minimize empty regions.\n      // This happens often for immediatelyLoadDesiredLevelOfDetail where parent tiles\n      // are not necessarily loaded before zooming out.\n      this.selectDescendants(tile, frameState);\n    }\n  }\n\n  visitTile(tileset, tile, frameState) {\n    ++tileset._statistics.visited;\n    tile._visitedFrame = frameState.frameNumber;\n  }\n\n  touchTile(tile, frameState) {\n    // TODO need a better frameNumber since it can be the same between updates\n    // Until then this needs to be commented out\n    // if (tile._touchedFrame === frameState.frameNumber) {\n    //   // Prevents another pass from touching the frame again\n    //   return;\n    // }\n    // TODO: add function to tile that te\n    tile.tileset._cache.touch(tile);\n    tile._touchedFrame = frameState.frameNumber;\n  }\n\n  // If skipLevelOfDetail is off try to load child tiles as soon as possible so that their parent can refine sooner.\n  // Additive tiles are prioritized by distance because it subjectively looks better.\n  // Replacement tiles are prioritized by screen space error.\n  // A tileset that has both additive and replacement tiles may not prioritize tiles as effectively since SSE and distance\n  // are different types of values. Maybe all priorities need to be normalized to 0-1 range.\n  getPriority(tile, options) {\n    switch (tile.refine) {\n      case TILE3D_REFINEMENT.ADD:\n        return tile._distanceToCamera;\n\n      case TILE3D_REFINEMENT.REPLACE:\n        const {parent} = tile;\n        const useParentScreenSpaceError =\n          parent &&\n          (!options.skipLevelOfDetail ||\n            tile._screenSpaceError === 0.0 ||\n            parent.hasTilesetContent);\n        const screenSpaceError = useParentScreenSpaceError\n          ? parent._screenSpaceError\n          : tile._screenSpaceError;\n        const rootScreenSpaceError = this.root._screenSpaceError;\n        return rootScreenSpaceError - screenSpaceError; // Map higher SSE to lower values (e.g. root tile is highest priority)\n\n      default:\n        return assert(false);\n    }\n  }\n\n  loadTile(tile, frameState) {\n    if (tile.hasUnloadedContent || tile.contentExpired) {\n      tile._requestedFrame = frameState.frameNumber;\n      tile._priority = this.getPriority(tile, this.options);\n      this.result._requestedTiles.push(tile);\n    }\n  }\n\n  // anyChildrenVisible(tileset, tile, frameState) {\n  //   let anyVisible = false;\n  //   for (const child of tile.children) {\n  //     child.updateVisibility(frameState);\n  //     anyVisible = anyVisible || child.isVisibleAndInRequestVolume;\n  //   }\n  //   return anyVisible;\n  // }\n\n  // meetsScreenSpaceErrorEarly(tileset, tile, frameState) {\n  //   const {parent} = tile;\n  //   if (!parent || parent.hasTilesetContent || parent.refine !== TILE3D_REFINEMENT.ADD) {\n  //     return false;\n  //   }\n  //\n  //   // Use parent's geometric error with child's box to see if the tile already meet the SSE\n  //   return tile.getScreenSpaceError(frameState, true) <= tileset.maximumScreenSpaceError;\n  // }\n\n  updateTileVisibility(tile, frameState) {\n    tile.updateVisibility(frameState);\n\n    // //  Optimization - if none of the tile's children are visible then this tile isn't visible\n    // if (!tile.isVisibleAndInRequestVolume) {\n    //   return;\n    // }\n    //\n    // const hasChildren = tile.children.length > 0;\n    // if (tile.hasTilesetContent && hasChildren) {\n    //   // Use the root tile's visibility instead of this tile's visibility.\n    //   // The root tile may be culled by the children bounds optimization in which\n    //   // case this tile should also be culled.\n    //   const firstChild = tile.children[0];\n    //   this.updateTileVisibility(tileset, firstChild, frameState);\n    //   tile._visible = firstChild._visible;\n    //   return;\n    // }\n    //\n    // if (this.meetsScreenSpaceErrorEarly(tileset, tile, frameState)) {\n    //   tile._visible = false;\n    //   return;\n    // }\n    //\n    // const replace = tile.refine === TILE3D_REFINEMENT.REPLACE;\n    // const useOptimization =\n    //   tile._optimChildrenWithinParent === TILE3D_OPTIMIZATION_HINT.USE_OPTIMIZATION;\n    // if (replace && useOptimization && hasChildren) {\n    //   if (!this.anyChildrenVisible(tileset, tile, frameState)) {\n    //     ++tileset._statistics.numberOfTilesCulledWithChildrenUnion;\n    //     tile._visible = false;\n    //     return;\n    //   }\n    // }\n  }\n\n  updateTile(tile, frameState) {\n    this.updateTileVisibility(tile, frameState);\n    tile.updateExpiration();\n  }\n\n  // eslint-disable-next-line complexity\n  updateAndPushChildren(tile, stack, frameState) {\n    const {children} = tile;\n\n    for (const child of children) {\n      this.updateTile(child, frameState);\n      stack.push(child);\n    }\n    return true;\n\n    // for (const child of children) {\n    //   this.updateTile(child, frameState);\n    // }\n    //\n    // function compareDistanceToCamera(a, b) {\n    //   // Sort by farthest child first since this is going on a stack\n    //   return b._distanceToCamera === 0 && a._distanceToCamera === 0\n    //     ? b._centerZDepth - a._centerZDepth\n    //     : b._distanceToCamera - a._distanceToCamera;\n    // }\n    //\n    // // Sort by distance to take advantage of early Z and reduce artifacts for skipLevelOfDetail\n    // children.sort(compareDistanceToCamera);\n    //\n    // // For traditional replacement refinement only refine if all children are loaded.\n    // // Empty tiles are exempt since it looks better if children stream in as they are loaded to fill the empty space.\n    // const checkRefines = !options.skipLevelOfDetail && tile.refine === TILE3D_REFINEMENT.REPLACE && tile.hasRenderContent\n    // let refines = true;\n    //\n    // let anyChildrenVisible = false;\n    // for (const child of children) {\n    //   if (child.isVisibleAndInRequestVolume) {\n    //     stack.push(child);\n    //     anyChildrenVisible = true;\n    //   } else if (checkRefines || options.loadSiblings) {\n    //     // Keep non-visible children loaded since they are still needed before the parent can refine.\n    //     // Or loadSiblings is true so always load tiles regardless of visibility.\n    //     this.loadTile(child, frameState);\n    //     this.touchTile(child, frameState);\n    //   }\n    //   if (checkRefines) {\n    //     let childRefines;\n    //     if (!child._inRequestVolume) {\n    //       childRefines = false;\n    //     } else if (!child.hasRenderContent) {\n    //       childRefines = this.executeEmptyTraversal(child, frameState);\n    //     } else {\n    //       childRefines = child.contentAvailable;\n    //     }\n    //     refines = refines && childRefines;\n    //   }\n    // }\n    //\n    // if (!anyChildrenVisible) {\n    //   refines = false;\n    // }\n    //\n    // return refines;\n  }\n\n  canTraverse(tile, options) {\n    // TODO: remove the depthLimit check once real sse is working\n    if (tile.children.length === 0 || options.depthLimit < tile.depth) {\n      return false;\n    }\n\n    if (tile.hasTilesetContent) {\n      // Traverse external this to visit its root tile\n      // Don't traverse if the subtree is expired because it will be destroyed\n      return !tile.contentExpired;\n    }\n\n    return tile._screenSpaceError > options.maximumScreenSpaceError;\n  }\n\n  // Depth-first traversal that traverses all visible tiles and marks tiles for selection.\n  // If skipLevelOfDetail is off then a tile does not refine until all children are loaded.\n  // This is the traditional replacement refinement approach and is called the base traversal.\n  // Tiles that have a greater screen space error than the base screen space error are part of the base traversal,\n  // all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree\n  // and rendering children and parent tiles simultaneously.\n\n  // eslint-disable-next-line max-statements, complexity\n  executeTraversal(root, baseScreenSpaceError, frameState) {\n    const {traversal} = this;\n    const {stack} = traversal;\n    stack.push(root);\n\n    while (stack.length > 0) {\n      traversal.stackMaximumLength = Math.max(traversal.stackMaximumLength, stack.length);\n\n      const tile = stack.pop();\n      const add = tile.refine === TILE3D_REFINEMENT.ADD;\n      const replace = tile.refine === TILE3D_REFINEMENT.REPLACE;\n      const parent = tile.parent;\n      const parentRefines = !parent || parent._refines;\n      let refines = false;\n\n      if (this.canTraverse(tile, this.options)) {\n        refines = this.updateAndPushChildren(tile, stack, frameState) && parentRefines;\n      }\n\n      const stoppedRefining = !refines && parentRefines;\n\n      if (!tile.hasRenderContent) {\n        // Add empty tile just to show its debug bounding volume\n        // If the tile has this content load the external this\n        // If the tile cannot refine further select its nearest loaded ancestor\n        this.result._emptyTiles.push(tile);\n        this.loadTile(tile, frameState);\n        if (stoppedRefining) {\n          this.selectDesiredTile(tile, frameState);\n        }\n      } else if (add) {\n        // Additive tiles are always loaded and selected\n        this.loadTile(tile, frameState);\n        this.selectDesiredTile(tile, frameState);\n      } else if (replace) {\n        // Always load tiles in the base traversal\n        // Select tiles that can't refine further\n        this.loadTile(tile, frameState);\n        if (stoppedRefining) {\n          this.selectDesiredTile(tile, frameState);\n        }\n      }\n\n      // this.visitTile(tileset, tile, frameState);\n      this.touchTile(tile, frameState);\n      tile._refines = refines;\n    }\n  }\n\n  // Depth-first traversal that checks if all nearest descendants with content are loaded. Ignores visibility.\n  // executeEmptyTraversal(root, frameState) {\n  //   const allDescendantsLoaded = true;\n  //   const stack = emptyTraversal.stack;\n  //   stack.push(root);\n  //\n  //   while (stack.length > 0) {\n  //     emptyTraversal.stackMaximumLength = Math.max(emptyTraversal.stackMaximumLength, stack.length);\n  //\n  //     const tile = stack.pop();\n  //     const children = tile.children;\n  //     const childrenLength = children.length;\n  //\n  //     // Only traverse if the tile is empty - traversal stop at descendants with content\n  //     const traverse = !tile.hasRenderContent && this.canTraverse(tile);\n  //\n  //     // Traversal stops but the tile does not have content yet.\n  //     // There will be holes if the parent tries to refine to its children, so don't refine.\n  //     if (!traverse && !tile.contentAvailable) {\n  //       allDescendantsLoaded = false;\n  //     }\n  //\n  //     this.updateTile(tile, frameState);\n  //     if (!tile.isVisibleAndInRequestVolume) {\n  //       // Load tiles that aren't visible since they are still needed for the parent to refine\n  //       this.loadTile(tile, frameState);\n  //       this.touchTile(tile, frameState);\n  //     }\n  //\n  //     if (traverse) {\n  //       for (const child of this.children) {\n  //         stack.push(child);\n  //       }\n  //     }\n  //   }\n  //\n  //   return allDescendantsLoaded;\n  // }\n}\n"],"file":"tileset-3d-traverser.js"}