import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { Matrix4, Vector3 } from 'math.gl';
import { Ellipsoid } from '@math.gl/geospatial';
import { Stats } from 'probe.gl';
import { path } from '@loaders.gl/core';
import assert from '../utils/assert';
import RequestScheduler from '../request-utils/request-scheduler';
import { calculateTransformProps } from './helpers/transform-utils';
import Tile3DHeader from './tile-3d-header';
import Tileset3DTraverser from './tileset-3d-traverser';
import Tileset3DCache from './tileset-3d-cache';
const TILES_TOTAL = 'Tiles In Tileset(s)';
const TILES_IN_MEMORY = 'Tiles In Memory';
const TILES_IN_VIEW = 'Tiles In View';
const TILES_RENDERABLE = 'Tiles To Render';
const TILES_LOADED = 'Tiles Loaded';
const TILES_LOADING = 'Tiles Loading';
const TILES_UNLOADED = 'Tiles Unloaded';
const TILES_LOAD_FAILED = 'Failed Tile Loads';
const POINTS_COUNT = 'Points';
const TILES_GPU_MEMORY = 'Tile Memory Use';
const WGS84_RADIUS_X = 6378137.0;
const WGS84_RADIUS_Y = 6378137.0;
const WGS84_RADIUS_Z = 6356752.3142451793;

function getZoom(boundingVolume) {
  const {
    halfAxes,
    radius,
    width,
    height
  } = boundingVolume;

  if (halfAxes) {
    const [x,,,, y,,,, z] = halfAxes;
    const zoomX = Math.log2(WGS84_RADIUS_X / x / 2);
    const zoomY = Math.log2(WGS84_RADIUS_Y / y / 2);
    const zoomZ = Math.log2(WGS84_RADIUS_Z / z / 2);
    return (zoomX + zoomY + zoomZ) / 3;
  } else if (radius) {
    return Math.log2(WGS84_RADIUS_Z / radius);
  } else if (height && width) {
    const zoomX = Math.log2(WGS84_RADIUS_X / width);
    const zoomY = Math.log2(WGS84_RADIUS_Y / height);
    return (zoomX + zoomY) / 2;
  }

  return 18;
}

const DEFAULT_OPTIONS = {
  basePath: '',
  ellipsoid: Ellipsoid.WGS84,
  modelMatrix: new Matrix4(),
  throttleRequests: false,
  maximumScreenSpaceError: 16,
  maximumMemoryUsage: 32,
  dynamicScreenSpaceError: false,
  dynamicScreenSpaceErrorDensity: 0.00278,
  dynamicScreenSpaceErrorFactor: 4.0,
  skipLevelOfDetail: false,
  baseScreenSpaceError: 1024,
  onTileLoad: () => {},
  onTileUnload: () => {},
  onTileLoadFail: (tile, message, url) => console.error("A 3D tile failed to load: ".concat(url, " ").concat(message))
};

function getQueryParamString(queryParams) {
  const queryParamStrings = [];

  for (const key of Object.keys(queryParams)) {
    queryParamStrings.push("".concat(key, "=").concat(queryParams[key]));
  }

  switch (queryParamStrings.length) {
    case 0:
      return '';

    case 1:
      return "?".concat(queryParamStrings[0]);

    default:
      return "?".concat(queryParamStrings.join('&'));
  }
}

export default class Tileset3D {
  constructor(json, url, options = {}) {
    assert(json);
    this.options = _objectSpread({}, DEFAULT_OPTIONS, {}, options);
    this.url = url;
    this.basePath = path.dirname(url);
    this.modelMatrix = this.options.modelMatrix;
    this.stats = new Stats({
      id: url
    });

    this._initializeStats();

    this.gpuMemoryUsageInBytes = 0;
    this.geometricError = undefined;
    this.userData = {};
    this._queryParams = {};
    this._requestScheduler = new RequestScheduler({
      throttleRequests: this.options.throttleRequests
    });
    this._traverser = new Tileset3DTraverser();
    this._cache = new Tileset3DCache();
    this._processingQueue = [];
    this.selectedTiles = [];
    this._emptyTiles = [];
    this._requestedTiles = [];
    this._selectedTilesToStyle = [];
    this.asset = {};
    this.credits = {};
    this._root = undefined;
    this._properties = undefined;
    this._extensionsUsed = undefined;
    this._gltfUpAxis = undefined;
    this._loadTimestamp = undefined;
    this._timeSinceLoad = 0.0;
    this._updatedVisibilityFrame = 0;
    this._extras = undefined;
    this._allTilesAdditive = true;
    this._hasMixedContent = false;
    this._maximumScreenSpaceError = options.maximumScreenSpaceError;
    this._maximumMemoryUsage = options.maximumMemoryUsage;
    this._tilesLoaded = false;
    this._initialTilesLoaded = false;
    this._readyPromise = Promise.resolve();
    this._classificationType = this.options.classificationType;
    this._ellipsoid = this.options.ellipsoid;
    this._dynamicScreenSpaceErrorComputedDensity = 0.0;

    this._initializeTileSet(json, this.options);
  }

  destroy() {
    this._destroy();
  }

  get properties() {
    return this._properties;
  }

  get ready() {
    return Boolean(this._root);
  }

  get readyPromise() {
    return this._readyPromise.promise;
  }

  get tilesLoaded() {
    return this._tilesLoaded;
  }

  get queryParams() {
    return getQueryParamString(this._queryParams);
  }

  get root() {
    return this._root;
  }

  get boundingSphere() {
    this._checkReady();

    this._root.updateTransform(this.modelMatrix);

    return this._root.boundingSphere;
  }

  get timeSinceLoad() {
    return this._timeSinceLoad;
  }

  get maximumMemoryUsage() {
    return this._maximumMemoryUsage;
  }

  set maximumMemoryUsage(value) {
    assert(value > 0);
    this._maximumMemoryUsage = value;
  }

  get ellipsoid() {
    return this.options.ellipsoid;
  }

  get extras() {
    return this._extras;
  }

  getTileUrl(tilePath, basePath) {
    const isDataUrl = url => url.startsWith('data:');

    return isDataUrl(tilePath) ? tilePath : "".concat(basePath || this.basePath, "/").concat(tilePath).concat(this.queryParams);
  }

  hasExtension(extensionName) {
    return Boolean(this._extensionsUsed && this._extensionsUsed.indexOf(extensionName) > -1);
  }

  update(frameState) {
    this._updatedVisibilityFrame++;

    this._cache.reset();

    this._traverser.traverse(this.root, frameState, this.options);

    Object.assign(this, this._traverser.result);
    const requestedTiles = this._requestedTiles;

    for (const tile of requestedTiles) {
      this._loadTile(tile);
    }

    this._unloadTiles();

    let tilesRenderable = 0;
    let pointsRenderable = 0;

    for (const tile of this.selectedTiles) {
      if (tile.contentAvailable) {
        tilesRenderable++;

        if (tile.content.pointCount) {
          pointsRenderable += tile.content.pointCount;
        }
      }
    }

    this.stats.get(TILES_IN_VIEW).count = this.selectedTiles.length;
    this.stats.get(TILES_RENDERABLE).count = tilesRenderable;
    this.stats.get(POINTS_COUNT).count = pointsRenderable;
  }

  trimLoadedTiles() {
    this._cache.trim();
  }

  addTileToCache(tile) {
    this._cache.add(this, tile, (tileset, tileToAdd) => tileset._addTileToCache(tileToAdd));
  }

  _initializeTileSet(tilesetJson, options) {
    this.asset = tilesetJson.asset;

    if (!this.asset) {
      throw new Error('Tileset must have an asset property.');
    }

    if (this.asset.version !== '0.0' && this.asset.version !== '1.0') {
      throw new Error('The tileset must be 3D Tiles version 0.0 or 1.0.');
    }

    if ('tilesetVersion' in this.asset) {
      this._queryParams.v = this.asset.tilesetVersion;
    }

    this.credits = {
      attributions: options.attributions || []
    };
    this._properties = tilesetJson.properties;
    this.geometricError = tilesetJson.geometricError;
    this._extensionsUsed = tilesetJson.extensionsUsed;
    this._extras = tilesetJson.extras;
    this._root = this._initializeTileHeaders(tilesetJson, null, this.basePath);

    this._calculateViewProps();
  }

  _calculateViewProps() {
    const root = this._root;
    const {
      center
    } = root.boundingVolume;

    if (!center) {
      console.warn('center was not pre-calculated for the root tile');
      this.cartographicCenter = new Vector3();
      this.zoom = 16;
      return;
    }

    this.cartographicCenter = Ellipsoid.WGS84.cartesianToCartographic(center, new Vector3());
    this.zoom = getZoom(root.boundingVolume);
  }

  _initializeStats() {
    this.stats.get(TILES_TOTAL);
    this.stats.get(TILES_LOADING);
    this.stats.get(TILES_IN_MEMORY);
    this.stats.get(TILES_IN_VIEW);
    this.stats.get(TILES_RENDERABLE);
    this.stats.get(TILES_LOADED);
    this.stats.get(TILES_UNLOADED);
    this.stats.get(TILES_LOAD_FAILED);
    this.stats.get(POINTS_COUNT, 'memory');
    this.stats.get(TILES_GPU_MEMORY, 'memory');
  }

  _initializeTileHeaders(tilesetJson, parentTileHeader, basePath) {
    const rootTile = new Tile3DHeader(this, tilesetJson.root, parentTileHeader, basePath);

    if (parentTileHeader) {
      parentTileHeader.children.push(rootTile);
      rootTile._depth = parentTileHeader._depth + 1;
    }

    const stack = [];
    stack.push(rootTile);

    while (stack.length > 0) {
      const tile = stack.pop();
      this.stats.get(TILES_TOTAL).incrementCount();
      const children = tile._header.children || [];

      for (const childHeader of children) {
        const childTile = new Tile3DHeader(this, childHeader, tile, basePath);
        tile.children.push(childTile);
        childTile._depth = tile._depth + 1;
        stack.push(childTile);
      }
    }

    return rootTile;
  }

  _destroyTileHeaders(parentTile) {
    this._destroySubtree(parentTile);
  }

  async _loadTile(tile) {
    let loaded;
    this.stats.get(TILES_LOADING).incrementCount();

    try {
      loaded = await tile.loadContent();
    } catch (error) {
      this.stats.get(TILES_LOADING).decrementCount();
      this.stats.get(TILES_LOAD_FAILED).incrementCount();
      this.options.onTileLoadFail(tile, error.message || error.toString(), tile.url);
      return;
    }

    this.stats.get(TILES_LOADING).decrementCount();

    if (!loaded) {
      return;
    }

    if (tile && tile._content) {
      calculateTransformProps(tile, tile._content);
    }

    this.options.onTileLoad(tile);
  }

  _addTileToCache(tile) {
    this.stats.get(TILES_LOADED).incrementCount();
    this.stats.get(TILES_IN_MEMORY).incrementCount();
    this.gpuMemoryUsageInBytes += tile._content.byteLength || 0;
    this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;
  }

  _unloadTile(tile) {
    this.stats.get(TILES_IN_MEMORY).decrementCount();
    this.stats.get(TILES_UNLOADED).incrementCount();
    this.gpuMemoryUsageInBytes -= tile._content.byteLength || 0;
    this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;
    this.options.onTileUnload(tile);
    tile.unloadContent();
  }

  _unloadTiles() {
    this._cache.unloadTiles(this, (tileset, tile) => tileset._unloadTile(tile));
  }

  _destroy() {
    const stack = [];

    if (this._root) {
      stack.push(this._root);
    }

    while (stack.length > 0) {
      for (const child of tile.children) {
        stack.push(child);
      }

      const tile = stack.pop();
      tile.destroy();
    }

    this._root = null;
  }

  _destroySubtree(tile) {
    const root = tile;
    const stack = [];
    stack.push(root);

    while (stack.length > 0) {
      tile = stack.pop();

      for (const child of tile.children) {
        stack.push(child);
      }

      if (tile !== root) {
        this._destroyTile(tile);
      }
    }

    root.children = [];
  }

  _destroyTile(tile) {
    this._cache.unloadTile(this, tile);

    this._unloadTile(tile);

    tile.destroy();
  }

}
//# sourceMappingURL=tileset-3d.js.map