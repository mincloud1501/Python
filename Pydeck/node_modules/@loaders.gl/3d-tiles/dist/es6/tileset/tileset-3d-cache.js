import DoublyLinkedList from '../utils/doubly-linked-list';

const defined = x => x !== undefined;

export default class Tileset3DCache {
  constructor() {
    this._list = new DoublyLinkedList();
    this._sentinel = this._list.add();
    this._trimTiles = false;
  }

  reset() {
    this._list.splice(this._list.tail, this._sentinel);
  }

  touch(tile) {
    const node = tile.cacheNode;

    if (defined(node)) {
      this._list.splice(this._sentinel, node);
    }
  }

  add(tileset, tile, addCallback) {
    if (!defined(tile.cacheNode)) {
      tile.cacheNode = this._list.add(tile);

      if (addCallback) {
        addCallback(tileset, tile);
      }
    }
  }

  unloadTile(tileset, tile, unloadCallback) {
    const node = tile.cacheNode;

    if (!defined(node)) {
      return;
    }

    this._list.remove(node);

    tile.cacheNode = undefined;

    if (unloadCallback) {
      unloadCallback(tileset, tile);
    }
  }

  unloadTiles(tileset, unloadCallback) {
    const trimTiles = this._trimTiles;
    this._trimTiles = false;
    const list = this._list;
    const maximumMemoryUsageInBytes = tileset.maximumMemoryUsage * 1024 * 1024;
    const sentinel = this._sentinel;
    let node = list.head;

    while (node !== sentinel && (tileset.gpuMemoryUsageInBytes > maximumMemoryUsageInBytes || trimTiles)) {
      const tile = node.item;
      node = node.next;
      this.unloadTile(tileset, tile, unloadCallback);
    }
  }

  trim() {
    this._trimTiles = true;
  }

}
//# sourceMappingURL=tileset-3d-cache.js.map