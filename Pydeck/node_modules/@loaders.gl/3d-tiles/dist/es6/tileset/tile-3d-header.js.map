{"version":3,"sources":["../../../src/tileset/tile-3d-header.js"],"names":["Vector3","Matrix4","CullingVolume","parse","fetchFile","path","Tile3DLoader","Tileset3DLoader","TILE3D_REFINEMENT","TILE3D_CONTENT_STATE","TILE3D_OPTIMIZATION_HINT","assert","createBoundingVolume","defined","x","undefined","scratchDate","Date","scratchCommandList","scratchToTileCenter","scratchPlane","Plane","INTERSECT","Intersect","computeVisibilityWithPlaneMask","cullingVolume","boundingVolume","parentPlaneMask","Number","isFinite","MASK_OUTSIDE","MASK_INSIDE","mask","planes","k","length","flag","plane","fromNormalDistance","normal","distance","result","intersectPlane","OUTSIDE","INTERSECTING","Tile3DHeader","constructor","tileset","header","parentHeader","basePath","_tileset","_header","_basePath","_content","_contentState","UNLOADED","_gpuMemoryUsageInBytes","parent","children","refine","_getRefine","cacheNode","userData","geometricError","console","warn","_initializeTransforms","_initializeBoundingVolumes","_initializeContent","_initializeCache","_optimChildrenWithinParent","NOT_COMPUTED","_initializeRenderingState","Object","seal","destroy","isDestroyed","gpuMemoryUsageInBytes","depth","_depth","selectedFrame","_selectedFrame","isVisibleAndInRequestVolume","_visible","_inRequestVolume","content","contentReady","READY","hasRenderContent","hasEmptyContent","hasTilesetContent","contentAvailable","_expiredContent","contentFailed","hasUnloadedContent","contentUnloaded","contentExpired","EXPIRED","FAILED","url","getTileUrl","contentUri","uri","_boundingVolume","contentBoundingVolume","_contentBoundingVolume","boundingSphere","extras","getScreenSpaceError","frameState","useParentGeometricError","parentGeometricError","Math","max","_distanceToCamera","height","sseDenominator","error","_getDynamicScreenSpaceError","fog","distanceToCamera","density","scalar","exp","dynamicScreenSpaceError","_dynamicScreenSpaceErrorComputedDensity","factor","dynamicScreenSpaceErrorFactor","dynamicError","loadContent","expired","expireDate","LOADING","updatePriority","tile","_priority","cancelled","_requestScheduler","scheduleRequest","response","startRequest","options","fetchOptions","endRequest","indexOf","_initializeTileHeaders","dirname","_contentLoaded","unloadContent","updateVisibility","_updatedVisibilityFrame","parentTransform","computedTransform","modelMatrix","parentVisibilityPlaneMask","_visibilityPlaneMask","MASK_INDETERMINATE","_updateTransform","distanceToTile","_screenSpaceError","visibility","insideViewerRequestVolume","updateExpiration","now","lessThan","clippingPlanes","clippingPlanesOriginMatrix","enabled","intersection","computeIntersectionWithBoundingVolume","_isClipped","INSIDE","contentVisibility","sqrt","distanceSquaredTo","camera","position","cameraSpaceZDepth","subVectors","center","direction","dot","viewerRequestVolume","_viewerRequestVolume","expire","expireDuration","duration","date","fromIso8601","tileHeader","transform","clone","multiplyRight","parentInitialTransform","_initialTransform","_tile","contentState","_serverKey","fullUri","_centerZDepth","_finalResolution","_stackLength","_selectionDepth","_touchedFrame","_visitedFrame","_requestedFrame","_ancestorWithContent","_ancestorWithContentAvailable","_refines","_shouldSelect","REPLACE","ADD","_isTileset","Boolean","asset","type","traverser","disableSkipLevelOfDetail","didTransformChange","equals","updateContent","expiredContent","update","updateExpireDate","expireDurationDate","addSeconds","createPriorityFunction"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n// import {TILE3D_REFINEMENT, TILE3D_OPTIMIZATION_HINT} from '../constants';\nimport {Vector3, Matrix4} from 'math.gl';\nimport {CullingVolume} from '@math.gl/culling';\nimport {parse, fetchFile, path} from '@loaders.gl/core';\nimport Tile3DLoader from '../tile-3d-loader';\nimport Tileset3DLoader from '../tileset-3d-loader';\nimport {TILE3D_REFINEMENT, TILE3D_CONTENT_STATE, TILE3D_OPTIMIZATION_HINT} from '../constants';\nimport assert from '../utils/assert';\nimport {createBoundingVolume} from './helpers/bounding-volume';\n\nconst defined = x => x !== undefined && x !== null;\n\n/* eslint-disable */\nconst scratchDate = new Date();\nconst scratchCommandList = [];\nconst scratchToTileCenter = new Vector3();\n\n// TODO: Remove\nconst scratchPlane = new Plane();\nimport {INTERSECT, Intersect, Plane} from '@math.gl/culling';\n\nfunction computeVisibilityWithPlaneMask(cullingVolume, boundingVolume, parentPlaneMask) {\n  assert(boundingVolume, 'boundingVolume is required.');\n  assert(Number.isFinite(parentPlaneMask), 'parentPlaneMask is required.');\n\n  if (\n    parentPlaneMask === CullingVolume.MASK_OUTSIDE ||\n    parentPlaneMask === CullingVolume.MASK_INSIDE\n  ) {\n    // parent is completely outside or completely inside, so this child is as well.\n    return parentPlaneMask;\n  }\n\n  // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.\n  // (Because if there are fewer than 31 planes, the upper bits wont be changed.)\n  let mask = CullingVolume.MASK_INSIDE;\n\n  const planes = cullingVolume.planes;\n  for (let k = 0; k < cullingVolume.planes.length; ++k) {\n    // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.\n    const flag = k < 31 ? 1 << k : 0;\n    if (k < 31 && (parentPlaneMask & flag) === 0) {\n      // boundingVolume is known to be INSIDE this plane.\n      continue;\n    }\n\n    const plane = scratchPlane.fromNormalDistance(planes[k].normal, planes[k].distance);\n    const result = boundingVolume.intersectPlane(plane);\n\n    if (result === Intersect.OUTSIDE) {\n      return CullingVolume.MASK_OUTSIDE;\n    } else if (result === Intersect.INTERSECTING) {\n      mask |= flag;\n    }\n  }\n\n  return mask;\n}\n\n// A Tile3DHeader represents a tile a Tileset3D. When a tile is first created, its content is not loaded;\n// the content is loaded on-demand when needed based on the view.\n// Do not construct this directly, instead access tiles through {@link Tileset3D#tileVisible}.\nexport default class Tile3DHeader {\n  constructor(tileset, header, parentHeader, basePath) {\n    // assert(tileset._asset);\n    assert(typeof header === 'object');\n\n    this._tileset = tileset;\n    this._header = header;\n    this._basePath = basePath;\n    this._content = null;\n    this._contentState = TILE3D_CONTENT_STATE.UNLOADED;\n    this._gpuMemoryUsageInBytes = 0;\n\n    // This tile's parent or `undefined` if this tile is the root.\n    this.parent = parentHeader;\n    // The tile's children.\n    this.children = [];\n    // Specifies the type of refine that is used when traversing this tile for rendering.\n    this.refine = this._getRefine(header.refine);\n    this.cacheNode = undefined;\n    this.userData = {};\n\n    // The error, in meters, introduced if this tile is rendered and its children are not.\n    // This is used to compute screen space error, i.e., the error measured in pixels.\n    if ('geometricError' in header) {\n      this.geometricError = header.geometricError;\n    } else {\n      this.geometricError = (this.parent && this.parent.geometricError) || tileset.geometricError;\n      console.warn('3D Tile: Required prop geometricError is undefined. Using parent error');\n    }\n\n    this._initializeTransforms(header);\n    this._initializeBoundingVolumes(header);\n    this._initializeContent(header);\n    this._initializeCache(header);\n\n    // Marks whether the tile's children bounds are fully contained within the tile's bounds\n    // @type {TILE3D_OPTIMIZATION_HINT}\n    this._optimChildrenWithinParent = TILE3D_OPTIMIZATION_HINT.NOT_COMPUTED;\n\n    this._initializeRenderingState();\n\n    Object.seal(this);\n  }\n\n  destroy() {\n    this._header = null;\n  }\n\n  isDestroyed() {\n    return this._header === null;\n  }\n\n  // The tileset containing this tile.\n  get gpuMemoryUsageInBytes() {\n    return this._gpuMemoryUsageInBytes;\n  }\n\n  // The tileset containing this tile.\n  get tileset() {\n    return this._tileset;\n  }\n\n  // The depth of the tile in the tileset tree.\n  get depth() {\n    return this._depth;\n  }\n\n  // The most recent frame that the tile was selected\n  get selectedFrame() {\n    return this._selectedFrame;\n  }\n\n  get isVisibleAndInRequestVolume() {\n    return this._visible && this._inRequestVolume;\n  }\n\n  // The tile's content.  This represents the actual tile's payload,\n  // not the content's metadata in the tileset JSON file.\n  get content() {\n    return this._content;\n  }\n\n  // Determines if the tile's content is ready. This is automatically `true` for\n  // tile's with empty content.\n  get contentReady() {\n    return this._contentState === TILE3D_CONTENT_STATE.READY;\n  }\n\n  // Returns true if tile is not an empty tile and not an external tileset\n  get hasRenderContent() {\n    return !this.hasEmptyContent && !this.hasTilesetContent;\n  }\n\n  // Determines if the tile has available content to render.  `true` if the tile's\n  // content is ready or if it has expired content this renders while new content loads; otherwise,\n  get contentAvailable() {\n    return (\n      (this.contentReady && this.hasRenderContent) ||\n      (defined(this._expiredContent) && !this.contentFailed)\n    );\n  }\n\n  // Returns true if tile has renderable content but it's unloaded\n  get hasUnloadedContent() {\n    return this.hasRenderContent && this.contentUnloaded;\n  }\n\n  // Determines if the tile's content has not be requested. `true` if tile's\n  // content has not be requested; otherwise, `false`.\n  get contentUnloaded() {\n    return this._contentState === TILE3D_CONTENT_STATE.UNLOADED;\n  }\n\n  // Determines if the tile's content is expired. `true` if tile's\n  // content is expired; otherwise, `false`.\n  get contentExpired() {\n    return this._contentState === TILE3D_CONTENT_STATE.EXPIRED;\n  }\n\n  // Determines if the tile's content failed to load.  `true` if the tile's\n  // content failed to load; otherwise, `false`.\n  get contentFailed() {\n    return this._contentState === TILE3D_CONTENT_STATE.FAILED;\n  }\n\n  get url() {\n    return this.tileset.getTileUrl(this.contentUri, this._basePath);\n  }\n\n  get uri() {\n    return this.tileset.getTileUrl(this.contentUri, this._basePath);\n  }\n\n  // Get the tile's bounding volume.\n  get boundingVolume() {\n    return this._boundingVolume;\n  }\n\n  // Get the bounding volume of the tile's contents.  This defaults to the\n  // tile's bounding volume when the content's bounding volume is `undefined`.\n  get contentBoundingVolume() {\n    return this._contentBoundingVolume || this._boundingVolume;\n  }\n\n  // Get the bounding sphere derived from the tile's bounding volume.\n  get boundingSphere() {\n    return this._boundingVolume.boundingSphere;\n  }\n\n  // Returns the `extras` property in the tileset JSON for this tile, which contains application specific metadata.\n  // Returns `undefined` if `extras` does not exist.\n  // @see {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#specifying-extensions-and-application-specific-extras|Extras in the 3D Tiles specification.}\n  get extras() {\n    return this._header.extras;\n  }\n\n  get depth() {\n    return this._depth;\n  }\n\n  // Get the tile's screen space error.\n  getScreenSpaceError(frameState, useParentGeometricError) {\n    const tileset = this._tileset;\n    const parentGeometricError =\n      (this.parent && this.parent.geometricError) || tileset.geometricError;\n    const geometricError = useParentGeometricError ? parentGeometricError : this.geometricError;\n\n    // Leaf tiles do not have any error so save the computation\n    if (geometricError === 0.0) {\n      return 0.0;\n    }\n\n    // TODO: Orthographic Frustum needs special treatment?\n    // this._getOrthograhicScreenSpaceError();\n\n    // Avoid divide by zero when viewer is inside the tile\n    const distance = Math.max(this._distanceToCamera, 1e-7);\n    const {height, sseDenominator} = frameState;\n    let error = (geometricError * height) / (distance * sseDenominator);\n\n    error -= this._getDynamicScreenSpaceError(distance);\n\n    return error;\n  }\n\n  // TODO: Refined screen space error that minimizes tiles in non-first-person\n  _getDynamicScreenSpaceError(distance) {\n    function fog(distanceToCamera, density) {\n      const scalar = distanceToCamera * density;\n      return 1.0 - Math.exp(-(scalar * scalar));\n    }\n\n    const tileset = this._tileset;\n\n    if (tileset.dynamicScreenSpaceError && tileset._dynamicScreenSpaceErrorComputedDensity) {\n      const density = tileset._dynamicScreenSpaceErrorComputedDensity;\n      const factor = tileset.dynamicScreenSpaceErrorFactor;\n      const dynamicError = fog(distance, density) * factor;\n      return dynamicError;\n    }\n\n    return 0;\n  }\n\n  // Requests the tile's content.\n  // The request may not be made if the Request Scheduler can't prioritize it.\n  async loadContent() {\n    if (this.hasEmptyContent) {\n      return false;\n    }\n\n    if (this._content) {\n      return true;\n    }\n\n    const expired = this.contentExpired;\n\n    // Append a query parameter of the tile expiration date to prevent caching\n    // if (expired) {\n    //   expired: this.expireDate.toString()\n    // const request = new Request({\n    //   throttle: true,\n    //   throttleByServer: true,\n    //   type: RequestType.TILES3D,\n    //   priorityFunction: createPriorityFunction(this),\n    //   serverKey: this._serverKey\n    // });\n\n    if (expired) {\n      this.expireDate = undefined;\n    }\n\n    this._contentState = TILE3D_CONTENT_STATE.LOADING;\n\n    function updatePriority(tile) {\n      // Check if any reason to abort\n      if (!tile._visible) {\n        return -1;\n      }\n      if (tile._contentState === TILE3D_CONTENT_STATE.UNLOADED) {\n        return -1;\n      }\n      return Math.max(1e7 - tile._priority, 0) || 0;\n    }\n\n    const cancelled = !(await this.tileset._requestScheduler.scheduleRequest(this, updatePriority));\n\n    if (cancelled) {\n      this._contentState = TILE3D_CONTENT_STATE.UNLOADED;\n      return false;\n    }\n\n    try {\n      const contentUri = this.uri;\n\n      let response;\n      try {\n        this.tileset._requestScheduler.startRequest(this);\n        response = await fetchFile(contentUri, this.tileset.options.fetchOptions);\n      } finally {\n        this.tileset._requestScheduler.endRequest(this);\n      }\n\n      // The content can be a binary tile ot a JSON tileset\n      this._content = await parse(response, [Tile3DLoader, Tileset3DLoader]);\n      // if (Tile3D.isTile(content)) {\n      //   new Tileset3D(content, contentUri);\n\n      if (contentUri.indexOf('.json') !== -1) {\n        // Add tile headers for the nested tilset's subtree\n        // Async update of the tree should be fine since there would never be edits to the same node\n        // TODO - we need to capture the child tileset's URL\n        this._tileset._initializeTileHeaders(this._content, this, path.dirname(this.uri));\n      }\n\n      this._contentState = TILE3D_CONTENT_STATE.READY;\n      this._contentLoaded();\n      return true;\n    } catch (error) {\n      // Tile is unloaded before the content finishes loading\n      this._contentState = TILE3D_CONTENT_STATE.FAILED;\n      throw error;\n    }\n  }\n\n  // Unloads the tile's content.\n  unloadContent() {\n    if (!this.hasRenderContent) {\n      return false;\n    }\n    if (this._content && this._content.destroy) {\n      this._content.destroy();\n    }\n    this._content = null;\n    this._contentState = TILE3D_CONTENT_STATE.UNLOADED;\n    return true;\n  }\n\n  // _getOrthograhicScreenSpaceError() {\n  // if (frustum instanceof OrthographicFrustum) {\n  //   const pixelSize = Math.max(frustum.top - frustum.bottom, frustum.right - frustum.left) / Math.max(width, height);\n  //   error = geometricError / pixelSize;\n  // }\n\n  // Update the tile's visibility.\n  updateVisibility(frameState) {\n    const tileset = this._tileset;\n    if (this._updatedVisibilityFrame === tileset._updatedVisibilityFrame) {\n      // Return early if visibility has already been checked during the traversal.\n      // The visibility may have already been checked if the cullWithChildrenBounds optimization is used.\n      return;\n    }\n\n    const parent = this.parent;\n    const parentTransform = parent ? parent.computedTransform : this._tileset.modelMatrix;\n    const parentVisibilityPlaneMask = parent\n      ? parent._visibilityPlaneMask\n      : CullingVolume.MASK_INDETERMINATE;\n    this._updateTransform(parentTransform);\n    this._distanceToCamera = this.distanceToTile(frameState);\n    // this._centerZDepth = this.cameraSpaceZDepth(frameState);\n    this._screenSpaceError = this.getScreenSpaceError(frameState, false);\n    this._visibilityPlaneMask = this.visibility(frameState, parentVisibilityPlaneMask); // Use parent's plane mask to speed up visibility test\n    this._visible = this._visibilityPlaneMask !== CullingVolume.MASK_OUTSIDE;\n    this._inRequestVolume = this.insideViewerRequestVolume(frameState);\n\n    this._updatedVisibilityFrame = tileset._updatedVisibilityFrame;\n  }\n\n  // Update whether the tile has expired.\n  updateExpiration() {\n    if (defined(this.expireDate) && this.contentReady && !this.hasEmptyContent) {\n      const now = Date.now(scratchDate);\n      if (Date.lessThan(this.expireDate, now)) {\n        this._contentState = TILE3D_CONTENT_STATE.EXPIRED;\n        this._expiredContent = this._content;\n      }\n    }\n  }\n\n  // Determines whether the tile's bounding volume intersects the culling volume.\n  // @param {FrameState} frameState The frame state.\n  // @param {Number} parentVisibilityPlaneMask The parent's plane mask to speed up the visibility check.\n  // @returns {Number} A plane mask as described above in {@link CullingVolume#computeVisibilityWithPlaneMask}.\n  visibility(frameState, parentVisibilityPlaneMask) {\n    const {cullingVolume} = frameState;\n    const {boundingVolume, tileset} = this;\n\n    const {clippingPlanes, clippingPlanesOriginMatrix} = tileset;\n    if (clippingPlanes && clippingPlanes.enabled) {\n      const intersection = clippingPlanes.computeIntersectionWithBoundingVolume(\n        boundingVolume,\n        clippingPlanesOriginMatrix\n      );\n      this._isClipped = intersection !== Intersect.INSIDE;\n      if (intersection === Intersect.OUTSIDE) {\n        return CullingVolume.MASK_OUTSIDE;\n      }\n    }\n\n    // return cullingVolume.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);\n    return computeVisibilityWithPlaneMask(cullingVolume, boundingVolume, parentVisibilityPlaneMask);\n  }\n\n  // Assuming the tile's bounding volume intersects the culling volume, determines\n  // whether the tile's content's bounding volume intersects the culling volume.\n  // @param {FrameState} frameState The frame state.\n  // @returns {Intersect} The result of the intersection: the tile's content is completely outside, completely inside, or intersecting the culling volume.\n  contentVisibility(frameState) {\n    return true;\n    /*\n    // Assumes the tile's bounding volume intersects the culling volume already, so\n    // just return Intersect.INSIDE if there is no content bounding volume.\n    if (!defined(this._contentBoundingVolume)) {\n      return Intersect.INSIDE;\n    }\n\n    if (this._visibilityPlaneMask === CullingVolume.MASK_INSIDE) {\n      // The tile's bounding volume is completely inside the culling volume so\n      // the content bounding volume must also be inside.\n      return Intersect.INSIDE;\n    }\n\n    // PERFORMANCE_IDEA: is it possible to burn less CPU on this test since we know the\n    // tile's (not the content's) bounding volume intersects the culling volume?\n    const cullingVolume = frameState.cullingVolume;\n    const boundingVolume = tile._contentBoundingVolume;\n\n    const tileset = this._tileset;\n    const clippingPlanes = tileset.clippingPlanes;\n    if (defined(clippingPlanes) && clippingPlanes.enabled) {\n      const intersection = clippingPlanes.computeIntersectionWithBoundingVolume(\n        boundingVolume,\n        tileset.clippingPlanesOriginMatrix\n      );\n      this._isClipped = intersection !== Intersect.INSIDE;\n      if (intersection === Intersect.OUTSIDE) {\n        return Intersect.OUTSIDE;\n      }\n    }\n\n    return cullingVolume.computeVisibility(boundingVolume);\n    */\n  }\n\n  // Computes the (potentially approximate) distance from the closest point of the tile's bounding volume to the camera.\n  // @param {FrameState} frameState The frame state.\n  // @returns {Number} The distance, in meters, or zero if the camera is inside the bounding volume.\n  distanceToTile(frameState) {\n    const boundingVolume = this._boundingVolume;\n    return Math.sqrt(boundingVolume.distanceSquaredTo(frameState.camera.position));\n  }\n\n  // Computes the tile's camera-space z-depth.\n  // @param {FrameState} frameState The frame state.\n  // @returns {Number} The distance, in meters.\n  cameraSpaceZDepth({camera}) {\n    const boundingVolume = this.boundingVolume; // Gets the underlying OrientedBoundingBox or BoundingSphere\n    scratchToTileCenter.subVectors(boundingVolume.center, camera.position);\n    return camera.direction.dot(scratchToTileCenter);\n  }\n\n  /**\n   * Checks if the camera is inside the viewer request volume.\n   * @param {FrameState} frameState The frame state.\n   * @returns {Boolean} Whether the camera is inside the volume.\n   */\n  insideViewerRequestVolume(frameState) {\n    const viewerRequestVolume = this._viewerRequestVolume;\n    return !viewerRequestVolume || viewerRequestVolume.distanceToCamera(frameState) === 0.0;\n  }\n\n  // PRIVATE\n\n  _initializeCache(header) {\n    // The node in the tileset's LRU cache, used to determine when to unload a tile's content.\n    this.cacheNode = undefined;\n\n    let expire = header.expire;\n    let expireDuration;\n    let expireDate;\n    if (expire) {\n      expireDuration = expire.duration;\n      if (expire.date) {\n        expireDate = Date.fromIso8601(expire.date);\n      }\n    }\n\n    // The time in seconds after the tile's content is ready when the content expires and new content is requested.\n    // @type {Number}\n    this.expireDuration = expireDuration;\n\n    // The date when the content expires and new content is requested.\n    // @type {Date}\n    this.expireDate = expireDate;\n  }\n\n  _initializeTransforms(tileHeader) {\n    // The local transform of this tile.\n    this.transform = tileHeader.transform ? new Matrix4(tileHeader.transform) : new Matrix4();\n\n    const parent = this.parent;\n    const tileset = this._tileset;\n\n    const parentTransform =\n      parent && parent.computedTransform\n        ? parent.computedTransform.clone()\n        : tileset.modelMatrix.clone();\n    this.computedTransform = new Matrix4(parentTransform).multiplyRight(this.transform);\n\n    const parentInitialTransform =\n      parent && parent._initialTransform ? parent._initialTransform.clone() : new Matrix4();\n    this._initialTransform = new Matrix4(parentInitialTransform).multiplyRight(this.transform);\n  }\n\n  _initializeBoundingVolumes(tileHeader) {\n    this._boundingVolume = createBoundingVolume(tileHeader.boundingVolume, this.computedTransform);\n\n    this._contentBoundingVolume = null;\n    this._viewerRequestVolume = null;\n\n    // Non-leaf tiles may have a content bounding-volume, which is a tight-fit bounding volume\n    // around only the features in the tile. This box is useful for culling for rendering,\n    // but not for culling for traversing the tree since it does not guarantee spatial coherence, i.e.,\n    // since it only bounds features in the tile, not the entire tile, children may be\n    // outside of this box.\n    if (tileHeader.content && tileHeader.content.boundingVolume) {\n      this._contentBoundingVolume = createBoundingVolume(\n        tileHeader.boundingVolume,\n        this.computedTransform\n      );\n    }\n\n    if (tileHeader.viewerRequestVolume) {\n      this._viewerRequestVolume = createBoundingVolume(\n        tileHeader.viewerRequestVolume,\n        this.computedTransform\n      );\n    }\n  }\n\n  _initializeContent(tileHeader) {\n    // Empty tile by default\n    this._content = {_tileset: this._tileset, _tile: this};\n    this.hasEmptyContent = true;\n    this.contentState = TILE3D_CONTENT_STATE.UNLOADED;\n    this._expiredContent = undefined;\n    this._serverKey = null;\n\n    // When `true`, the tile's content points to an external tileset.\n    // This is `false` until the tile's content is loaded.\n    this.hasTilesetContent = false;\n\n    // If a content tileHeader\n    if (tileHeader.content) {\n      this.contentUri = tileHeader.content.uri || tileHeader.content.url;\n      if ('url' in tileHeader) {\n        console.warn('Tileset 3D: \"content.url\" property deprecated. Use \"content.uri\" instead.');\n        this.contentUri = tileHeader.url;\n      }\n      this._content = null;\n      this.hasEmptyContent = false;\n      this.contentState = TILE3D_CONTENT_STATE.UNLOADED;\n      this.fullUri = this._basePath + '/' + this.contentUri;\n      // this.serverKey = RequestScheduler.getServerKey(contentResource.getUrlComponent());\n    }\n  }\n\n  // TODO - remove anything not related to basic visibility detection\n  _initializeRenderingState() {\n    // Members this are updated every frame for tree traversal and rendering optimizations:\n    this._distanceToCamera = 0;\n    this._centerZDepth = 0;\n    this._screenSpaceError = 0;\n    this._visibilityPlaneMask = CullingVolume.MASK_INDETERMINATE;\n    this._visible = false;\n    this._inRequestVolume = false;\n\n    this._finalResolution = true;\n    this._depth = 0;\n    this._stackLength = 0;\n    this._selectionDepth = 0;\n\n    this._updatedVisibilityFrame = 0;\n    this._touchedFrame = 0;\n    this._visitedFrame = 0;\n    this._selectedFrame = 0;\n    this._requestedFrame = 0;\n    this._ancestorWithContent = undefined;\n    this._ancestorWithContentAvailable = undefined;\n    this._refines = false;\n    this._shouldSelect = false;\n    this._priority = 0.0;\n  }\n\n  _getRefine(refine) {\n    switch (refine) {\n      case 'REPLACE':\n      case 'replace':\n        return TILE3D_REFINEMENT.REPLACE;\n      case 'ADD':\n      case 'add':\n        return TILE3D_REFINEMENT.ADD;\n      default:\n        // Inherit from parent tile if omitted.\n        return this.parent ? this.parent.refine : TILE3D_REFINEMENT.REPLACE;\n    }\n  }\n\n  _isTileset(content) {\n    return Boolean(content.asset);\n  }\n\n  _contentLoaded() {\n    // Vector and Geometry tile rendering do not support the skip LOD optimization.\n    switch (this._content && this._content.type) {\n      case 'vctr':\n      case 'geom':\n        tileset.traverser.disableSkipLevelOfDetail = true;\n      default:\n    }\n\n    // The content may be tileset json\n    if (this._isTileset(this._content)) {\n      this.hasTilesetContent = true;\n    }\n  }\n\n  // Update the tile's transform. The transform is applied to the tile's bounding volumes.\n  _updateTransform(parentTransform = new Matrix4()) {\n    const computedTransform = parentTransform.clone().multiplyRight(this.transform);\n    const didTransformChange = !computedTransform.equals(this.computedTransform);\n\n    if (!didTransformChange) {\n      return;\n    }\n\n    this.computedTransform = computedTransform;\n\n    // Matrix4.clone(computedTransform, this.computedTransform);\n\n    // Update the bounding volumes\n    const header = this._header;\n\n    const content = this._header.content;\n    this._boundingVolume = createBoundingVolume(\n      header.boundingVolume,\n      this.computedTransform,\n      this._boundingVolume\n    );\n    if (this._contentBoundingVolume) {\n      this._contentBoundingVolume = createBoundingVolume(\n        content.boundingVolume,\n        this.computedTransform,\n        this._contentBoundingVolume\n      );\n    }\n    if (this._viewerRequestVolume) {\n      this._viewerRequestVolume = createBoundingVolume(\n        header.viewerRequestVolume,\n        this.computedTransform,\n        this._viewerRequestVolume\n      );\n    }\n  }\n}\n\nfunction updateContent(tile, tileset, frameState) {\n  const content = tile._content;\n  const expiredContent = tile._expiredContent;\n\n  if (expiredContent) {\n    if (!tile.contentReady) {\n      // Render the expired content while the content loads\n      expiredContent.update(tileset, frameState);\n      return;\n    }\n\n    // New content is ready, destroy expired content\n    tile._expiredContent.destroy();\n    tile._expiredContent = undefined;\n  }\n\n  content.update(tileset, frameState);\n}\n\nfunction updateExpireDate(tile) {\n  if (defined(tile.expireDuration)) {\n    const expireDurationDate = Date.now(scratchDate);\n    Date.addSeconds(expireDurationDate, tile.expireDuration, expireDurationDate);\n\n    if (defined(tile.expireDate)) {\n      if (Date.lessThan(tile.expireDate, expireDurationDate)) {\n        Date.clone(expireDurationDate, tile.expireDate);\n      }\n    } else {\n      tile.expireDate = Date.clone(expireDurationDate);\n    }\n  }\n}\n\nfunction createPriorityFunction(tile) {\n  return function() {\n    return tile._priority;\n  };\n}\n"],"file":"tile-3d-header.js"}