(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/bundle.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/process/browser.js":
/*!************************************************************************!*\
  !*** /Users/xintongxia/dev/loaders.gl/node_modules/process/browser.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "../../node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../core/src/index.js":
/*!****************************!*\
  !*** ../core/src/index.js ***!
  \****************************/
/*! exports provided: path, setPathPrefix, getPathPrefix, resolvePath, fetchFile, readFileSync, writeFile, writeFileSync, _getErrorMessageFromResponseSync, _getErrorMessageFromResponse, registerLoaders, parse, parseSync, parseInBatches, parseInBatchesSync, load, loadInBatches, encode, encodeSync, encodeInBatches, save, saveSync, isPromise, isIterable, isAsyncIterable, isIterator, isFetchResponse, isReadableStream, isWritableStream, toArrayBuffer, getStreamIterator, forEach, concatenateAsyncIterator, lineAsyncIterator, textDecoderAsyncIterator, numberedLineAsyncIterator, isBrowser, self, window, global, document, assert, _selectLoader, _WorkerThread, _WorkerFarm, _WorkerPool, _fetchProgress, _unregisterLoaders, TextEncoder, TextDecoder, createReadStream, parseFile, parseFileSync, loadFile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextEncoder", function() { return TextEncoder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextDecoder", function() { return TextDecoder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createReadStream", function() { return createReadStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseFile", function() { return parseFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseFileSync", function() { return parseFileSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadFile", function() { return loadFile; });
/* harmony import */ var _lib_parse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/parse */ "../core/src/lib/parse.js");
/* harmony import */ var _lib_parse_sync__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/parse-sync */ "../core/src/lib/parse-sync.js");
/* harmony import */ var _lib_fetch_fetch_file__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/fetch/fetch-file */ "../core/src/lib/fetch/fetch-file.js");
/* harmony import */ var _lib_load__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/load */ "../core/src/lib/load.js");
/* harmony import */ var _lib_fetch_file_aliases__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/fetch/file-aliases */ "../core/src/lib/fetch/file-aliases.js");
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/globals */ "../core/src/utils/globals.js");
/* harmony import */ var _lib_path_path__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/path/path */ "../core/src/lib/path/path.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "path", function() { return _lib_path_path__WEBPACK_IMPORTED_MODULE_6__; });
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setPathPrefix", function() { return _lib_fetch_file_aliases__WEBPACK_IMPORTED_MODULE_4__["setPathPrefix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getPathPrefix", function() { return _lib_fetch_file_aliases__WEBPACK_IMPORTED_MODULE_4__["getPathPrefix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resolvePath", function() { return _lib_fetch_file_aliases__WEBPACK_IMPORTED_MODULE_4__["resolvePath"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fetchFile", function() { return _lib_fetch_fetch_file__WEBPACK_IMPORTED_MODULE_2__["fetchFile"]; });

/* harmony import */ var _lib_fetch_read_file__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/fetch/read-file */ "../core/src/lib/fetch/read-file.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "readFileSync", function() { return _lib_fetch_read_file__WEBPACK_IMPORTED_MODULE_7__["readFileSync"]; });

/* harmony import */ var _lib_fetch_write_file__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/fetch/write-file */ "../core/src/lib/fetch/write-file.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "writeFile", function() { return _lib_fetch_write_file__WEBPACK_IMPORTED_MODULE_8__["writeFile"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "writeFileSync", function() { return _lib_fetch_write_file__WEBPACK_IMPORTED_MODULE_8__["writeFileSync"]; });

/* harmony import */ var _lib_fetch_fetch_error_message__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/fetch/fetch-error-message */ "../core/src/lib/fetch/fetch-error-message.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_getErrorMessageFromResponseSync", function() { return _lib_fetch_fetch_error_message__WEBPACK_IMPORTED_MODULE_9__["getErrorMessageFromResponseSync"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_getErrorMessageFromResponse", function() { return _lib_fetch_fetch_error_message__WEBPACK_IMPORTED_MODULE_9__["getErrorMessageFromResponse"]; });

/* harmony import */ var _lib_register_loaders__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/register-loaders */ "../core/src/lib/register-loaders.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "registerLoaders", function() { return _lib_register_loaders__WEBPACK_IMPORTED_MODULE_10__["registerLoaders"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return _lib_parse__WEBPACK_IMPORTED_MODULE_0__["parse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseSync", function() { return _lib_parse_sync__WEBPACK_IMPORTED_MODULE_1__["parseSync"]; });

/* harmony import */ var _lib_parse_in_batches__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/parse-in-batches */ "../core/src/lib/parse-in-batches.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseInBatches", function() { return _lib_parse_in_batches__WEBPACK_IMPORTED_MODULE_11__["parseInBatches"]; });

/* harmony import */ var _lib_parse_in_batches_sync__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./lib/parse-in-batches-sync */ "../core/src/lib/parse-in-batches-sync.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseInBatchesSync", function() { return _lib_parse_in_batches_sync__WEBPACK_IMPORTED_MODULE_12__["parseInBatchesSync"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "load", function() { return _lib_load__WEBPACK_IMPORTED_MODULE_3__["load"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadInBatches", function() { return _lib_load__WEBPACK_IMPORTED_MODULE_3__["loadInBatches"]; });

/* harmony import */ var _lib_encode__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./lib/encode */ "../core/src/lib/encode.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "encode", function() { return _lib_encode__WEBPACK_IMPORTED_MODULE_13__["encode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "encodeSync", function() { return _lib_encode__WEBPACK_IMPORTED_MODULE_13__["encodeSync"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "encodeInBatches", function() { return _lib_encode__WEBPACK_IMPORTED_MODULE_13__["encodeInBatches"]; });

/* harmony import */ var _lib_save__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./lib/save */ "../core/src/lib/save.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "save", function() { return _lib_save__WEBPACK_IMPORTED_MODULE_14__["save"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "saveSync", function() { return _lib_save__WEBPACK_IMPORTED_MODULE_14__["saveSync"]; });

/* harmony import */ var _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./javascript-utils/is-type */ "../core/src/javascript-utils/is-type.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isPromise", function() { return _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_15__["isPromise"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isIterable", function() { return _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_15__["isIterable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isAsyncIterable", function() { return _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_15__["isAsyncIterable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isIterator", function() { return _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_15__["isIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isFetchResponse", function() { return _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_15__["isFetchResponse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isReadableStream", function() { return _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_15__["isReadableStream"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWritableStream", function() { return _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_15__["isWritableStream"]; });

/* harmony import */ var _javascript_utils_binary_utils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./javascript-utils/binary-utils */ "../core/src/javascript-utils/binary-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toArrayBuffer", function() { return _javascript_utils_binary_utils__WEBPACK_IMPORTED_MODULE_16__["toArrayBuffer"]; });

/* harmony import */ var _javascript_utils_stream_utils__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./javascript-utils/stream-utils */ "../core/src/javascript-utils/stream-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getStreamIterator", function() { return _javascript_utils_stream_utils__WEBPACK_IMPORTED_MODULE_17__["getStreamIterator"]; });

/* harmony import */ var _javascript_utils_async_iterator_utils__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./javascript-utils/async-iterator-utils */ "../core/src/javascript-utils/async-iterator-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return _javascript_utils_async_iterator_utils__WEBPACK_IMPORTED_MODULE_18__["forEach"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concatenateAsyncIterator", function() { return _javascript_utils_async_iterator_utils__WEBPACK_IMPORTED_MODULE_18__["concatenateAsyncIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lineAsyncIterator", function() { return _javascript_utils_async_iterator_utils__WEBPACK_IMPORTED_MODULE_18__["lineAsyncIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "textDecoderAsyncIterator", function() { return _javascript_utils_async_iterator_utils__WEBPACK_IMPORTED_MODULE_18__["textDecoderAsyncIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "numberedLineAsyncIterator", function() { return _javascript_utils_async_iterator_utils__WEBPACK_IMPORTED_MODULE_18__["numberedLineAsyncIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_5__["isBrowser"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "self", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_5__["self"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_5__["window"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "global", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_5__["global"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "document", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_5__["document"]; });

/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./utils/assert */ "../core/src/utils/assert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return _utils_assert__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _lib_select_loader__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./lib/select-loader */ "../core/src/lib/select-loader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_selectLoader", function() { return _lib_select_loader__WEBPACK_IMPORTED_MODULE_20__["selectLoader"]; });

/* harmony import */ var _worker_utils_worker_thread__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./worker-utils/worker-thread */ "../core/src/worker-utils/worker-thread.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_WorkerThread", function() { return _worker_utils_worker_thread__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony import */ var _worker_utils_worker_farm__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./worker-utils/worker-farm */ "../core/src/worker-utils/worker-farm.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_WorkerFarm", function() { return _worker_utils_worker_farm__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony import */ var _worker_utils_worker_pool__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./worker-utils/worker-pool */ "../core/src/worker-utils/worker-pool.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_WorkerPool", function() { return _worker_utils_worker_pool__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony import */ var _lib_progress_fetch_progress__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./lib/progress/fetch-progress */ "../core/src/lib/progress/fetch-progress.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_fetchProgress", function() { return _lib_progress_fetch_progress__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_unregisterLoaders", function() { return _lib_register_loaders__WEBPACK_IMPORTED_MODULE_10__["_unregisterLoaders"]; });









// PATH



// FILE READING AND WRITING






// FILE PARSING AND ENCODING


// LOADING (READING + PARSING)






// ENCODING AND SAVING



// "JAVASCRIPT" UTILS




// ITERATOR UTILS




// CORE UTILS



// EXPERIMENTAL








// FOR TESTING


// DEPRECATED

// Use @loaders.gl/polyfills and global symbols instead
const TextEncoder = _utils_globals__WEBPACK_IMPORTED_MODULE_5__["global"].TextEncoder;
const TextDecoder = _utils_globals__WEBPACK_IMPORTED_MODULE_5__["global"].TextDecoder;

// Returns a promise that resolves to a readable stream
async function createReadStream(url, options) {
  // eslint-disable-next-line
  console.warn('createReadStream() deprecated, use fetch().then(resp => resp.body)');
  url = Object(_lib_fetch_file_aliases__WEBPACK_IMPORTED_MODULE_4__["resolvePath"])(url);
  const response = await Object(_lib_fetch_fetch_file__WEBPACK_IMPORTED_MODULE_2__["fetchFile"])(url, options);
  return response.body;
}

function parseFile(...args) {
  console.warn('parse() deprecated, use parse()'); // eslint-disable-line
  return Object(_lib_parse__WEBPACK_IMPORTED_MODULE_0__["parse"])(...args);
}

function parseFileSync(...args) {
  console.warn('parseSync() deprecated, use parseSync()'); // eslint-disable-line
  return Object(_lib_parse_sync__WEBPACK_IMPORTED_MODULE_1__["parseSync"])(...args);
}

function loadFile(...args) {
  console.warn('loadFile() deprecated, use load()'); // eslint-disable-line
  return Object(_lib_load__WEBPACK_IMPORTED_MODULE_3__["load"])(...args);
}


/***/ }),

/***/ "../core/src/javascript-utils/async-iterator-utils.js":
/*!************************************************************!*\
  !*** ../core/src/javascript-utils/async-iterator-utils.js ***!
  \************************************************************/
/*! exports provided: forEach, concatenateAsyncIterator, textDecoderAsyncIterator, textEncoderAsyncIterator, lineAsyncIterator, numberedLineAsyncIterator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concatenateAsyncIterator", function() { return concatenateAsyncIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "textDecoderAsyncIterator", function() { return textDecoderAsyncIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "textEncoderAsyncIterator", function() { return textEncoderAsyncIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineAsyncIterator", function() { return lineAsyncIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numberedLineAsyncIterator", function() { return numberedLineAsyncIterator; });
/* harmony import */ var _javascript_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../javascript-utils/memory-copy-utils */ "../core/src/javascript-utils/memory-copy-utils.js");
/* global TextDecoder, TextEncoder */


// GENERAL UTILITIES

// Iterate over async iterator, without resetting iterator if end is not reached
// - forEach does not reset iterator if exiting loop prematurely
//   so that iteration can continue in a second loop
// - It is recommended to use a standard for await as last loop to ensure
//   iterator gets properly reset
// TODO - optimize using sync iteration if argument is an Iterable?
async function forEach(iterator, visitor) {
  // eslint-disable-next-line
  while (true) {
    const {done, value} = await iterator.next();
    if (done) {
      iterator.return();
      return;
    }
    const cancel = visitor(value);
    if (cancel) {
      return;
    }
  }
}

// Concatenates all data chunks yielded by an async iterator
async function concatenateAsyncIterator(asyncIterator) {
  let arrayBuffer = new ArrayBuffer();
  let string = '';
  for await (const chunk of asyncIterator) {
    if (typeof chunk === 'string') {
      string += chunk;
    } else {
      arrayBuffer = Object(_javascript_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_0__["concatenateArrayBuffers"])(arrayBuffer, chunk);
    }
  }
  return string || arrayBuffer;
}

// ITERATOR GENERATORS

// TextDecoder iterators
// TextDecoder will keep any partial undecoded bytes between calls to `decode`

async function* textDecoderAsyncIterator(arrayBufferIterator, options) {
  const textDecoder = new TextDecoder(options);
  for await (const arrayBuffer of arrayBufferIterator) {
    yield typeof arrayBuffer === 'string'
      ? arrayBuffer
      : textDecoder.decode(arrayBuffer, {stream: true});
  }
}

// TextEncoder iterator
// TODO - this is not useful unless min chunk size is given
// TextEncoder will keep any partial undecoded bytes between calls to `encode`
// If iterator does not yield strings, assume arrayBuffer and return unencoded

async function* textEncoderAsyncIterator(textIterator, options) {
  const textEncoder = new TextEncoder();
  for await (const text of textIterator) {
    yield typeof text === 'string' ? textEncoder.encode(text) : text;
  }
}

// Input: async iterable over strings
// Returns: an async iterable over lines
// See http://2ality.com/2018/04/async-iter-nodejs.html

async function* lineAsyncIterator(textIterator) {
  let previous = '';
  for await (const textChunk of textIterator) {
    previous += textChunk;
    let eolIndex;
    while ((eolIndex = previous.indexOf('\n')) >= 0) {
      // line includes the EOL
      const line = previous.slice(0, eolIndex + 1);
      previous = previous.slice(eolIndex + 1);
      yield line;
    }
  }

  if (previous.length > 0) {
    yield previous;
  }
}

/**
 * Parameter: async iterable of lines
 * Result: async iterable of numbered lines
 */
// See http://2ality.com/2018/04/async-iter-nodejs.html
// eslint-disable-next-line no-shadow
async function* numberedLineAsyncIterator(lineIterator) {
  let counter = 1;
  for await (const line of lineIterator) {
    yield {counter, line};
    counter++;
  }
}


/***/ }),

/***/ "../core/src/javascript-utils/binary-utils.js":
/*!****************************************************!*\
  !*** ../core/src/javascript-utils/binary-utils.js ***!
  \****************************************************/
/*! exports provided: toArrayBuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toArrayBuffer", function() { return toArrayBuffer; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "../core/src/utils/assert.js");
/* harmony import */ var _node_utils_to_array_buffer_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node/utils/to-array-buffer.node */ 0);
/* harmony import */ var _node_utils_to_array_buffer_node__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_utils_to_array_buffer_node__WEBPACK_IMPORTED_MODULE_1__);
/* global ArrayBuffer, TextEncoder */



function toArrayBuffer(data) {
  if (_node_utils_to_array_buffer_node__WEBPACK_IMPORTED_MODULE_1__["toArrayBuffer"]) {
    // TODO - per docs we should just be able to call buffer.buffer, but there are issues
    data = Object(_node_utils_to_array_buffer_node__WEBPACK_IMPORTED_MODULE_1__["toArrayBuffer"])(data);
  }

  if (data instanceof ArrayBuffer) {
    return data;
  }

  // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)
  if (ArrayBuffer.isView(data)) {
    return data.buffer;
  }

  if (typeof data === 'string') {
    const text = data;
    const uint8Array = new TextEncoder().encode(text);
    return uint8Array.buffer;
  }

  return Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(false);
}

// export function blobToArrayBuffer(blob) {
//   return new Promise((resolve, reject) => {
//     let arrayBuffer;
//     const fileReader = new FileReader();
//     fileReader.onload = event => {
//       arrayBuffer = event.target.result;
//     };
//     fileReader.onloadend = event => resolve(arrayBuffer);
//     fileReader.onerror = reject;
//     fileReader.readAsArrayBuffer(blob);
//   });
// }


/***/ }),

/***/ "../core/src/javascript-utils/is-type.js":
/*!***********************************************!*\
  !*** ../core/src/javascript-utils/is-type.js ***!
  \***********************************************/
/*! exports provided: isPromise, isIterable, isAsyncIterable, isIterator, isFetchResponse, isFile, isBlob, isFileReadable, isWritableDOMStream, isReadableDOMStream, isWritableNodeStream, isReadableNodeStream, isReadableStream, isWritableStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPromise", function() { return isPromise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIterable", function() { return isIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAsyncIterable", function() { return isAsyncIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIterator", function() { return isIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFetchResponse", function() { return isFetchResponse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFile", function() { return isFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBlob", function() { return isBlob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFileReadable", function() { return isFileReadable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWritableDOMStream", function() { return isWritableDOMStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isReadableDOMStream", function() { return isReadableDOMStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWritableNodeStream", function() { return isWritableNodeStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isReadableNodeStream", function() { return isReadableNodeStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isReadableStream", function() { return isReadableStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWritableStream", function() { return isWritableStream; });
/* global File, Blob, Response */

const isBoolean = x => typeof x === 'boolean';
const isFunction = x => typeof x === 'function';
const isObject = x => x !== null && typeof x === 'object';

const isPromise = x => isObject(x) && isFunction(x.then);

const isIterable = x => x && typeof x[Symbol.iterator] === 'function';

const isAsyncIterable = x => x && typeof x[Symbol.asyncIterator] === 'function';

const isIterator = x => x && isFunction(x.next);

const isFetchResponse = x =>
  (typeof Response !== 'undefined' && x instanceof Response) || (x.arrayBuffer && x.text && x.json);

const isFile = x => typeof File !== 'undefined' && x instanceof File;
const isBlob = x => typeof Blob !== 'undefined' && x instanceof Blob;
const isFileReadable = x => isFile(x) || isBlob(x); // Blob & File are FileReader compatible

const isWritableDOMStream = x => {
  return isObject(x) && isFunction(x.abort) && isFunction(x.getWriter);
};

const isReadableDOMStream = x => {
  return (
    isObject(x) &&
    isFunction(x.tee) &&
    isFunction(x.cancel) &&
    isFunction(x.pipeTo) &&
    isFunction(x.getReader)
  );
};

const isWritableNodeStream = x => {
  return isObject(x) && isFunction(x.end) && isFunction(x.write) && isBoolean(x.writable);
};

const isReadableNodeStream = x => {
  return isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);
};

const isReadableStream = x => isReadableDOMStream(x) || isReadableNodeStream(x);

const isWritableStream = x => isWritableDOMStream(x) || isWritableNodeStream(x);


/***/ }),

/***/ "../core/src/javascript-utils/memory-copy-utils.js":
/*!*********************************************************!*\
  !*** ../core/src/javascript-utils/memory-copy-utils.js ***!
  \*********************************************************/
/*! exports provided: concatenateArrayBuffers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concatenateArrayBuffers", function() { return concatenateArrayBuffers; });
function concatenateArrayBuffers(source1, source2) {
  const sourceArray1 = source1 instanceof ArrayBuffer ? new Uint8Array(source1) : source1;
  const sourceArray2 = source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2;
  const temp = new Uint8Array(sourceArray1.byteLength + sourceArray2.byteLength);
  temp.set(sourceArray1, 0);
  temp.set(sourceArray2, sourceArray1.byteLength);
  return temp;
}


/***/ }),

/***/ "../core/src/javascript-utils/stream-utils.js":
/*!****************************************************!*\
  !*** ../core/src/javascript-utils/stream-utils.js ***!
  \****************************************************/
/*! exports provided: getStreamIterator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStreamIterator", function() { return getStreamIterator; });
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/globals */ "../core/src/utils/globals.js");


function getStreamIterator(stream) {
  // Hacky test for node version to ensure we don't call bad polyfills
  if (_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"] || _utils_globals__WEBPACK_IMPORTED_MODULE_0__["nodeVersion"] >= 10) {
    // NODE 10+: stream is an asyncIterator
    if (typeof stream[Symbol.asyncIterator] === 'function') {
      return stream;
    }

    // WhatWG: stream is supposed to have a `getIterator` method
    if (typeof stream.getIterator === 'function') {
      return stream.getIterator();
    }
  }

  return _utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"] ? makeBrowserStreamIterator(stream) : makeNodeStreamIterator(stream);
}

// BROWSER IMPLEMENTATION
// See https://jakearchibald.com/2017/async-iterators-and-generators/#making-streams-iterate

async function* makeBrowserStreamIterator(stream) {
  // In the brower, we first need to get a lock on the stream
  const reader = stream.getReader();

  try {
    // eslint-disable-next-line no-constant-condition
    while (true) {
      // Read from the stream
      const {done, value} = await reader.read();
      // Exit if we're done
      if (done) {
        return;
      }
      // Else yield the chunk
      yield value;
    }
  } catch (error) {
    // TODO - examples makes it look like this should always be called,
    // but that generates exceptions so only call it if we do not reach the end
    reader.releaseLock();
  }
}

// NODE <10 IMPLEMENTATION
// See https://github.com/bustle/streaming-iterables, MIT license

async function* makeNodeStreamIterator(stream) {
  // Node createStream will return promises to handle http requests
  stream = await stream;

  // eslint-disable-next-line no-constant-condition
  while (true) {
    const data = stream.read();
    if (data !== null) {
      yield data;
      // eslint-disable-next-line no-continue
      continue;
    }
    if (stream._readableState.ended) {
      return;
    }
    await onceReadable(stream);
  }
}

async function onceReadable(stream) {
  return new Promise(resolve => {
    stream.once('readable', resolve);
  });
}

// TODO - we could add our own polyfill
// const {Readable} = require('stream');
// if (typeof Readable !== 'undefined' && !Readable.prototype[Symbol.asyncIterator]) {
//   Readable.prototype[Symbol.asyncIterator] = function () {
//     return makeNodeStreamIterator(this);
//   }
// }


/***/ }),

/***/ "../core/src/lib/encode.js":
/*!*********************************!*\
  !*** ../core/src/lib/encode.js ***!
  \*********************************/
/*! exports provided: encode, encodeSync, encodeInBatches */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encode", function() { return encode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeSync", function() { return encodeSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeInBatches", function() { return encodeInBatches; });
function encode(data, writer, options, url) {
  if (writer.encode) {
    return writer.encode(data, options);
  }
  if (writer.encodeSync) {
    return Promise.resolve(writer.encodeSync(data, options));
  }
  // TODO - Use encodeToBatches?
  throw new Error('Writer could not encode data');
}

function encodeSync(data, writer, options, url) {
  if (writer.encodeSync) {
    return writer.encodeSync(data, options);
  }
  throw new Error('Writer could not synchronously encode data');
}

function encodeInBatches(data, writer, options, url) {
  if (writer.encodeInBatches) {
    return writer.encodeInBatches(data, options);
  }
  // TODO -fall back to atomic encode?
  throw new Error('Writer could not encode data in batches');
}


/***/ }),

/***/ "../core/src/lib/fetch/fetch-error-message.js":
/*!****************************************************!*\
  !*** ../core/src/lib/fetch/fetch-error-message.js ***!
  \****************************************************/
/*! exports provided: getErrorMessageFromResponseSync, getErrorMessageFromResponse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getErrorMessageFromResponseSync", function() { return getErrorMessageFromResponseSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getErrorMessageFromResponse", function() { return getErrorMessageFromResponse; });
function getErrorMessageFromResponseSync(response) {
  return `Failed to fetch resource ${response.url}(${response.status}): ${response.statusText} `;
}

async function getErrorMessageFromResponse(response) {
  let message = `Failed to fetch resource ${response.url} (${response.status}): `;
  try {
    const contentType = response.headers.get('Content-Type');
    if (contentType.includes('application/json')) {
      message += await response.text();
    } else {
      message += response.statusText;
    }
  } catch (error) {
    // eslint forbids return in finally statement
    return message;
  }
  return message;
}


/***/ }),

/***/ "../core/src/lib/fetch/fetch-file.browser.js":
/*!***************************************************!*\
  !*** ../core/src/lib/fetch/fetch-file.browser.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return fetchFileReadable; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/assert */ "../core/src/utils/assert.js");
/* global FileReader, Headers */


// File reader fetch "polyfill" for the browser
class FileReadableResponse {
  constructor(fileOrBlob) {
    this._fileOrBlob = fileOrBlob;
    this.bodyUsed = false;
  }

  get headers() {
    return new Headers({
      'Content-Length': this._fileOrBlob.size,
      'Content-Type': this._fileOrBlob.type
    });
  }

  get ok() {
    return true; // Blob & File objects are already in memory
  }

  get status() {
    return 200; // Blob & File objects are already in memory
  }

  url() {
    // Note: This is just the file name without path information
    // Note: File has `name` field but the Blob baseclass does not
    return this._fileOrBlob.name || '';
  }

  async arrayBuffer() {
    const {reader, promise} = this._getFileReader();
    reader.readAsArrayBuffer(this._fileOrBlob);
    return promise;
  }

  async text() {
    const {reader, promise} = this._getFileReader();
    reader.readAsText(this._fileOrBlob);
    return promise;
  }

  async json() {
    const text = await this.text();
    return JSON.parse(text);
  }

  // TODO - body, how to support stream?
  // Can this be portable?
  // eslint-disable-next-line
  // https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams#Creating_your_own_custom_readable_stream
  // get body() {
  //   assert(false);
  // }

  // PRIVATE

  _getFileReader() {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(!this.bodyUsed);
    this.bodyUsed = true;

    let reader;
    const promise = new Promise((resolve, reject) => {
      try {
        reader = new FileReader();
        reader.onerror = error => reject(new Error(error));
        reader.onabort = () => reject(new Error('Read aborted.'));
        reader.onload = () => resolve(reader.result);
      } catch (error) {
        reject(error);
      }
    });
    return {reader, promise};
  }
}

// @param {File|Blob} file  HTML File or Blob object to read as string
// @returns {Promise.string}  Resolves to a string containing file contents
function fetchFileReadable(fileOrBlob, options) {
  return Promise.resolve(new FileReadableResponse(fileOrBlob, options));
}


/***/ }),

/***/ "../core/src/lib/fetch/fetch-file.js":
/*!*******************************************!*\
  !*** ../core/src/lib/fetch/fetch-file.js ***!
  \*******************************************/
/*! exports provided: fetchFile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchFile", function() { return fetchFile; });
/* harmony import */ var _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../javascript-utils/is-type */ "../core/src/javascript-utils/is-type.js");
/* harmony import */ var _file_aliases__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./file-aliases */ "../core/src/lib/fetch/file-aliases.js");
/* harmony import */ var _fetch_file_browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fetch-file.browser */ "../core/src/lib/fetch/fetch-file.browser.js");
/* global fetch */




// As fetch but respects pathPrefix and file aliases
// Reads file data from:
// * data urls
// * http/http urls
// * File/Blob objects
async function fetchFile(url, options) {
  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isFileReadable"])(url)) {
    return Object(_fetch_file_browser__WEBPACK_IMPORTED_MODULE_2__["default"])(url, options);
  }
  url = Object(_file_aliases__WEBPACK_IMPORTED_MODULE_1__["resolvePath"])(url);
  // TODO - SUPPORT reading from `File` objects
  return fetch(url, options);
}


/***/ }),

/***/ "../core/src/lib/fetch/file-aliases.js":
/*!*********************************************!*\
  !*** ../core/src/lib/fetch/file-aliases.js ***!
  \*********************************************/
/*! exports provided: setPathPrefix, getPathPrefix, addAliases, resolvePath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setPathPrefix", function() { return setPathPrefix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPathPrefix", function() { return getPathPrefix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addAliases", function() { return addAliases; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolvePath", function() { return resolvePath; });
// Simple file alias mechanisms for tests.

let pathPrefix = '';
const fileAliases = {};

/*
 * Set a relative path prefix
 */
function setPathPrefix(prefix) {
  pathPrefix = prefix;
}

function getPathPrefix() {
  return pathPrefix;
}

// Note: addAliases are not exported at the moment, they are only for loaders.gl testing
function addAliases(aliases) {
  Object.assign(fileAliases, aliases);
}

function resolvePath(filename) {
  for (const alias in fileAliases) {
    if (filename.startsWith(alias)) {
      const replacement = fileAliases[alias];
      return filename.replace(alias, replacement);
    }
  }
  filename += pathPrefix;
  return filename;
}


/***/ }),

/***/ "../core/src/lib/fetch/read-file.browser.js":
/*!**************************************************!*\
  !*** ../core/src/lib/fetch/read-file.browser.js ***!
  \**************************************************/
/*! exports provided: readFileSyncBrowser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readFileSyncBrowser", function() { return readFileSyncBrowser; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/assert */ "../core/src/utils/assert.js");
// TODO - this file is not tested


const DEFAULT_OPTIONS = {
  dataType: 'arraybuffer',
  // TODO - this was mostly set to true to make test cases work
  nothrow: true
};

const isDataURL = url => url.startsWith('data:');

// In a few cases (data URIs, files under Node) "files" can be read synchronously
function readFileSyncBrowser(uri, options) {
  options = getReadFileOptions(options);

  if (isDataURL(uri)) {
    // TODO - removed until decodeDataUri does not depend on Node.js Buffer
    //   return decodeDataUri(uri);
  }

  if (!options.nothrow) {
    // throw new Error('Cant load URI synchronously');
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(false);
  }

  return null;
}

// HELPER FUNCTIONS

function getReadFileOptions(options = {}) {
  options = Object.assign({}, DEFAULT_OPTIONS, options);
  options.responseType = options.responseType || options.dataType;
  return options;
}


/***/ }),

/***/ "../core/src/lib/fetch/read-file.js":
/*!******************************************!*\
  !*** ../core/src/lib/fetch/read-file.js ***!
  \******************************************/
/*! exports provided: readFileSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readFileSync", function() { return readFileSync; });
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/globals */ "../core/src/utils/globals.js");
/* harmony import */ var _node_read_file_sync_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node/read-file-sync.node */ 1);
/* harmony import */ var _node_read_file_sync_node__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_read_file_sync_node__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _file_aliases__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./file-aliases */ "../core/src/lib/fetch/file-aliases.js");
/* harmony import */ var _read_file_browser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./read-file.browser */ "../core/src/lib/fetch/read-file.browser.js");





// In a few cases (data URIs, node.js) "files" can be read synchronously
function readFileSync(url, options = {}) {
  url = Object(_file_aliases__WEBPACK_IMPORTED_MODULE_2__["resolvePath"])(url);
  if (!_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"] && _node_read_file_sync_node__WEBPACK_IMPORTED_MODULE_1__["readFileSync"]) {
    return _node_read_file_sync_node__WEBPACK_IMPORTED_MODULE_1__["readFileSync"](url, options);
  }
  return Object(_read_file_browser__WEBPACK_IMPORTED_MODULE_3__["readFileSyncBrowser"])(url, options);
}


/***/ }),

/***/ "../core/src/lib/fetch/write-file.js":
/*!*******************************************!*\
  !*** ../core/src/lib/fetch/write-file.js ***!
  \*******************************************/
/*! exports provided: writeFile, writeFileSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "writeFile", function() { return writeFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "writeFileSync", function() { return writeFileSync; });
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/globals */ "../core/src/utils/globals.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/assert */ "../core/src/utils/assert.js");
/* harmony import */ var _node_write_file_node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../node/write-file.node */ 2);
/* harmony import */ var _node_write_file_node__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_write_file_node__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _file_aliases__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./file-aliases */ "../core/src/lib/fetch/file-aliases.js");





function writeFile(filePath, arrayBufferOrString, options) {
  filePath = Object(_file_aliases__WEBPACK_IMPORTED_MODULE_3__["resolvePath"])(filePath);
  if (!_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"] && _node_write_file_node__WEBPACK_IMPORTED_MODULE_2__["writeFile"]) {
    return _node_write_file_node__WEBPACK_IMPORTED_MODULE_2__["writeFile"](filePath, arrayBufferOrString, options);
  }
  return Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(false);
}

function writeFileSync(filePath, arrayBufferOrString, options) {
  filePath = Object(_file_aliases__WEBPACK_IMPORTED_MODULE_3__["resolvePath"])(filePath);
  if (!_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"] && _node_write_file_node__WEBPACK_IMPORTED_MODULE_2__["writeFileSync"]) {
    return _node_write_file_node__WEBPACK_IMPORTED_MODULE_2__["writeFileSync"](filePath, arrayBufferOrString, options);
  }
  return Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(false);
}


/***/ }),

/***/ "../core/src/lib/load.js":
/*!*******************************!*\
  !*** ../core/src/lib/load.js ***!
  \*******************************/
/*! exports provided: loadInBatches, load */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadInBatches", function() { return loadInBatches; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "load", function() { return load; });
/* harmony import */ var _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../javascript-utils/is-type */ "../core/src/javascript-utils/is-type.js");
/* harmony import */ var _fetch_fetch_file__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fetch/fetch-file */ "../core/src/lib/fetch/fetch-file.js");
/* harmony import */ var _loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loader-utils/normalize-loader */ "../core/src/lib/loader-utils/normalize-loader.js");
/* harmony import */ var _loader_utils_normalize_options__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loader-utils/normalize-options */ "../core/src/lib/loader-utils/normalize-options.js");
/* harmony import */ var _select_loader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./select-loader */ "../core/src/lib/select-loader.js");
/* harmony import */ var _parse__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parse */ "../core/src/lib/parse.js");
/* harmony import */ var _parse_in_batches__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./parse-in-batches */ "../core/src/lib/parse-in-batches.js");









async function loadInBatches(url, loaders, options) {
  const response = await Object(_fetch_fetch_file__WEBPACK_IMPORTED_MODULE_1__["fetchFile"])(url, options);
  return Object(_parse_in_batches__WEBPACK_IMPORTED_MODULE_6__["parseInBatches"])(response, loaders, options, url);
}

// Note: Load does duplicate a lot of parse.
// Works like parse but can call `loadAndParse` for parsers that need to do their own loading
// it can also call fetchFile on string urls, which `parse` won't do.
async function load(url, loaders, options) {
  // Signature: load(url, options)
  if (!Array.isArray(loaders) && !Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_2__["isLoaderObject"])(loaders)) {
    options = loaders;
    loaders = null;
  }

  // Extract a url for auto detection
  const autoUrl = Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isFileReadable"])(url) ? url.name : url;

  // Initial loader autodection (Use registered loaders if none provided)
  // This only uses URL extensions to detect loaders.
  const loader = Object(_select_loader__WEBPACK_IMPORTED_MODULE_4__["selectLoader"])(loaders, autoUrl, null, {nothrow: true});

  if (loader) {
    // Some loaders do not separate reading and parsing of data (e.g ImageLoader)
    // These can only be handled by `load`, not `parse`
    // TODO - ImageLoaders can be rewritten to separate load and parse, phase out this variant?
    if (loader.loadAndParse) {
      const loaderOptions = Object(_loader_utils_normalize_options__WEBPACK_IMPORTED_MODULE_3__["mergeLoaderAndUserOptions"])(options, loader);
      return await loader.loadAndParse(url, loaderOptions);
    }
  }

  // at this point, data can be binary or text
  let data = url;
  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isFileReadable"])(data) || typeof data === 'string') {
    data = await Object(_fetch_fetch_file__WEBPACK_IMPORTED_MODULE_1__["fetchFile"])(url, options);
  }

  // Fall back to parse
  // Note: An improved round of autodetection is possible now that data has been loaded
  // This means that another loader might be selected
  return Object(_parse__WEBPACK_IMPORTED_MODULE_5__["parse"])(data, loaders, options, url);
}


/***/ }),

/***/ "../core/src/lib/loader-utils/check-errors.js":
/*!****************************************************!*\
  !*** ../core/src/lib/loader-utils/check-errors.js ***!
  \****************************************************/
/*! exports provided: checkFetchResponseStatus, checkFetchResponseStatusSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkFetchResponseStatus", function() { return checkFetchResponseStatus; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkFetchResponseStatusSync", function() { return checkFetchResponseStatusSync; });
async function checkFetchResponseStatus(response) {
  if (!response.ok) {
    let errorMessage = `fetch failed ${response.status} `;
    try {
      const text = await response.text();
      errorMessage += text;
    } catch (error) {
      // ignore error
    }
    throw new Error(errorMessage);
  }
}

function checkFetchResponseStatusSync(response) {
  if (!response.ok) {
    throw new Error(`fetch failed ${response.status}`);
  }
}


/***/ }),

/***/ "../core/src/lib/loader-utils/get-data.js":
/*!************************************************!*\
  !*** ../core/src/lib/loader-utils/get-data.js ***!
  \************************************************/
/*! exports provided: getUrlFromData, getArrayBufferOrStringFromDataSync, getArrayBufferOrStringFromData, getAsyncIteratorFromData, getIteratorFromData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUrlFromData", function() { return getUrlFromData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArrayBufferOrStringFromDataSync", function() { return getArrayBufferOrStringFromDataSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArrayBufferOrStringFromData", function() { return getArrayBufferOrStringFromData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAsyncIteratorFromData", function() { return getAsyncIteratorFromData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIteratorFromData", function() { return getIteratorFromData; });
/* harmony import */ var _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../javascript-utils/is-type */ "../core/src/javascript-utils/is-type.js");
/* harmony import */ var _javascript_utils_stream_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../javascript-utils/stream-utils */ "../core/src/javascript-utils/stream-utils.js");
/* harmony import */ var _fetch_fetch_file_browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../fetch/fetch-file.browser */ "../core/src/lib/fetch/fetch-file.browser.js");
/* harmony import */ var _check_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./check-errors */ "../core/src/lib/loader-utils/check-errors.js");
/* global TextDecoder */





const ERR_DATA = 'Cannot convert supplied data type';

// Extract a URL from `parse` arguments if possible
// If a fetch Response object or File/Blob were passed in get URL from those objects
function getUrlFromData(data, url) {
  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isFetchResponse"])(data)) {
    url = url || data.url;
  } else if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isFileReadable"])(url)) {
    // File or Blob
    url = url.name;
  }
  // Strip any query string
  return typeof url === 'string' ? url.replace(/\?.*/, '') : url;
}

function getArrayBufferOrStringFromDataSync(data, loader) {
  if (loader.text && typeof data === 'string') {
    return data;
  }

  if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
    const arrayBuffer = data.buffer || data;
    if (loader.text && !loader.binary) {
      const textDecoder = new TextDecoder('utf8');
      return textDecoder.decode(arrayBuffer);
    }
    return arrayBuffer;
  }

  throw new Error(ERR_DATA);
}

// Convert async iterator to a promise
async function getArrayBufferOrStringFromData(data, loader) {
  // Resolve any promise
  data = await data;

  const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);
  if (typeof data === 'string' || isArrayBuffer) {
    return getArrayBufferOrStringFromDataSync(data, loader);
  }

  // Blobs and files are FileReader compatible
  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isFileReadable"])(data)) {
    data = await Object(_fetch_fetch_file_browser__WEBPACK_IMPORTED_MODULE_2__["default"])(data);
  }

  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isFetchResponse"])(data)) {
    await Object(_check_errors__WEBPACK_IMPORTED_MODULE_3__["checkFetchResponseStatus"])(data);
    return loader.binary ? await data.arrayBuffer() : await data.text();
  }

  // if (isIterable(data) || isAsyncIterable(data)) {
  // }

  // Assume arrayBuffer iterator - attempt to concatenate
  // return concatenateAsyncIterator(data);

  throw new Error(ERR_DATA);
}

function getAsyncIteratorFromData(data) {
  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isIterator"])(data)) {
    return data;
  }

  // TODO: Our fetchFileReaderObject response does not yet support a body stream
  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isFetchResponse"])(data) && data.body) {
    // Note Since this function is not async, we currently can't load error message, just status
    Object(_check_errors__WEBPACK_IMPORTED_MODULE_3__["checkFetchResponseStatusSync"])(data);
    return Object(_javascript_utils_stream_utils__WEBPACK_IMPORTED_MODULE_1__["getStreamIterator"])(data.body);
  }

  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isReadableStream"])(data)) {
    return Object(_javascript_utils_stream_utils__WEBPACK_IMPORTED_MODULE_1__["getStreamIterator"])(data);
  }

  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isAsyncIterable"])(data)) {
    return data[Symbol.asyncIterator]();
  }

  return getIteratorFromData(data);
}

function getIteratorFromData(data) {
  // generate an iterator that emits a single chunk
  if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
    return (function* oneChunk() {
      yield data.buffer || data;
    })();
  }

  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isIterator"])(data)) {
    return data;
  }

  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isIterable"])(data)) {
    return data[Symbol.iterator]();
  }

  throw new Error(ERR_DATA);
}


/***/ }),

/***/ "../core/src/lib/loader-utils/get-loader-context.js":
/*!**********************************************************!*\
  !*** ../core/src/lib/loader-utils/get-loader-context.js ***!
  \**********************************************************/
/*! exports provided: getLoaderContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLoaderContext", function() { return getLoaderContext; });
function getLoaderContext(context, options) {
  return {
    fetch: typeof window !== 'undefined' && window.fetch,
    ...context
  };
}


/***/ }),

/***/ "../core/src/lib/loader-utils/normalize-loader.js":
/*!********************************************************!*\
  !*** ../core/src/lib/loader-utils/normalize-loader.js ***!
  \********************************************************/
/*! exports provided: isLoaderObject, normalizeLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isLoaderObject", function() { return isLoaderObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeLoader", function() { return normalizeLoader; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/assert */ "../core/src/utils/assert.js");


function isLoaderObject(loader) {
  if (!loader) {
    return false;
  }

  if (Array.isArray(loader)) {
    loader = loader[0];
  }

  const hasParser =
    loader.parseTextSync ||
    loader.parseSync ||
    loader.parse ||
    loader.loadAndParse ||
    loader.parseStream || // TODO Replace with parseInBatches
    loader.parseInBatches ||
    // loader.parseInBatchesSync || // Optimization only, parseInBatches needed
    loader.worker;

  return hasParser;
}

function normalizeLoader(loader) {
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(isLoaderObject(loader));

  // NORMALIZE [LOADER, OPTIONS] => LOADER

  // If [loader, options], create a new loaders object with options merged in
  let options;
  if (Array.isArray(loader)) {
    options = loader[1];
    loader = loader[0];
    loader = {
      ...loader,
      options: {...loader.options, ...options}
    };
  }

  // NORMALIZE LOADER.EXTENSIONS

  // Remove `extension`` prop, replace with `extensions``
  if (loader.extension) {
    loader.extensions = loader.extensions || loader.extension;
    delete loader.extension;
  }

  // Ensure loader.extensions is an array
  if (!Array.isArray(loader.extensions)) {
    loader.extensions = [loader.extensions];
  }

  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(loader.extensions && loader.extensions.length > 0 && loader.extensions[0]);

  // NORMALIZE text and binary flags

  // Ensure at least one of text/binary flags are properly set
  if (loader.parseTextSync) {
    loader.text = true;
  }

  if (!loader.text) {
    loader.binary = true;
  }

  // TODO - Does adding a default MIME type add any value?
  /*
  if (!loader.mimeType) {
    if (loader.binary) {
      // TODO - do we need separate mime types for binary and text formats?
      loader.mimeType = 'application/octet-stream';
    }
  }
  */

  return loader;
}


/***/ }),

/***/ "../core/src/lib/loader-utils/normalize-options.js":
/*!*********************************************************!*\
  !*** ../core/src/lib/loader-utils/normalize-options.js ***!
  \*********************************************************/
/*! exports provided: mergeLoaderAndUserOptions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeLoaderAndUserOptions", function() { return mergeLoaderAndUserOptions; });
/* harmony import */ var _null_log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./null-log */ "../core/src/lib/loader-utils/null-log.js");


function mergeLoaderAndUserOptions(options, loader) {
  options = Object.assign(
    {},
    loader && loader.DEFAULT_OPTIONS,
    loader && loader.defaultOptions,
    loader && loader.options,
    options,
    // TODO - explain why this option is needed for parsing
    {
      dataType: 'arraybuffer'
    }
  );

  // LOGGING

  // options.log can be set to `null` to defeat logging
  if (options.log === null) {
    options.log = new _null_log__WEBPACK_IMPORTED_MODULE_0__["default"]();
  }
  // log defaults to console
  if (!('log' in options)) {
    /* global console */
    options.log = console;
  }

  return options;
}


/***/ }),

/***/ "../core/src/lib/loader-utils/null-log.js":
/*!************************************************!*\
  !*** ../core/src/lib/loader-utils/null-log.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return NullLog; });
class NullLog {
  log() {}
  info() {}
  warn() {}
  error() {}
}


/***/ }),

/***/ "../core/src/lib/loader-utils/parse-with-worker.js":
/*!*********************************************************!*\
  !*** ../core/src/lib/loader-utils/parse-with-worker.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseWithWorker; });
/* harmony import */ var _javascript_utils_binary_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../javascript-utils/binary-utils */ "../core/src/javascript-utils/binary-utils.js");
/* harmony import */ var _worker_utils_worker_farm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../worker-utils/worker-farm */ "../core/src/worker-utils/worker-farm.js");
/* harmony import */ var _parse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parse */ "../core/src/lib/parse.js");
/* harmony import */ var _worker_utils_worker_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../worker-utils/worker-utils */ "../core/src/worker-utils/worker-utils.js");






let _workerFarm = null;

function getWorkerFarm(options = {}) {
  const props = {};
  if (options.maxConcurrency) {
    props.maxConcurrency = options.maxConcurrency;
  }
  if (options.onDebug) {
    props.onDebug = options.onDebug;
  }

  if (!_workerFarm) {
    _workerFarm = new _worker_utils_worker_farm__WEBPACK_IMPORTED_MODULE_1__["default"]({onMessage: onWorkerMessage});
  }
  _workerFarm.setProps(props);

  return _workerFarm;
}

async function onWorkerMessage({worker, data, resolve, reject}) {
  switch (data.type) {
    case 'done':
      resolve(data.result);
      break;

    case 'process':
      try {
        const result = await Object(_parse__WEBPACK_IMPORTED_MODULE_2__["parse"])(data.arraybuffer, data.options, data.url);
        worker.postMessage({type: 'process-done', id: data.id, result}, Object(_worker_utils_worker_utils__WEBPACK_IMPORTED_MODULE_3__["getTransferList"])(result));
      } catch (error) {
        worker.postMessage({type: 'process-error', id: data.id, message: error.message});
      }
      break;

    case 'error':
      reject(data.message);
      break;

    default:
    // TODO - is this not an error case? Log a warning?
  }
}

/**
 * this function expects that the worker function sends certain messages,
 * this can be automated if the worker is wrapper by a call to createWorker in @loaders.gl/loader-utils.
 */
function parseWithWorker(
  workerSource,
  workerName,
  data,
  options = {},
  context = {}
) {
  const workerFarm = getWorkerFarm(options);

  // options.log object contains functions which cannot be transferred
  // TODO - decide how to handle logging on workers
  options = JSON.parse(JSON.stringify(options));

  return workerFarm.process(workerSource, `loaders.gl-${workerName}`, {
    arraybuffer: Object(_javascript_utils_binary_utils__WEBPACK_IMPORTED_MODULE_0__["toArrayBuffer"])(data),
    options,
    source: 'loaders.gl', // Lets worker ignore unrelated messages
    type: 'process' // For future extension
  });
}


/***/ }),

/***/ "../core/src/lib/parse-in-batches-sync.js":
/*!************************************************!*\
  !*** ../core/src/lib/parse-in-batches-sync.js ***!
  \************************************************/
/*! exports provided: parseInBatchesSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseInBatchesSync", function() { return parseInBatchesSync; });
/* harmony import */ var _loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loader-utils/normalize-loader */ "../core/src/lib/loader-utils/normalize-loader.js");
/* harmony import */ var _loader_utils_normalize_options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loader-utils/normalize-options */ "../core/src/lib/loader-utils/normalize-options.js");
/* harmony import */ var _loader_utils_get_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loader-utils/get-data */ "../core/src/lib/loader-utils/get-data.js");
/* harmony import */ var _loader_utils_get_loader_context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loader-utils/get-loader-context */ "../core/src/lib/loader-utils/get-loader-context.js");
/* harmony import */ var _select_loader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./select-loader */ "../core/src/lib/select-loader.js");






// TODO - remove?
async function parseInBatchesSync(data, loaders, options, url) {
  // Signature: parseInBatchesSync(data, options, url)
  // Uses registered loaders
  if (!Array.isArray(loaders) && !Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_0__["isLoaderObject"])(loaders)) {
    url = options;
    options = loaders;
    loaders = null;
  }

  // Chooses a loader and normalizes it
  // TODO - only uses URL, need a selectLoader variant that peeks at first stream chunk...
  const loader = Object(_select_loader__WEBPACK_IMPORTED_MODULE_4__["selectLoader"])(loaders, url, null);

  // Normalize options
  options = Object(_loader_utils_normalize_options__WEBPACK_IMPORTED_MODULE_1__["mergeLoaderAndUserOptions"])(options, loader);

  const context = Object(_loader_utils_get_loader_context__WEBPACK_IMPORTED_MODULE_3__["getLoaderContext"])({url}, options);

  return parseWithLoaderInBatchesSync(loader, data, options, context);
}

function parseWithLoaderInBatchesSync(loader, data, options, context) {
  // Create async iterator adapter for data, and concatenate result
  if (loader.parseInBatchesSync) {
    const inputIterator = Object(_loader_utils_get_data__WEBPACK_IMPORTED_MODULE_2__["getIteratorFromData"])(data);
    const outputIterator = loader.parseInBatchesSync(inputIterator, options, context, loader);
    return outputIterator;
  }

  throw new Error('parseWithLoaderInBatchesSync not available');
}


/***/ }),

/***/ "../core/src/lib/parse-in-batches.js":
/*!*******************************************!*\
  !*** ../core/src/lib/parse-in-batches.js ***!
  \*******************************************/
/*! exports provided: parseInBatches */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseInBatches", function() { return parseInBatches; });
/* harmony import */ var _loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loader-utils/normalize-loader */ "../core/src/lib/loader-utils/normalize-loader.js");
/* harmony import */ var _loader_utils_normalize_options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loader-utils/normalize-options */ "../core/src/lib/loader-utils/normalize-options.js");
/* harmony import */ var _loader_utils_get_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loader-utils/get-data */ "../core/src/lib/loader-utils/get-data.js");
/* harmony import */ var _loader_utils_get_loader_context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loader-utils/get-loader-context */ "../core/src/lib/loader-utils/get-loader-context.js");
/* harmony import */ var _select_loader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./select-loader */ "../core/src/lib/select-loader.js");






async function parseInBatches(data, loaders, options, url) {
  // Signature: parseInBatches(data, options, url)
  // Uses registered loaders
  if (!Array.isArray(loaders) && !Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_0__["isLoaderObject"])(loaders)) {
    url = options;
    options = loaders;
    loaders = null;
  }

  // Chooses a loader and normalizes it
  // TODO - only uses URL, need a selectLoader variant that peeks at first stream chunk...
  const loader = Object(_select_loader__WEBPACK_IMPORTED_MODULE_4__["selectLoader"])(loaders, url, null);

  // Normalize options
  options = Object(_loader_utils_normalize_options__WEBPACK_IMPORTED_MODULE_1__["mergeLoaderAndUserOptions"])(options, loader);

  const context = Object(_loader_utils_get_loader_context__WEBPACK_IMPORTED_MODULE_3__["getLoaderContext"])({url}, options);

  return parseWithLoaderInBatches(loader, data, options, context);
}

function parseWithLoaderInBatches(loader, data, options, context) {
  // Create async iterator adapter for data, and concatenate result
  if (loader.parseInBatches) {
    const inputIterator = Object(_loader_utils_get_data__WEBPACK_IMPORTED_MODULE_2__["getAsyncIteratorFromData"])(data);
    const outputIterator = loader.parseInBatches(inputIterator, options, context, loader);
    return outputIterator;
  }

  throw new Error('parseWithLoaderInBatchesSync not available');
}


/***/ }),

/***/ "../core/src/lib/parse-sync.js":
/*!*************************************!*\
  !*** ../core/src/lib/parse-sync.js ***!
  \*************************************/
/*! exports provided: parseSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseSync", function() { return parseSync; });
/* harmony import */ var _select_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select-loader */ "../core/src/lib/select-loader.js");
/* harmony import */ var _loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loader-utils/normalize-loader */ "../core/src/lib/loader-utils/normalize-loader.js");
/* harmony import */ var _loader_utils_normalize_options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loader-utils/normalize-options */ "../core/src/lib/loader-utils/normalize-options.js");
/* harmony import */ var _loader_utils_get_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loader-utils/get-data */ "../core/src/lib/loader-utils/get-data.js");
/* harmony import */ var _loader_utils_get_loader_context__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./loader-utils/get-loader-context */ "../core/src/lib/loader-utils/get-loader-context.js");






function parseSync(data, loaders, options, url) {
  // Signature: parseSync(data, options, url)
  // Uses registered loaders
  if (!Array.isArray(loaders) && !Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_1__["isLoaderObject"])(loaders)) {
    url = options;
    options = loaders;
    loaders = null;
  }

  // Chooses a loader and normalize it
  const loader = Object(_select_loader__WEBPACK_IMPORTED_MODULE_0__["selectLoader"])(loaders, url, data);
  // Note: if nothrow option was set, it is possible that no loader was found, if so just return null
  if (!loader) {
    return null;
  }

  // Normalize options
  options = Object(_loader_utils_normalize_options__WEBPACK_IMPORTED_MODULE_2__["mergeLoaderAndUserOptions"])(options, loader);

  const context = Object(_loader_utils_get_loader_context__WEBPACK_IMPORTED_MODULE_4__["getLoaderContext"])({url, parseSync}, options);

  return parseWithLoaderSync(loader, data, options, context);
}

// TODO - should accept loader.parseSync/parse and generate 1 chunk asyncIterator
function parseWithLoaderSync(loader, data, options, context) {
  data = Object(_loader_utils_get_data__WEBPACK_IMPORTED_MODULE_3__["getArrayBufferOrStringFromDataSync"])(data, loader);

  if (loader.parseTextSync && typeof data === 'string') {
    return loader.parseTextSync(data, options, context, loader);
  }

  if (loader.parseSync) {
    return loader.parseSync(data, options, context, loader);
  }

  // TBD - If synchronous parser not available, return null
  throw new Error(`Could not parse ${context.url || 'data'} using ${loader.name} loader`);
}


/***/ }),

/***/ "../core/src/lib/parse.js":
/*!********************************!*\
  !*** ../core/src/lib/parse.js ***!
  \********************************/
/*! exports provided: parse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "../core/src/utils/assert.js");
/* harmony import */ var _loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loader-utils/normalize-loader */ "../core/src/lib/loader-utils/normalize-loader.js");
/* harmony import */ var _loader_utils_normalize_options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loader-utils/normalize-options */ "../core/src/lib/loader-utils/normalize-options.js");
/* harmony import */ var _loader_utils_get_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loader-utils/get-data */ "../core/src/lib/loader-utils/get-data.js");
/* harmony import */ var _loader_utils_get_loader_context__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./loader-utils/get-loader-context */ "../core/src/lib/loader-utils/get-loader-context.js");
/* harmony import */ var _loader_utils_parse_with_worker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./loader-utils/parse-with-worker */ "../core/src/lib/loader-utils/parse-with-worker.js");
/* harmony import */ var _select_loader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./select-loader */ "../core/src/lib/select-loader.js");









async function parse(data, loaders, options, url) {
  // Signature: parse(data, options, url)
  // Uses registered loaders
  if (loaders && !Array.isArray(loaders) && !Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_1__["isLoaderObject"])(loaders)) {
    url = options;
    options = loaders;
    loaders = null;
  }

  options = options || {};

  // Extract a url for auto detection
  const autoUrl = Object(_loader_utils_get_data__WEBPACK_IMPORTED_MODULE_3__["getUrlFromData"])(data, url);

  // Chooses a loader and normalize it
  const loader = Object(_select_loader__WEBPACK_IMPORTED_MODULE_6__["selectLoader"])(loaders, autoUrl, data);

  // Normalize options
  options = Object(_loader_utils_normalize_options__WEBPACK_IMPORTED_MODULE_2__["mergeLoaderAndUserOptions"])(options, loader);

  const context = Object(_loader_utils_get_loader_context__WEBPACK_IMPORTED_MODULE_4__["getLoaderContext"])({url: autoUrl, parse}, options);

  return await parseWithLoader(loader, data, options, context);
}

// TODO: support progress and abort
// TODO: support moving loading to worker
// TODO - should accept loader.parseAsyncIterator and concatenate.
async function parseWithLoader(loader, data, options, context) {
  data = await Object(_loader_utils_get_data__WEBPACK_IMPORTED_MODULE_3__["getArrayBufferOrStringFromData"])(data, loader);

  // First check for synchronous text parser, wrap results in promises
  if (loader.parseTextSync && typeof data === 'string') {
    options.dataType = 'text';
    return loader.parseTextSync(data, options, context, loader);
  }

  // Check for asynchronous parser
  if (loader.parse) {
    return await loader.parse(data, options, context, loader);
  }

  // Now check for synchronous binary data parser, wrap results in promises
  if (loader.parseSync) {
    return loader.parseSync(data, options, context, loader);
  }

  if (loader.worker) {
    return await Object(_loader_utils_parse_with_worker__WEBPACK_IMPORTED_MODULE_5__["default"])(loader.worker, loader.name, data, options, context, loader);
  }

  // TBD - If asynchronous parser not available, return null
  // => This loader does not work on loaded data and only supports `loadAndParseAsync`
  return Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(false);
}


/***/ }),

/***/ "../core/src/lib/path/path.js":
/*!************************************!*\
  !*** ../core/src/lib/path/path.js ***!
  \************************************/
/*! exports provided: dirname */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dirname", function() { return dirname; });
// Beginning of a minimal implementation of the Node.js path API, that doesn't pull in big polyfills.
function dirname(url) {
  const slashIndex = url && url.lastIndexOf('/');
  return slashIndex >= 0 ? url.substr(0, slashIndex) : '';
}


/***/ }),

/***/ "../core/src/lib/progress/fetch-progress.js":
/*!**************************************************!*\
  !*** ../core/src/lib/progress/fetch-progress.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return fetchProgress; });
// Forked from github AnthumChris/fetch-progress-indicators under MIT license
/* global Response, ReadableStream */

// Intercepts the Response stream and creates a new Response
async function fetchProgress(
  response,
  onProgress,
  onDone = () => {},
  onError = () => {}
) {
  response = await response;
  if (!response.ok) {
    // ERROR checking needs to be done separately
    return response;
  }
  if (!response.body) {
    // 'ReadableStream not yet supported in this browser.
    return response;
  }
  const contentLength = response.headers.get('content-length');
  const totalBytes = contentLength && parseInt(contentLength, 10);
  if (!(contentLength > 0)) {
    return response;
  }
  // Currently override only implemented in browser
  if (typeof ReadableStream === 'undefined') {
    return response;
  }

  // Create a new stream that invisbly wraps original stream
  const progressStream = new ReadableStream({
    start(controller) {
      const reader = response.body.getReader();
      read(controller, reader, 0, totalBytes, onProgress, onDone, onError);
    }
  });

  return new Response(progressStream);
}

// Forward to original streams controller
// TODO - this causes a crazy deep "async stack"... rewrite as async iterator?
// eslint-disable-next-line max-params
async function read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError) {
  try {
    const {done, value} = await reader.read();
    if (done) {
      onDone();
      controller.close();
      return;
    }
    loadedBytes += value.byteLength;
    const percent = Math.round((loadedBytes / totalBytes) * 100);
    onProgress(percent, {loadedBytes, totalBytes});
    controller.enqueue(value);
    await read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError);
  } catch (error) {
    controller.error(error);
    onError(error);
  }
}


/***/ }),

/***/ "../core/src/lib/register-loaders.js":
/*!*******************************************!*\
  !*** ../core/src/lib/register-loaders.js ***!
  \*******************************************/
/*! exports provided: registerLoaders, getRegisteredLoaders, _unregisterLoaders */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerLoaders", function() { return registerLoaders; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRegisteredLoaders", function() { return getRegisteredLoaders; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_unregisterLoaders", function() { return _unregisterLoaders; });
/* harmony import */ var _loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loader-utils/normalize-loader */ "../core/src/lib/loader-utils/normalize-loader.js");


let registeredLoaders = [];

function registerLoaders(loaders) {
  loaders = Array.isArray(loaders) ? loaders : [loaders];

  for (const loader of loaders) {
    const normalizedLoader = Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_0__["normalizeLoader"])(loader);
    if (!registeredLoaders.find(registeredLoader => normalizedLoader === registeredLoader)) {
      // add to the beginning of the registeredLoaders, so the last registeredLoader get picked
      registeredLoaders.unshift(normalizedLoader);
    }
  }
}

function getRegisteredLoaders() {
  return registeredLoaders;
}

// For testing
function _unregisterLoaders() {
  registeredLoaders = [];
}


/***/ }),

/***/ "../core/src/lib/save.js":
/*!*******************************!*\
  !*** ../core/src/lib/save.js ***!
  \*******************************/
/*! exports provided: save, saveSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "save", function() { return save; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saveSync", function() { return saveSync; });
/* harmony import */ var _encode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./encode */ "../core/src/lib/encode.js");
/* harmony import */ var _fetch_write_file__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fetch/write-file */ "../core/src/lib/fetch/write-file.js");



function save(data, url, writer, options) {
  const encodedData = Object(_encode__WEBPACK_IMPORTED_MODULE_0__["encode"])(data, writer, options, url);
  return Object(_fetch_write_file__WEBPACK_IMPORTED_MODULE_1__["writeFile"])(url, encodedData);
}

function saveSync(data, url, writer, options) {
  const encodedData = Object(_encode__WEBPACK_IMPORTED_MODULE_0__["encodeSync"])(data, writer, options, url);
  return Object(_fetch_write_file__WEBPACK_IMPORTED_MODULE_1__["writeFileSync"])(url, encodedData);
}


/***/ }),

/***/ "../core/src/lib/select-loader.js":
/*!****************************************!*\
  !*** ../core/src/lib/select-loader.js ***!
  \****************************************/
/*! exports provided: selectLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selectLoader", function() { return selectLoader; });
/* harmony import */ var _register_loaders__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./register-loaders */ "../core/src/lib/register-loaders.js");
/* harmony import */ var _loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loader-utils/normalize-loader */ "../core/src/lib/loader-utils/normalize-loader.js");



const EXT_PATTERN = /\.([^.]+)$/;
const DATA_URL_PATTERN = /^data:(.*?)(;|,)/;

// Find a loader that matches file extension and/or initial file content
// Search the loaders array argument for a loader that matches url extension or initial data
// Returns: a normalized loader

// TODO - Need a variant that peeks at streams for parseInBatches
// TODO - Detect multiple matching loaders? Use heuristics to grade matches?
// TODO - Allow apps to pass context to disambiguate between multiple matches (e.g. multiple .json formats)?

function selectLoader(loaders, url = '', data = null, {nothrow = false} = {}) {
  url = url || '';

  // if only a single loader was provided (not as array), force its use
  // TODO - Should this behaviour be kept and documented?
  if (loaders && !Array.isArray(loaders)) {
    const loader = loaders;
    Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_1__["normalizeLoader"])(loader);
    return loader;
  }

  // If no loaders provided, get the registered loaders
  loaders = loaders || Object(_register_loaders__WEBPACK_IMPORTED_MODULE_0__["getRegisteredLoaders"])();
  normalizeLoaders(loaders);

  url = url.replace(/\?.*/, '');
  let loader = null;
  loader = loader || findLoaderByUrl(loaders, url);
  loader = loader || findLoaderByExamingInitialData(loaders, data);

  // no loader available
  if (!loader) {
    if (nothrow) {
      return null;
    }
    throw new Error(`No valid loader found for ${url}`);
  }

  return loader;
}

function normalizeLoaders(loaders) {
  for (const loader of loaders) {
    Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_1__["normalizeLoader"])(loader);
  }
}

// TODO - Would be nice to support http://example.com/file.glb?parameter=1
// E.g: x = new URL('http://example.com/file.glb?load=1'; x.pathname
function findLoaderByUrl(loaders, url) {
  // Check for data url
  let match = url.match(DATA_URL_PATTERN);
  const mimeType = match && match[1];
  if (mimeType) {
    return findLoaderByMimeType(loaders, mimeType);
  }
  // Get extension
  match = url.match(EXT_PATTERN);
  const extension = match && match[1];
  const loader = extension && findLoaderByExtension(loaders, extension);
  return loader;
}

function findLoaderByMimeType(loaders, mimeType) {
  for (const loader of loaders) {
    if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {
      return loader;
    }
  }
  return null;
}

function findLoaderByExtension(loaders, extension) {
  extension = extension.toLowerCase();

  for (const loader of loaders) {
    for (const loaderExtension of loader.extensions) {
      if (loaderExtension.toLowerCase() === extension) {
        return loader;
      }
    }
  }
  return null;
}

function findLoaderByExamingInitialData(loaders, data) {
  if (!data) {
    return null;
  }

  for (const loader of loaders) {
    if (typeof data === 'string') {
      if (testText(data, loader)) {
        return loader;
      }
    } else if (ArrayBuffer.isView(data)) {
      // Typed Arrays can have offsets into underlying buffer
      if (testBinary(data.buffer, data.byteOffset, loader)) {
        return loader;
      }
    } else if (data instanceof ArrayBuffer) {
      const byteOffset = 0;
      if (testBinary(data, byteOffset, loader)) {
        return loader;
      }
    }
    // TODO Handle streaming case (requires creating a new AsyncIterator)
  }
  return null;
}

function testText(data, loader) {
  return loader.testText && loader.testText(data);
}

function testBinary(data, byteOffset, loader) {
  const type = Array.isArray(loader.test) ? 'array' : typeof loader.test;
  switch (type) {
    case 'function':
      return loader.test(data, loader);

    case 'string':
    case 'array':
      // Magic bytes check: If `loader.test` is a string or array of strings,
      // check if binary data starts with one of those strings
      const tests = Array.isArray(loader.test) ? loader.test : [loader.test];
      return tests.some(test => {
        const magic = getMagicString(data, byteOffset, test.length);
        return test === magic;
      });

    default:
      return false;
  }
}

function getMagicString(arrayBuffer, byteOffset, length) {
  if (arrayBuffer.byteLength <= byteOffset + length) {
    return '';
  }
  const dataView = new DataView(arrayBuffer);
  let magic = '';
  for (let i = 0; i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }
  return magic;
}


/***/ }),

/***/ "../core/src/utils/assert.js":
/*!***********************************!*\
  !*** ../core/src/utils/assert.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
// Replacement for the external assert method to reduce bundle size
// Note: We don't use the second "message" argument in calling code,
// so no need to support it here
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loader assertion failed.');
  }
}


/***/ }),

/***/ "../core/src/utils/globals.js":
/*!************************************!*\
  !*** ../core/src/utils/globals.js ***!
  \************************************/
/*! exports provided: isBrowser, self, window, global, document, nodeVersion */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process, global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return isBrowser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "self", function() { return self_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "window", function() { return window_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "global", function() { return global_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "document", function() { return document_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nodeVersion", function() { return nodeVersion; });
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Purpose: include this in your module to avoids adding dependencies on
// micro modules like 'global' and 'is-browser';

/* eslint-disable no-restricted-globals */
/* global process, window, global, document */
const isBrowser =
  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;

/* global self, window, global, document */
const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};

const self_ = globals.self || globals.window || globals.global;
const window_ = globals.window || globals.self || globals.global;
const global_ = globals.global || globals.self || globals.window;
const document_ = globals.document || {};



// Extract node version
const matches =
  typeof process !== 'undefined' && process.version && process.version.match(/v([0-9]*)/);
const nodeVersion = (matches && parseFloat(matches[1])) || 0;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/process/browser.js */ "../../node_modules/process/browser.js"), __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../core/src/worker-utils/worker-farm.js":
/*!***********************************************!*\
  !*** ../core/src/worker-utils/worker-farm.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorkerFarm; });
/* harmony import */ var _worker_pool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-pool */ "../core/src/worker-utils/worker-pool.js");


const DEFAULT_MAX_CONCURRENCY = 5;

/**
 * Process multiple data messages with a "farm" of different workers (in worker pools)
 */
class WorkerFarm {
  /**
   * @param processor {function | string} - worker function
   * @param maxConcurrency {number} - max count of workers
   */
  constructor({maxConcurrency = DEFAULT_MAX_CONCURRENCY, onMessage, onDebug = () => {}}) {
    this.maxConcurrency = maxConcurrency;
    this.onMessage = onMessage;
    this.onDebug = onDebug;
    this.workerPools = new Map();
  }

  setProps(props) {
    if ('maxConcurrency' in props) {
      this.maxConcurrency = props.maxConcurrency;
    }

    if ('onDebug' in props) {
      this.onDebug = props.onDebug;
    }
  }

  destroy() {
    this.workerPools.forEach(workerPool => workerPool.destroy());
  }

  /**
   * Process binary data in a worker
   * @param data {data containing binary typed arrays} - data to be transferred to worker
   * @returns a Promise with data containing typed arrays transferred back from work
   */
  async process(workerSource, workerName, data) {
    const workerPool = this._getWorkerPool(workerSource, workerName);
    return workerPool.process(data);
  }

  // PRIVATE

  _getWorkerPool(workerSource, workerName) {
    let workerPool = this.workerPools.get(workerName);
    if (!workerPool) {
      workerPool = new _worker_pool__WEBPACK_IMPORTED_MODULE_0__["default"]({
        source: workerSource,
        name: workerName,
        onMessage: this.onMessage,
        maxConcurrency: this.maxConcurrency,
        onDebug: this.onDebug
      });
      this.workerPools.set(workerName, workerPool);
    }
    return workerPool;
  }
}


/***/ }),

/***/ "../core/src/worker-utils/worker-pool.js":
/*!***********************************************!*\
  !*** ../core/src/worker-utils/worker-pool.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorkerPool; });
/* harmony import */ var _worker_thread__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-thread */ "../core/src/worker-utils/worker-thread.js");


/**
 * Process multiple data messages with small pool of identical workers
 */
class WorkerPool {
  /**
   * @param processor {function | string} - worker function
   * @param maxConcurrency {number} - max count of workers
   */
  constructor({source, name = 'unnamed', maxConcurrency = 1, onMessage, onDebug = () => {}}) {
    this.source = source;
    this.name = name;
    this.maxConcurrency = maxConcurrency;
    this.onMessage = onMessage;
    this.onDebug = onDebug;

    this.jobQueue = [];
    this.idleQueue = [];
    this.count = 0;
    this.isDestroyed = false;
  }

  destroy() {
    // Destroy idle workers, active Workers will be destroyed on completion
    this.idleQueue.forEach(worker => worker.destroy());
    this.isDestroyed = true;
  }

  /**
   * Process binary data in a worker
   * @param data {data containing binary typed arrays} - data to be transferred to worker
   * @returns a Promise with data containing typed arrays transferred back from work
   */
  async process(data, jobName) {
    return new Promise((resolve, reject) => {
      this.jobQueue.push({data, jobName, resolve, reject});
      this._startQueuedJob();
    });
  }

  // PRIVATE

  _startQueuedJob() {
    if (!this.jobQueue.length) {
      return;
    }
    const worker = this._getAvailableWorker();
    if (!worker) {
      return;
    }

    // We have a worker, dequeue and start the job
    const job = this.jobQueue.shift();

    this.onDebug({
      message: 'processing',
      worker: worker.name,
      job: job.jobName,
      backlog: this.jobQueue.length
    });

    worker
      .process(job.data)
      .then(result => job.resolve(result))
      .catch(error => job.reject(error))
      .then(() => this._onWorkerDone(worker));
  }

  _onWorkerDone(worker) {
    if (this.isDestroyed) {
      worker.destroy();
    } else {
      this.idleQueue.push(worker);
      this._startQueuedJob();
    }
  }

  _getAvailableWorker() {
    // If a worker has completed and returned to the queue, it can be used
    if (this.idleQueue.length > 0) {
      return this.idleQueue.shift();
    }

    // Create fresh worker if we haven't yet created the max amount of worker threads for this worker source
    if (this.count < this.maxConcurrency) {
      this.count++;
      const name = `${this.name.toLowerCase()}-worker-${this.count}-of-${this.maxConcurrency}`;
      return new _worker_thread__WEBPACK_IMPORTED_MODULE_0__["default"]({source: this.source, onMessage: this.onMessage, name});
    }

    // No worker available, have to wait
    return null;
  }
}


/***/ }),

/***/ "../core/src/worker-utils/worker-thread.js":
/*!*************************************************!*\
  !*** ../core/src/worker-utils/worker-thread.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorkerThread; });
/* harmony import */ var _worker_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-utils */ "../core/src/worker-utils/worker-utils.js");
/* global Worker */


let count = 0;

// By default resolves to the first message the worker sends back
function defaultOnMessage({data, resolve}) {
  resolve(data);
}

class WorkerThread {
  constructor({source, name = `web-worker-${count++}`, onMessage}) {
    const url = Object(_worker_utils__WEBPACK_IMPORTED_MODULE_0__["getWorkerURL"])(source);
    this.worker = new Worker(url, {name});
    this.name = name;
    this.onMessage = onMessage || defaultOnMessage;
  }

  /**
   * Process binary data in a worker
   * @param data {data containing binary typed arrays} - data to be transferred to worker
   * @returns a Promise with data containing typed arrays transferred back from work
   */
  async process(data) {
    return new Promise((resolve, reject) => {
      this.worker.onmessage = event =>
        this.onMessage({worker: this.worker, data: event.data, resolve, reject});
      this.worker.onerror = error => reject(error);
      const transferList = Object(_worker_utils__WEBPACK_IMPORTED_MODULE_0__["getTransferList"])(data);
      this.worker.postMessage(data, transferList);
    });
  }

  destroy() {
    this.worker.terminate();
    this.worker = null;
  }
}


/***/ }),

/***/ "../core/src/worker-utils/worker-utils.js":
/*!************************************************!*\
  !*** ../core/src/worker-utils/worker-utils.js ***!
  \************************************************/
/*! exports provided: getTransferList, getWorkerURL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTransferList", function() { return getTransferList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getWorkerURL", function() { return getWorkerURL; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "../core/src/utils/assert.js");
/* global URL, Blob */


function getTransferList(object, recursive = true, transfers = []) {
  if (!object) {
    // ignore
  } else if (object instanceof ArrayBuffer) {
    transfers.push(object);
  } else if (object.buffer && object.buffer instanceof ArrayBuffer) {
    // Typed array
    transfers.push(object.buffer);
  } else if (recursive && typeof object === 'object') {
    for (const key in object) {
      // Avoid perf hit - only go one level deep
      getTransferList(object[key], recursive, transfers);
    }
  }
  return transfers;
}

const workerURLCache = new Map();

// Creates a URL from worker source that can be used to create `Worker` instances
// Packages (and then caches) the result of `webworkify` as an "Object URL"
function getWorkerURL(workerSource) {
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(typeof workerSource === 'string', 'worker source');

  // url(./worker.js)
  // This pattern is used to differentiate worker urls from worker source code
  // Load from url is needed for testing, when using Webpack & webworker target
  if (workerSource.startsWith('url(') && workerSource.endsWith(')')) {
    return workerSource.match(/^url\((.*)\)$/)[1];
  }

  let workerURL = workerURLCache.get(workerSource);

  if (!workerURL) {
    const blob = new Blob([workerSource], {type: 'application/javascript'});
    // const blob = webworkify(workerSource, {bare: true});
    workerURL = URL.createObjectURL(blob);
    workerURLCache.set(workerSource, workerURL);
  }

  return workerURL;
}


/***/ }),

/***/ "../images/src/image-loader.js":
/*!*************************************!*\
  !*** ../images/src/image-loader.js ***!
  \*************************************/
/*! exports provided: default, ImageBitmapLoader, HTMLImageLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageBitmapLoader", function() { return ImageBitmapLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HTMLImageLoader", function() { return HTMLImageLoader; });
/* harmony import */ var _lib_parse_image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/parse-image */ "../images/src/lib/parse-image.js");
/* global Image */


const EXTENSIONS = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'ico', 'svg'];
const MIME_TYPES = [
  'image/png',
  'image/jpeg',
  'image/gif',
  'image/webp',
  'image/bmp',
  'image/vndmicrosofticon',
  'image/svg+xml'
];

// Loads a platform-specific image type that can be used as input data to WebGL textures
/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'Images',
  mimeTypes: MIME_TYPES,
  extensions: EXTENSIONS,
  parse: _lib_parse_image__WEBPACK_IMPORTED_MODULE_0__["canParseImage"] && _lib_parse_image__WEBPACK_IMPORTED_MODULE_0__["parseImage"],
  loadAndParse: typeof Image !== 'undefined' && _lib_parse_image__WEBPACK_IMPORTED_MODULE_0__["loadToHTMLImage"]
});

// EXPERIMENTAL

// Specifically loads an ImageBitmap (works on newer browsers, on both main and worker threads)
const ImageBitmapLoader = {
  mimeTypes: MIME_TYPES,
  extensions: EXTENSIONS,
  parse: _lib_parse_image__WEBPACK_IMPORTED_MODULE_0__["parseToImageBitmap"]
};

// Specifically loads an HTMLImage (works on all browsers' main thread but not on worker threads)
const HTMLImageLoader = {
  mimeTypes: MIME_TYPES,
  extensions: EXTENSIONS,
  loadAndParse: _lib_parse_image__WEBPACK_IMPORTED_MODULE_0__["loadToHTMLImage"]
};


/***/ }),

/***/ "../images/src/image-writer.js":
/*!*************************************!*\
  !*** ../images/src/image-writer.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_encode_image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/encode-image */ "../images/src/lib/encode-image.js");


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'Images',
  extensions: ['jpeg'],
  encode: _lib_encode_image__WEBPACK_IMPORTED_MODULE_0__["encodeImage"],
  DEFAULT_OPTIONS: {
    type: 'png'
  }
});


/***/ }),

/***/ "../images/src/index.js":
/*!******************************!*\
  !*** ../images/src/index.js ***!
  \******************************/
/*! exports provided: ImageLoader, HTMLImageLoader, ImageBitmapLoader, ImageWriter, loadImage, isImage, getImageMetadata, getImageMIMEType, getImageSize, decodeImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _image_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./image-loader */ "../images/src/image-loader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ImageLoader", function() { return _image_loader__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HTMLImageLoader", function() { return _image_loader__WEBPACK_IMPORTED_MODULE_0__["HTMLImageLoader"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ImageBitmapLoader", function() { return _image_loader__WEBPACK_IMPORTED_MODULE_0__["ImageBitmapLoader"]; });

/* harmony import */ var _image_writer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./image-writer */ "../images/src/image-writer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ImageWriter", function() { return _image_writer__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _lib_parse_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/parse-image */ "../images/src/lib/parse-image.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadImage", function() { return _lib_parse_image__WEBPACK_IMPORTED_MODULE_2__["loadImage"]; });

/* harmony import */ var _lib_get_image_metadata__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/get-image-metadata */ "../images/src/lib/get-image-metadata.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isImage", function() { return _lib_get_image_metadata__WEBPACK_IMPORTED_MODULE_3__["isImage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getImageMetadata", function() { return _lib_get_image_metadata__WEBPACK_IMPORTED_MODULE_3__["getImageMetadata"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getImageMIMEType", function() { return _lib_get_image_metadata__WEBPACK_IMPORTED_MODULE_3__["getImageMIMEType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getImageSize", function() { return _lib_get_image_metadata__WEBPACK_IMPORTED_MODULE_3__["getImageSize"]; });

/* harmony import */ var _lib_image_utils_browser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/image-utils-browser */ "../images/src/lib/image-utils-browser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "decodeImage", function() { return _lib_image_utils_browser__WEBPACK_IMPORTED_MODULE_4__["decodeImage"]; });






// UTILS


// Experimental



/***/ }),

/***/ "../images/src/lib/encode-image.js":
/*!*****************************************!*\
  !*** ../images/src/lib/encode-image.js ***!
  \*****************************************/
/*! exports provided: encodeImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeImage", function() { return encodeImage; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "../images/src/utils/assert.js");
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/globals */ "../images/src/utils/globals.js");
// Image loading/saving for browser
/* global document, HTMLCanvasElement, Image */




// Returns data bytes representing a compressed image in PNG or JPG format,
// This data can be saved using file system (f) methods or
// used in a request.
// @param {Image}  image - Image or Canvas
// @param {String} opt.type='png' - png, jpg or image/png, image/jpg are valid
// @param {String} opt.dataURI= - Whether to include a data URI header

function encodeImage(image, type) {
  if (_utils_globals__WEBPACK_IMPORTED_MODULE_1__["global"]._encodeImageNode) {
    return _utils_globals__WEBPACK_IMPORTED_MODULE_1__["global"]._encodeImageNode(image, type);
  }

  if (image instanceof HTMLCanvasElement) {
    const canvas = image;
    return canvas.toDataURL(type);
  }

  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(image instanceof Image, 'getImageData accepts image or canvas');
  const canvas = document.createElement('canvas');
  canvas.width = image.width;
  canvas.height = image.height;
  canvas.getContext('2d').drawImage(image, 0, 0);

  // Get raw image data
  const data = canvas.toDataURL(type || 'png').replace(/^data:image\/(png|jpg);base64,/, '');
  return Promise.resolve(data);
}


/***/ }),

/***/ "../images/src/lib/get-image-metadata.js":
/*!***********************************************!*\
  !*** ../images/src/lib/get-image-metadata.js ***!
  \***********************************************/
/*! exports provided: isImage, getImageMIMEType, getImageSize, getImageMetadata */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isImage", function() { return isImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImageMIMEType", function() { return getImageMIMEType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImageSize", function() { return getImageSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImageMetadata", function() { return getImageMetadata; });
/* harmony import */ var _image_parsers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./image-parsers */ "../images/src/lib/image-parsers.js");
// Attributions
// * Based on binary-gltf-utils under MIT license: Copyright (c) 2016-17 Karl Cheng

// TODO: make these functions work for Node.js buffers?
// Quarantine references to Buffer to prevent bundler from adding big polyfills
// import {bufferToArrayBuffer} from '../node/buffer-to-array-buffer';
// TODO - this should be handled in @loaders.gl/polyfills



const ERR_INVALID_MIME_TYPE = `Invalid MIME type. Supported MIME types are: ${Array.from(
  _image_parsers__WEBPACK_IMPORTED_MODULE_0__["mimeTypeMap"].keys()
).join(', ')}`;

// Supported image types are PNG, JPEG, GIF and BMP.
function isImage(arrayBuffer, mimeType) {
  if (mimeType) {
    const {test} = getImageTypeHandlers(mimeType);
    const dataView = toDataView(arrayBuffer);
    return test(dataView);
  }
  // check if known type
  return Boolean(getImageMIMEType(arrayBuffer));
}

// Sniffs the contents of a file to attempt to deduce the image type
function getImageMIMEType(arrayBuffer) {
  const dataView = toDataView(arrayBuffer);

  // Loop through each file type and see if they work.
  for (const [mimeType, {test}] of _image_parsers__WEBPACK_IMPORTED_MODULE_0__["mimeTypeMap"].entries()) {
    if (test(dataView)) {
      return mimeType;
    }
  }

  return null;
}

function getImageSize(arrayBuffer, mimeType = null) {
  mimeType = mimeType || getImageMIMEType(arrayBuffer);

  const {getSize} = getImageTypeHandlers(mimeType);

  const dataView = toDataView(arrayBuffer);
  const size = getSize(dataView);

  if (!size) {
    throw new Error(`invalid image data for type: ${mimeType}`);
  }

  return size;
}

// Sniffs the contents of a file to attempt to deduce the image type and size.
// Supported image types are PNG, JPEG, GIF and BMP.
function getImageMetadata(arrayBuffer, mimeType = null) {
  mimeType = mimeType || getImageMIMEType(arrayBuffer);

  const metadata = getImageSize(arrayBuffer, mimeType);
  metadata.mimeType = mimeType;
  return metadata;
}

function getImageTypeHandlers(mimeType) {
  const handlers = _image_parsers__WEBPACK_IMPORTED_MODULE_0__["mimeTypeMap"].get(mimeType);
  if (!handlers) {
    throw new Error(ERR_INVALID_MIME_TYPE);
  }
  return handlers;
}

function toDataView(data) {
  // TODO: make these functions work for Node.js buffers?
  // if (bufferToArrayBuffer) {
  //   data = bufferToArrayBuffer(data);
  // }

  // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)
  if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
    return new DataView(data.buffer || data);
  }

  throw new Error('toDataView');
}


/***/ }),

/***/ "../images/src/lib/image-parsers.js":
/*!******************************************!*\
  !*** ../images/src/lib/image-parsers.js ***!
  \******************************************/
/*! exports provided: mimeTypeMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mimeTypeMap", function() { return mimeTypeMap; });
const BIG_ENDIAN = false;
const LITTLE_ENDIAN = true;

const mimeTypeMap = new Map([
  ['image/png', {test: isPng, getSize: getPngSize}],
  ['image/jpeg', {test: isJpeg, getSize: getJpegSize}],
  ['image/gif', {test: isGif, getSize: getGifSize}],
  ['image/bmp', {test: isBmp, getSize: getBmpSize}]
]);

// PNG

function isPng(dataView) {
  // Check file contains the first 4 bytes of the PNG signature.
  return dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 0x89504e47;
}

function getPngSize(dataView) {
  // Extract size from a binary PNG file
  return {
    width: dataView.getUint32(16, BIG_ENDIAN),
    height: dataView.getUint32(20, BIG_ENDIAN)
  };
}

// GIF

function isGif(dataView) {
  // Check first 4 bytes of the GIF signature ("GIF8").
  return dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 0x47494638;
}

// Extract size from a binary GIF file
// TODO: GIF is not this simple
function getGifSize(dataView) {
  // GIF is little endian.
  return {
    width: dataView.getUint16(6, LITTLE_ENDIAN),
    height: dataView.getUint16(8, LITTLE_ENDIAN)
  };
}

// BMP

// TODO: BMP is not this simple
function isBmp(dataView) {
  // Check magic number is valid (first 2 characters should be "BM").
  return dataView.byteLength >= 2 && dataView.getUint16(0, BIG_ENDIAN) === 0x424d;
}

function getBmpSize(dataView) {
  // BMP is little endian.
  return {
    width: dataView.getUint32(18, LITTLE_ENDIAN),
    height: dataView.getUint32(22, LITTLE_ENDIAN)
  };
}

// JPEG

function isJpeg(dataView) {
  // Check file contains the JPEG "start of image" (SOI) marker
  // followed by another marker.
  return (
    dataView.byteLength >= 3 &&
    dataView.getUint16(0, BIG_ENDIAN) === 0xffd8 &&
    dataView.getUint8(2, BIG_ENDIAN) === 0xff
  );
}

// Extract width and height from a binary JPEG file
function getJpegSize(dataView) {
  // Check file contains the JPEG "start of image" (SOI) marker.
  if (dataView.byteLength < 2 || dataView.getUint16(0, BIG_ENDIAN) !== 0xffd8) {
    return null;
  }

  const {tableMarkers, sofMarkers} = getJpegMarkers();

  // Exclude the two byte SOI marker.
  let i = 2;
  while (i < dataView.byteLength) {
    const marker = dataView.getUint16(i, BIG_ENDIAN);

    // The frame that contains the width and height of the JPEG image.
    if (sofMarkers.has(marker)) {
      return {
        height: dataView.getUint16(i + 5, BIG_ENDIAN), // Number of lines
        width: dataView.getUint16(i + 7, BIG_ENDIAN) // Number of pixels per line
      };
    }

    // Miscellaneous tables/data preceding the frame header.
    if (!tableMarkers.has(marker)) {
      return null;
    }

    // Length includes size of length parameter but not the two byte header.
    i += 2;
    i += dataView.getUint16(i, BIG_ENDIAN);
  }

  return null;
}

function getJpegMarkers() {
  // Tables/misc header markers.
  // DQT, DHT, DAC, DRI, COM, APP_n
  const tableMarkers = new Set([0xffdb, 0xffc4, 0xffcc, 0xffdd, 0xfffe]);
  for (let i = 0xffe0; i < 0xfff0; ++i) {
    tableMarkers.add(i);
  }

  // SOF markers and DHP marker.
  // These markers are after tables/misc data.
  const sofMarkers = new Set([
    0xffc0,
    0xffc1,
    0xffc2,
    0xffc3,
    0xffc5,
    0xffc6,
    0xffc7,
    0xffc9,
    0xffca,
    0xffcb,
    0xffcd,
    0xffce,
    0xffcf,
    0xffde
  ]);

  return {tableMarkers, sofMarkers};
}


/***/ }),

/***/ "../images/src/lib/image-utils-browser.js":
/*!************************************************!*\
  !*** ../images/src/lib/image-utils-browser.js ***!
  \************************************************/
/*! exports provided: decodeImage, getImagePixelData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeImage", function() { return decodeImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImagePixelData", function() { return getImagePixelData; });
// TODO - currently only work in browser, great if could work on all platform image types
/* global document */

// Unpacks compressed image data into an HTML image
function decodeImage(arrayBufferOrView, {mimeType = 'image/jpeg'}) {
  /* global window, Blob, Image */
  const blob = new Blob([arrayBufferOrView], {type: mimeType});
  const urlCreator = window.URL || window.webkitURL;
  const imageUrl = urlCreator.createObjectURL(blob);

  return new Promise((resolve, reject) => {
    const image = new Image();
    image.onload = () => resolve(image);
    image.onerror = reject;
    image.src = imageUrl;
    return image;
  });
}

// Get (uncompressed) image pixel data
function getImagePixelData(image, width = null, height = null) {
  width = width || image.width;
  height = height || image.height;
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(image, 0, 0, width, height);
  return ctx.getImageData(0, 0, width, height);
}


/***/ }),

/***/ "../images/src/lib/parse-image.js":
/*!****************************************!*\
  !*** ../images/src/lib/parse-image.js ***!
  \****************************************/
/*! exports provided: canParseImage, parseImage, loadImage, parseToImageBitmap, loadToHTMLImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "canParseImage", function() { return canParseImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseImage", function() { return parseImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadImage", function() { return loadImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseToImageBitmap", function() { return parseToImageBitmap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadToHTMLImage", function() { return loadToHTMLImage; });
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/globals */ "../images/src/utils/globals.js");
/* harmony import */ var _get_image_metadata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-image-metadata */ "../images/src/lib/get-image-metadata.js");
/* global Image, Blob, createImageBitmap, btoa, fetch */



const canParseImage = _utils_globals__WEBPACK_IMPORTED_MODULE_0__["global"]._parseImageNode || typeof ImageBitmap !== 'undefined';

// Parse to platform defined type (ndarray on node, ImageBitmap on browser)
function parseImage(arrayBuffer, options) {
  if (_utils_globals__WEBPACK_IMPORTED_MODULE_0__["global"]._parseImageNode) {
    const {mimeType} = Object(_get_image_metadata__WEBPACK_IMPORTED_MODULE_1__["getImageMetadata"])(arrayBuffer);
    return _utils_globals__WEBPACK_IMPORTED_MODULE_0__["global"]._parseImageNode(arrayBuffer, mimeType, options);
  }

  return parseToImageBitmap(arrayBuffer, options);
}

// Fallback for older browsers
// TODO - investigate Image.decode()
// https://medium.com/dailyjs/image-loading-with-image-decode-b03652e7d2d2
async function loadImage(url, options = {}) {
  if (typeof Image === 'undefined') {
    const response = await fetch(url, options);
    const arrayBuffer = await response.arrayBuffer();
    return parseImage(arrayBuffer, options);
  }
  return await loadToHTMLImage(url, options);
}

// Asynchronously parses an array buffer into an ImageBitmap - this contains the decoded data
// Supported on worker threads
// Not supported on Edge and Safari
// https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap#Browser_compatibility
function parseToImageBitmap(arrayBuffer, options) {
  if (typeof createImageBitmap === 'undefined') {
    throw new Error('parseImage');
  }

  const blob = new Blob([new Uint8Array(arrayBuffer)]);
  return createImageBitmap(blob);
}

//
async function loadToHTMLImage(url, options) {
  let src;
  if (/\.svg((\?|#).*)?$/.test(url)) {
    // is SVG
    const response = await fetch(url, options);
    const xml = await response.text();
    // base64 encoding is safer. utf-8 fails in some browsers
    src = `data:image/svg+xml;base64,${btoa(xml)}`;
  } else {
    src = await url;
  }

  return await new Promise((resolve, reject) => {
    try {
      const image = new Image();
      image.onload = () => resolve(image);
      image.onerror = err => reject(new Error(`Could not load image ${url}: ${err}`));
      image.crossOrigin = (options && options.crossOrigin) || 'anonymous';
      image.src = src;
    } catch (error) {
      reject(error);
    }
  });
}


/***/ }),

/***/ "../images/src/utils/assert.js":
/*!*************************************!*\
  !*** ../images/src/utils/assert.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
// Replacement for the external assert method to reduce bundle size
// Note: We don't use the second "message" argument in calling code,
// so no need to support it here
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || '@loaders.gl/images assertion failed.');
  }
}


/***/ }),

/***/ "../images/src/utils/globals.js":
/*!**************************************!*\
  !*** ../images/src/utils/globals.js ***!
  \**************************************/
/*! exports provided: isBrowser, global */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process, global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return isBrowser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "global", function() { return global_; });
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Purpose: include this in your module to avoids adding dependencies on
// micro modules like 'global' and 'is-browser';

/* eslint-disable no-restricted-globals */
/* global process, global, window, self */
const isBrowser =
  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;

const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global
};

const global_ = globals.global || globals.self || globals.window;



/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/process/browser.js */ "../../node_modules/process/browser.js"), __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../loader-utils/src/categories/mesh/mesh-utils.js":
/*!*********************************************************!*\
  !*** ../loader-utils/src/categories/mesh/mesh-utils.js ***!
  \*********************************************************/
/*! exports provided: getMeshSize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMeshSize", function() { return getMeshSize; });
function getMeshSize(attributes) {
  let size = 0;
  for (const attributeName in attributes) {
    const attribute = attributes[attributeName];
    if (ArrayBuffer.isView(attribute)) {
      size += attribute.length * attribute.BYTES_PER_ELEMENT;
    }
  }
  return size;
}


/***/ }),

/***/ "../loader-utils/src/index.js":
/*!************************************!*\
  !*** ../loader-utils/src/index.js ***!
  \************************************/
/*! exports provided: createWorker, padTo4Bytes, copyToArray, copyArrayBuffer, copyPaddedArrayBufferToDataView, copyPaddedStringToDataView, padStringToByteAlignment, copyStringToDataView, copyBinaryToDataView, _getMeshSize, assert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _worker_utils_create_worker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-utils/create-worker */ "../loader-utils/src/worker-utils/create-worker.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createWorker", function() { return _worker_utils_create_worker__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _lib_memory_copy_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/memory-copy-utils */ "../loader-utils/src/lib/memory-copy-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "padTo4Bytes", function() { return _lib_memory_copy_utils__WEBPACK_IMPORTED_MODULE_1__["padTo4Bytes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyToArray", function() { return _lib_memory_copy_utils__WEBPACK_IMPORTED_MODULE_1__["copyToArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyArrayBuffer", function() { return _lib_memory_copy_utils__WEBPACK_IMPORTED_MODULE_1__["copyArrayBuffer"]; });

/* harmony import */ var _lib_binary_copy_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/binary-copy-utils */ "../loader-utils/src/lib/binary-copy-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyPaddedArrayBufferToDataView", function() { return _lib_binary_copy_utils__WEBPACK_IMPORTED_MODULE_2__["copyPaddedArrayBufferToDataView"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyPaddedStringToDataView", function() { return _lib_binary_copy_utils__WEBPACK_IMPORTED_MODULE_2__["copyPaddedStringToDataView"]; });

/* harmony import */ var _lib_encode_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/encode-utils */ "../loader-utils/src/lib/encode-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "padStringToByteAlignment", function() { return _lib_encode_utils__WEBPACK_IMPORTED_MODULE_3__["padStringToByteAlignment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyStringToDataView", function() { return _lib_encode_utils__WEBPACK_IMPORTED_MODULE_3__["copyStringToDataView"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyBinaryToDataView", function() { return _lib_encode_utils__WEBPACK_IMPORTED_MODULE_3__["copyBinaryToDataView"]; });

/* harmony import */ var _categories_mesh_mesh_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./categories/mesh/mesh-utils */ "../loader-utils/src/categories/mesh/mesh-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_getMeshSize", function() { return _categories_mesh_mesh_utils__WEBPACK_IMPORTED_MODULE_4__["getMeshSize"]; });

/* harmony import */ var _lib_utils_assert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/utils/assert */ "../loader-utils/src/lib/utils/assert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return _lib_utils_assert__WEBPACK_IMPORTED_MODULE_5__["default"]; });

// WORKER UTILS


// MEMORY COPY UTILS




// MESH CATEGORY UTILS





/***/ }),

/***/ "../loader-utils/src/lib/binary-copy-utils.js":
/*!****************************************************!*\
  !*** ../loader-utils/src/lib/binary-copy-utils.js ***!
  \****************************************************/
/*! exports provided: copyPaddedArrayBufferToDataView, copyPaddedStringToDataView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyPaddedArrayBufferToDataView", function() { return copyPaddedArrayBufferToDataView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyPaddedStringToDataView", function() { return copyPaddedStringToDataView; });
/* harmony import */ var _memory_copy_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./memory-copy-utils */ "../loader-utils/src/lib/memory-copy-utils.js");
/* global TextEncoder */


function copyPaddedArrayBufferToDataView(dataView, byteOffset, sourceBuffer, padding) {
  const paddedLength = Object(_memory_copy_utils__WEBPACK_IMPORTED_MODULE_0__["padTo4Bytes"])(sourceBuffer.byteLength);
  const padLength = paddedLength - sourceBuffer.byteLength;

  if (dataView) {
    // Copy array
    const targetArray = new Uint8Array(
      dataView.buffer,
      dataView.byteOffset + byteOffset,
      sourceBuffer.byteLength
    );
    const sourceArray = new Uint8Array(sourceBuffer);
    targetArray.set(sourceArray);

    // Add PADDING
    for (let i = 0; i < padLength; ++i) {
      // json chunk is padded with spaces (ASCII 0x20)
      dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 0x20);
    }
  }
  byteOffset += paddedLength;
  return byteOffset;
}

function copyPaddedStringToDataView(dataView, byteOffset, string, padding) {
  const textEncoder = new TextEncoder();
  // PERFORMANCE IDEA: We encode twice, once to get size and once to store
  // PERFORMANCE IDEA: Use TextEncoder.encodeInto() to avoid temporary copy
  const stringBuffer = textEncoder.encode(string);

  byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer, padding);

  return byteOffset;
}


/***/ }),

/***/ "../loader-utils/src/lib/encode-utils.js":
/*!***********************************************!*\
  !*** ../loader-utils/src/lib/encode-utils.js ***!
  \***********************************************/
/*! exports provided: padStringToByteAlignment, copyStringToDataView, copyBinaryToDataView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "padStringToByteAlignment", function() { return padStringToByteAlignment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyStringToDataView", function() { return copyStringToDataView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyBinaryToDataView", function() { return copyBinaryToDataView; });
// UTILITIES

// PERFORMANCE IDEA: No need to copy string twice...
function padStringToByteAlignment(string, byteAlignment) {
  const length = string.length;
  const paddedLength = Math.ceil(length / byteAlignment) * byteAlignment; // Round up to the required alignment
  const padding = paddedLength - length;
  let whitespace = '';
  for (let i = 0; i < padding; ++i) {
    whitespace += ' ';
  }
  return string + whitespace;
}

function copyStringToDataView(dataView, byteOffset, string, byteLength) {
  if (dataView) {
    for (let i = 0; i < byteLength; i++) {
      dataView.setUint8(byteOffset + i, string.charCodeAt(i));
    }
  }
  return byteOffset + byteLength;
}

function copyBinaryToDataView(dataView, byteOffset, binary, byteLength) {
  if (dataView) {
    for (let i = 0; i < byteLength; i++) {
      dataView.setUint8(byteOffset + i, binary[i]);
      byteOffset++;
    }
  }
  return byteOffset + byteLength;
}


/***/ }),

/***/ "../loader-utils/src/lib/memory-copy-utils.js":
/*!****************************************************!*\
  !*** ../loader-utils/src/lib/memory-copy-utils.js ***!
  \****************************************************/
/*! exports provided: padTo4Bytes, copyArrayBuffer, copyToArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "padTo4Bytes", function() { return padTo4Bytes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyArrayBuffer", function() { return copyArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyToArray", function() { return copyToArray; });
function padTo4Bytes(byteLength) {
  return (byteLength + 3) & ~3;
}

/* Creates a new Uint8Array based on two different ArrayBuffers
 * @private
 * @param {ArrayBuffers} buffer1 The first buffer.
 * @param {ArrayBuffers} buffer2 The second buffer.
 * @return {ArrayBuffers} The new ArrayBuffer created out of the two.
 */
function copyArrayBuffer(
  targetBuffer,
  sourceBuffer,
  byteOffset,
  byteLength = sourceBuffer.byteLength
) {
  const targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);
  const sourceArray = new Uint8Array(sourceBuffer);
  targetArray.set(sourceArray);
  return targetBuffer;
}

/**
 * Copy from source to target at the targetOffset
 *
 * @param {ArrayBuffer|TypedArray} source - The data to copy
 * @param {TypedArray} target - The destination to copy data into
 * @param {Number} targetOffset - The start offset into target to place the copied data
 *
 * @return {Number} Returns the new offset taking into account proper padding
 */
function copyToArray(source, target, targetOffset) {
  let sourceArray;

  if (source instanceof ArrayBuffer) {
    sourceArray = new Uint8Array(source);
  } else {
    // Pack buffer onto the big target array
    //
    // 'source.data.buffer' could be a view onto a larger buffer.
    // We MUST use this constructor to ensure the byteOffset and byteLength is
    // set to correct values from 'source.data' and not the underlying
    // buffer for target.set() to work properly.
    const srcByteOffset = source.byteOffset;
    const srcByteLength = source.byteLength;
    sourceArray = new Uint8Array(source.buffer, srcByteOffset, srcByteLength);
  }

  // Pack buffer onto the big target array
  target.set(sourceArray, targetOffset);

  return targetOffset + padTo4Bytes(sourceArray.byteLength);
}


/***/ }),

/***/ "../loader-utils/src/lib/utils/assert.js":
/*!***********************************************!*\
  !*** ../loader-utils/src/lib/utils/assert.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
// Replacement for the external assert method to reduce bundle size
// Note: We don't use the second "message" argument in calling code,
// so no need to support it here
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loader assertion failed.');
  }
}


/***/ }),

/***/ "../loader-utils/src/worker-utils/create-worker.js":
/*!*********************************************************!*\
  !*** ../loader-utils/src/worker-utils/create-worker.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createWorker; });
/* harmony import */ var _get_transfer_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-transfer-list */ "../loader-utils/src/worker-utils/get-transfer-list.js");
/* eslint-disable no-restricted-globals */
/* global TextDecoder, self */


// Set up a WebWorkerGlobalScope to talk with the main thread
function createWorker(loader) {
  // TODO - explain when this happens? Just a sanity check? Throw an error or log a warning?
  if (typeof self === 'undefined') {
    return;
  }

  self.onmessage = async evt => {
    const {data} = evt;

    try {
      if (!isKnownMessage(data, loader.name)) {
        return;
      }

      const {arraybuffer, byteOffset = 0, byteLength = 0, options = {}} = data;

      const result = await parseData(loader, arraybuffer, byteOffset, byteLength, options);
      const transferList = Object(_get_transfer_list__WEBPACK_IMPORTED_MODULE_0__["default"])(result);
      self.postMessage({type: 'done', result}, transferList);
    } catch (error) {
      self.postMessage({type: 'error', message: error.message});
    }
  };

  let requestId = 0;
  self.parse = (arraybuffer, options = {}, url) =>
    new Promise((resolve, reject) => {
      const id = requestId++;

      const onMessage = ({data}) => {
        if (!data || data.id !== id) {
          // not ours
          return;
        }
        switch (data.type) {
          case 'process-done':
            self.removeEventListener('message', onMessage);
            resolve(data.result);
            break;

          case 'process-error':
            self.removeEventListener('message', onMessage);
            reject(data.message);
            break;

          default:
          // ignore
        }
      };
      self.addEventListener('message', onMessage);
      // Ask the main thread to decode data
      self.postMessage({type: 'process', id, arraybuffer, options, url}, [arraybuffer]);
    });
}

// TODO - Support byteOffset and byteLength (enabling parsing of embedded binaries without copies)
// TODO - Why not support async loader.parse* funcs here?
// TODO - Why not reuse a common function instead of reimplementing loader.parse* selection logic? Keeping loader small?
// TODO - Lack of appropriate parser functions can be detected when we create worker, no need to wait until parse
async function parseData(loader, arraybuffer, byteOffset, byteLength, options) {
  let data;
  let parser;
  if (loader.parseSync || loader.parse) {
    data = arraybuffer;
    parser = loader.parseSync || loader.parse;
  } else if (loader.parseTextSync) {
    const textDecoder = new TextDecoder();
    data = textDecoder.decode(arraybuffer);
    parser = loader.parseTextSync;
  } else {
    throw new Error(`Could not load data with ${loader.name} loader`);
  }

  return await parser(data, options);
}

// Filter out noise messages sent to workers
function isKnownMessage(data, name) {
  return data && data.type === 'process' && data.source === 'loaders.gl';
}

/*
function checkMessage(evt, name) {
  switch (evt.data && evt.data.source) {
    // Ignore known noise event from react-dev-tools bridge, webpack build progress etc...
    case 'react-devtools-bridge':
    case 'react-devtools-content-script':
    case 'react-devtools-detector':
      return false;
    default:
      // fall through
  }

  switch (evt.data && evt.data.type) {
    case 'webpackProgress':
    case 'webpackOk':
      return false;
    default:
      // Enable to debug messages
      // const message = `${name.toLowerCase()}-worker: ignoring unknown message`;
      // console.log(message, evt.data, evt); // eslint-disable-line
      return false;
  }
}
*/


/***/ }),

/***/ "../loader-utils/src/worker-utils/get-transfer-list.js":
/*!*************************************************************!*\
  !*** ../loader-utils/src/worker-utils/get-transfer-list.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getTransferList; });
// Returns an array of Transferrable objects that can be used with
// postMessage: https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage
function getTransferList(object, recursive = true, transfers) {
  // Make sure that items in the transfer list is unique
  const transfersSet = transfers || new Set();

  if (!object) {
    // ignore
  } else if (object instanceof ArrayBuffer) {
    transfersSet.add(object);
  } else if (object.buffer && object.buffer instanceof ArrayBuffer) {
    // Typed array
    transfersSet.add(object.buffer);
  } else if (recursive && typeof object === 'object') {
    for (const key in object) {
      // Avoid perf hit - only go one level deep
      getTransferList(object[key], recursive, transfersSet);
    }
  }

  // If transfers is defined, is internal recursive call
  // Otherwise it's called by the user
  return transfers === undefined ? Array.from(transfersSet) : null;
}


/***/ }),

/***/ "./src/bundle.js":
/*!***********************!*\
  !*** ./src/bundle.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/* global window, global */
const moduleExports = __webpack_require__(/*! ./index */ "./src/index.js");

const _global = typeof window === 'undefined' ? global : window;
_global.loaders = _global.loaders || {};

module.exports = Object.assign(_global.loaders, moduleExports);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/glb-loader.js":
/*!***************************!*\
  !*** ./src/glb-loader.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_parse_glb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/parse-glb */ "./src/lib/parse-glb.js");
// Binary container format for GLB



/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'GLB',
  extensions: ['glb'],
  mimeType: 'model/gltf-binary',
  binary: true,
  parse: async (arrayBuffer, options) => parseSync(arrayBuffer, options),
  parseSync,
  defaultOptions: {
    strict: false // Enables deprecated XVIZ support (illegal CHUNK formats)
  }
});

function parseSync(arrayBuffer, options) {
  const {byteOffset = 0} = options;
  const glb = {};
  Object(_lib_parse_glb__WEBPACK_IMPORTED_MODULE_0__["default"])(glb, arrayBuffer, byteOffset, options);
  return glb;
}


/***/ }),

/***/ "./src/glb-writer.js":
/*!***************************!*\
  !*** ./src/glb-writer.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_encode_glb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/encode-glb */ "./src/lib/encode-glb.js");


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'GLB',
  extensions: ['glb'],
  mimeType: 'model/gltf-binary',
  encodeSync,
  binary: true
});

function encodeSync(glb, options) {
  const {byteOffset = 0} = options;

  // Calculate length and allocate buffer
  const byteLength = Object(_lib_encode_glb__WEBPACK_IMPORTED_MODULE_0__["default"])(glb, null, byteOffset, options);
  const arrayBuffer = new ArrayBuffer(byteLength);

  // Encode into buffer
  const dataView = new DataView(arrayBuffer);
  Object(_lib_encode_glb__WEBPACK_IMPORTED_MODULE_0__["default"])(glb, dataView, byteOffset, options);

  return arrayBuffer;
}


/***/ }),

/***/ "./src/gltf-loader.js":
/*!****************************!*\
  !*** ./src/gltf-loader.js ***!
  \****************************/
/*! exports provided: default, parse, parseSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseSync", function() { return parseSync; });
/* harmony import */ var _lib_parse_gltf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/parse-gltf */ "./src/lib/parse-gltf.js");
/* harmony import */ var _lib_deprecated_gltf_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/deprecated/gltf-parser */ "./src/lib/deprecated/gltf-parser.js");
// Binary container format for glTF




const defaultOptions = {
  gltf: {
    parserVersion: 1 // the new parser that will be the only option in V2.
  },
  uri: '' // base URI
};

/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'glTF',
  extensions: ['gltf', 'glb'],
  // mimeType: 'model/gltf-binary',
  mimeType: 'model/gltf+json',
  text: true,
  binary: true,
  test: 'glTF',
  parse,
  parseSync, // Less features when parsing synchronously
  defaultOptions
});

async function parse(arrayBuffer, options = {}, context) {
  // Apps like to call the parse method directly so apply default options here
  options = {...defaultOptions, ...options};

  // Deprecated v1 Parser: Returns `GLTFParser` instance, instead of "pure" js object
  if (options.gltf.parserVersion !== 2 && options.useGLTFParser !== false) {
    const gltfParser = new _lib_deprecated_gltf_parser__WEBPACK_IMPORTED_MODULE_1__["default"]();
    return gltfParser.parse(arrayBuffer, options);
  }

  const {byteOffset = 0} = options;
  const gltf = {};
  return await Object(_lib_parse_gltf__WEBPACK_IMPORTED_MODULE_0__["parseGLTF"])(gltf, arrayBuffer, byteOffset, options, context);
}

function parseSync(arrayBuffer, options = {}, context) {
  // Apps like to call the parse method directly so apply default options here
  options = {...defaultOptions, ...options};

  // Deprecated: Return GLTFParser instance
  if (options.gltf.parserVersion !== 2 && options.useGLTFParser !== false) {
    return new _lib_deprecated_gltf_parser__WEBPACK_IMPORTED_MODULE_1__["default"]().parseSync(arrayBuffer, options);
  }

  // Return pure javascript object
  const {byteOffset = 0} = options;
  const gltf = {};
  return Object(_lib_parse_gltf__WEBPACK_IMPORTED_MODULE_0__["parseGLTFSync"])(gltf, arrayBuffer, byteOffset, options, context);
}


/***/ }),

/***/ "./src/gltf-writer.js":
/*!****************************!*\
  !*** ./src/gltf-writer.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_encode_gltf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/encode-gltf */ "./src/lib/encode-gltf.js");


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'glTF',
  extensions: ['glb'], // We only support encoding to binary GLB, not to JSON GLTF
  // mimeType: 'model/gltf-binary',
  mimeType: 'model/gltf+json',
  encodeSync,
  binary: true,
  defaultOptions: {
    useGLTFBuilder: true // Note: GLTFBuilder will be removed in v2
  }
});

function encodeSync(gltf, options = {}) {
  const {byteOffset = 0} = options;

  // Calculate length, then create arraybuffer and encode
  const byteLength = Object(_lib_encode_gltf__WEBPACK_IMPORTED_MODULE_0__["encodeGLTFSync"])(gltf, null, byteOffset, options);
  const arrayBuffer = new ArrayBuffer(byteLength);
  const dataView = new DataView(arrayBuffer);
  Object(_lib_encode_gltf__WEBPACK_IMPORTED_MODULE_0__["encodeGLTFSync"])(gltf, dataView, byteOffset, options);

  return arrayBuffer;
}


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: KHR_DRACO_MESH_COMPRESSION, UBER_POINT_CLOUD_EXTENSION, GLTFLoader, GLTFWriter, GLBLoader, GLBWriter, GLTFScenegraph, postProcessGLTF, parseGLTFSync, encodeGLTFSync, packBinaryJson, unpackBinaryJson, GLBParser, GLBBuilder, GLTFParser, GLTFBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_gltf_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/gltf-constants */ "./src/lib/gltf-constants.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KHR_DRACO_MESH_COMPRESSION", function() { return _lib_gltf_constants__WEBPACK_IMPORTED_MODULE_0__["KHR_DRACO_MESH_COMPRESSION"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UBER_POINT_CLOUD_EXTENSION", function() { return _lib_gltf_constants__WEBPACK_IMPORTED_MODULE_0__["UBER_POINT_CLOUD_EXTENSION"]; });

/* harmony import */ var _gltf_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gltf-loader */ "./src/gltf-loader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLTFLoader", function() { return _gltf_loader__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _gltf_writer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./gltf-writer */ "./src/gltf-writer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLTFWriter", function() { return _gltf_writer__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _glb_loader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./glb-loader */ "./src/glb-loader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLBLoader", function() { return _glb_loader__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _glb_writer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./glb-writer */ "./src/glb-writer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLBWriter", function() { return _glb_writer__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _lib_gltf_scenegraph__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/gltf-scenegraph */ "./src/lib/gltf-scenegraph.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLTFScenegraph", function() { return _lib_gltf_scenegraph__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _lib_post_process_gltf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/post-process-gltf */ "./src/lib/post-process-gltf.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "postProcessGLTF", function() { return _lib_post_process_gltf__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _lib_parse_gltf__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/parse-gltf */ "./src/lib/parse-gltf.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseGLTFSync", function() { return _lib_parse_gltf__WEBPACK_IMPORTED_MODULE_7__["parseGLTFSync"]; });

/* harmony import */ var _lib_encode_gltf__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/encode-gltf */ "./src/lib/encode-gltf.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "encodeGLTFSync", function() { return _lib_encode_gltf__WEBPACK_IMPORTED_MODULE_8__["encodeGLTFSync"]; });

/* harmony import */ var _lib_deprecated_packed_json_pack_binary_json__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/deprecated/packed-json/pack-binary-json */ "./src/lib/deprecated/packed-json/pack-binary-json.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "packBinaryJson", function() { return _lib_deprecated_packed_json_pack_binary_json__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _lib_deprecated_packed_json_unpack_binary_json__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/deprecated/packed-json/unpack-binary-json */ "./src/lib/deprecated/packed-json/unpack-binary-json.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unpackBinaryJson", function() { return _lib_deprecated_packed_json_unpack_binary_json__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _lib_deprecated_glb_parser__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/deprecated/glb-parser */ "./src/lib/deprecated/glb-parser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLBParser", function() { return _lib_deprecated_glb_parser__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _lib_deprecated_glb_builder__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./lib/deprecated/glb-builder */ "./src/lib/deprecated/glb-builder.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLBBuilder", function() { return _lib_deprecated_glb_builder__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _lib_deprecated_gltf_parser__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./lib/deprecated/gltf-parser */ "./src/lib/deprecated/gltf-parser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLTFParser", function() { return _lib_deprecated_gltf_parser__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _lib_deprecated_gltf_builder__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./lib/deprecated/gltf-builder */ "./src/lib/deprecated/gltf-builder.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLTFBuilder", function() { return _lib_deprecated_gltf_builder__WEBPACK_IMPORTED_MODULE_14__["default"]; });

// Constants


// glTF loader/writer definition objects



// GLB Loader & Writer (for custom formats that want to leverage the GLB binary "envelope")



// glTF Data Access Helper Class



// For 3D Tiles



// DEPRECATED










/***/ }),

/***/ "./src/lib/deprecated/glb-builder.js":
/*!*******************************************!*\
  !*** ./src/lib/deprecated/glb-builder.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GLBBuilder; });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../loader-utils/src/index.js");
/* harmony import */ var _loaders_gl_images__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/images */ "../images/src/index.js");
/* harmony import */ var _gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../gltf-utils/gltf-utils */ "./src/lib/gltf-utils/gltf-utils.js");
/* harmony import */ var _encode_glb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../encode-glb */ "./src/lib/encode-glb.js");
/* harmony import */ var _packed_json_pack_binary_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./packed-json/pack-binary-json */ "./src/lib/deprecated/packed-json/pack-binary-json.js");
/* eslint-disable camelcase, max-statements */






class GLBBuilder {
  constructor(options = {}) {
    // Lets us keep track of how large the body will be, as well as the offset for each of the
    // original buffers.
    this.byteLength = 0;

    this.json = {
      buffers: [
        {
          // Just the single BIN chunk buffer
          byteLength: 0 // Updated at end of conversion
        }
      ],
      bufferViews: [],
      accessors: [],
      images: [],
      meshes: []
    };

    // list of binary buffers to be written to the BIN chunk
    // (Each call to addBuffer, addImage etc adds an entry here)
    this.sourceBuffers = [];

    this.log = options.log || console; // eslint-disable-line
  }

  // ACCESSORS

  getByteLength() {
    return this.byteLength;
  }

  // Checks if a binary buffer is a recognized image format (PNG, JPG, GIF, ...)
  isImage(imageData) {
    return Object(_loaders_gl_images__WEBPACK_IMPORTED_MODULE_1__["isImage"])(imageData);
  }

  // MODIFERS
  encodeSync(options = {}) {
    return this.encodeAsGLB(options);
  }

  // Encode the full glTF file as a binary GLB file
  // Returns an ArrayBuffer that represents the complete GLB image that can be saved to file
  // Encode the full GLB buffer with header etc
  // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#
  // glb-file-format-specification
  encodeAsGLB(options = {}) {
    // TODO - avoid double array buffer creation
    this._packBinaryChunk();

    if (options.magic) {
      console.warn('Custom glTF magic number no longer supported'); // eslint-disable-line
    }

    const glb = {
      version: 2,
      json: this.json,
      binary: this.arrayBuffer
    };

    // Calculate length and allocate buffer
    const byteLength = Object(_encode_glb__WEBPACK_IMPORTED_MODULE_3__["default"])(glb, null, 0, options);
    const glbArrayBuffer = new ArrayBuffer(byteLength);

    // Encode into buffer
    const dataView = new DataView(glbArrayBuffer);
    Object(_encode_glb__WEBPACK_IMPORTED_MODULE_3__["default"])(glb, dataView, 0, options);

    return glbArrayBuffer;
  }

  // Add an extra application-defined key to the top-level data structure
  // By default packs JSON by extracting binary data and replacing it with JSON pointers
  addApplicationData(key, data, packOptions = {}) {
    const jsonData = packOptions.packTypedArrays ? Object(_packed_json_pack_binary_json__WEBPACK_IMPORTED_MODULE_4__["default"])(data, this, packOptions) : data;
    this.json[key] = jsonData;
    return this;
  }

  // Add a binary buffer. Builds glTF "JSON metadata" and saves buffer reference
  // Buffer will be copied into BIN chunk during "pack"
  // Currently encodes buffers as glTF accessors, but this could be optimized
  addBuffer(sourceBuffer, accessor = {size: 3}) {
    const bufferViewIndex = this.addBufferView(sourceBuffer);

    const accessorDefaults = {
      size: accessor.size,
      componentType: Object(_gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_2__["getComponentTypeFromArray"])(sourceBuffer),
      count: Math.round(sourceBuffer.length / accessor.size)
    };

    return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));
  }

  // Basic glTF adders: basic memory buffer/image type fields
  // Scenegraph specific adders are placed in glTFBuilder
  // TODO: These should be moved to glTFBuilder once addBuffer
  // have been rewritten to not depend on these.

  // Add one untyped source buffer, create a matching glTF `bufferView`, and return its index
  addBufferView(buffer) {
    const byteLength = buffer.byteLength || buffer.length;

    // Add a bufferView indicating start and length of this binary sub-chunk
    this.json.bufferViews.push({
      buffer: 0,
      // Write offset from the start of the binary body
      byteOffset: this.byteLength,
      byteLength
    });

    // We've now written the contents to the body, so update the total length
    // Every sub-chunk needs to be 4-byte aligned
    this.byteLength += Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["padTo4Bytes"])(byteLength);

    // Add this buffer to the list of buffers to be written to the body.
    this.sourceBuffers.push(buffer);

    // Return the index to the just created bufferView
    return this.json.bufferViews.length - 1;
  }

  // Adds an accessor to a bufferView
  addAccessor(bufferViewIndex, accessor) {
    // Add an accessor pointing to the new buffer view
    this.json.accessors.push({
      bufferView: bufferViewIndex,
      type: Object(_gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_2__["getAccessorTypeFromSize"])(accessor.size),
      componentType: accessor.componentType,
      count: accessor.count
    });

    return this.json.accessors.length - 1;
  }

  // PRIVATE

  // For testing
  _pack() {
    this._packBinaryChunk();
    return {arrayBuffer: this.arrayBuffer, json: this.json};
  }

  // Pack the binary chunk
  _packBinaryChunk() {
    // Already packed
    if (this.arrayBuffer) {
      return;
    }

    // Allocate total array
    const totalByteLength = this.byteLength;
    const arrayBuffer = new ArrayBuffer(totalByteLength);
    const targetArray = new Uint8Array(arrayBuffer);

    // Copy each array into
    let dstByteOffset = 0;
    for (let i = 0; i < this.sourceBuffers.length; i++) {
      const sourceBuffer = this.sourceBuffers[i];
      dstByteOffset = Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["copyToArray"])(sourceBuffer, targetArray, dstByteOffset);
    }

    // Update the glTF BIN CHUNK byte length
    this.json.buffers[0].byteLength = totalByteLength;

    // Save generated arrayBuffer
    this.arrayBuffer = arrayBuffer;

    // Clear out sourceBuffers
    this.sourceBuffers = [];
  }

  // Report internal buffer sizes for debug and testing purposes
  _getInternalCounts() {
    return {
      buffers: this.json.buffers.length,
      bufferViews: this.json.bufferViews.length,
      accessors: this.json.accessors.length,
      images: this.json.images.length
    };
  }
}


/***/ }),

/***/ "./src/lib/deprecated/glb-parser.js":
/*!******************************************!*\
  !*** ./src/lib/deprecated/glb-parser.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GLBParser; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "./src/lib/utils/assert.js");
/* harmony import */ var _parse_glb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parse-glb */ "./src/lib/parse-glb.js");
/* harmony import */ var _gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../gltf-utils/gltf-utils */ "./src/lib/gltf-utils/gltf-utils.js");
/* harmony import */ var _packed_json_unpack_binary_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./packed-json/unpack-binary-json */ "./src/lib/deprecated/packed-json/unpack-binary-json.js");
/* harmony import */ var _packed_json_unpack_gltf_buffers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./packed-json/unpack-gltf-buffers */ "./src/lib/deprecated/packed-json/unpack-gltf-buffers.js");
/* eslint-disable camelcase, max-statements, no-restricted-globals */






class GLBParser {
  static isGLB(arrayBuffer, options = {}) {
    const byteOffset = 0;
    return Object(_parse_glb__WEBPACK_IMPORTED_MODULE_1__["isGLB"])(arrayBuffer, byteOffset);
  }

  // Return the gltf JSON and the original arrayBuffer
  parse(arrayBuffer, options = {}) {
    return this.parseSync(arrayBuffer, options);
  }

  parseSync(arrayBuffer, options = {}) {
    this.glbArrayBuffer = arrayBuffer;

    this.binaryByteOffset = null;
    this.packedJson = null;
    this.json = null;

    // Only parse once
    if (this.json === null && this.binaryByteOffset === null) {
      const byteOffset = 0;

      // Populates the supplied object (`this`) with parsed data members.
      Object(_parse_glb__WEBPACK_IMPORTED_MODULE_1__["default"])(this, this.glbArrayBuffer, byteOffset, options);

      // Backwards compat
      this.binaryByteOffset = this.binChunkByteOffset;

      // Unpack binary JSON
      this.packedJson = this.json;

      const unpackedBuffers = Object(_packed_json_unpack_gltf_buffers__WEBPACK_IMPORTED_MODULE_4__["default"])(
        this.glbArrayBuffer,
        this.json,
        this.binaryByteOffset
      );
      this.json = Object(_packed_json_unpack_binary_json__WEBPACK_IMPORTED_MODULE_3__["default"])(this.json, unpackedBuffers);

      this.unpackedBuffers = unpackedBuffers;
    }

    return this;
  }

  // Returns application JSON data stored in `key`
  getApplicationData(key) {
    return this.json[key];
  }

  // Returns JSON envelope
  getJSON() {
    return this.json;
  }

  // Return binary chunk
  getArrayBuffer() {
    return this.glbArrayBuffer;
  }

  // Return index into binary chunk
  getBinaryByteOffset() {
    return this.binaryByteOffset;
  }

  // Unpacks a bufferview into a new Uint8Array that is a view into the binary chunk
  getBufferView(glTFBufferView) {
    const byteOffset = (glTFBufferView.byteOffset || 0) + this.binaryByteOffset;
    return new Uint8Array(this.glbArrayBuffer, byteOffset, glTFBufferView.byteLength);
  }

  // Unpacks a glTF accessor into a new typed array that is a view into the binary chunk
  getBuffer(glTFAccessor) {
    // Decode the glTF accessor format
    const ArrayType = _gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_2__["ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY"][glTFAccessor.componentType];
    const components = _gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_2__["ATTRIBUTE_TYPE_TO_COMPONENTS"][glTFAccessor.type];
    const bytesPerComponent = _gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_2__["ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE"][glTFAccessor.componentType];
    const length = glTFAccessor.count * components;
    const byteLength = glTFAccessor.count * components * bytesPerComponent;

    // Get the boundaries of the binary sub-chunk for this bufferView
    const glTFBufferView = this.json.bufferViews[glTFAccessor.bufferView];
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(byteLength >= 0 && glTFAccessor.byteOffset + byteLength <= glTFBufferView.byteLength);

    const byteOffset = glTFBufferView.byteOffset + this.binaryByteOffset + glTFAccessor.byteOffset;
    return new ArrayType(this.glbArrayBuffer, byteOffset, length);
  }

  // Unpacks an image into an HTML image
  getImageData(glTFImage) {
    return {
      typedArray: this.getBufferView(glTFImage.bufferView),
      mimeType: glTFImage.mimeType || 'image/jpeg'
    };
  }

  getImage(glTFImage) {
    /* global self, Blob, Image */
    const arrayBufferView = this.getBufferView(glTFImage.bufferView);
    const mimeType = glTFImage.mimeType || 'image/jpeg';
    const blob = new Blob([arrayBufferView], {type: mimeType});
    const urlCreator = self.URL || self.webkitURL;
    const imageUrl = urlCreator.createObjectURL(blob);
    const img = new Image();
    img.src = imageUrl;
    return img;
  }

  getImageAsync(glTFImage) {
    /* global self, Blob, Image */
    return new Promise(resolve => {
      const arrayBufferView = this.getBufferView(glTFImage.bufferView);
      const mimeType = glTFImage.mimeType || 'image/jpeg';
      const blob = new Blob([arrayBufferView], {type: mimeType});
      const urlCreator = self.URL || self.webkitURL;
      const imageUrl = urlCreator.createObjectURL(blob);
      const img = new Image();
      img.onload = () => resolve(img);
      img.src = imageUrl;
    });
  }
}


/***/ }),

/***/ "./src/lib/deprecated/gltf-builder.js":
/*!********************************************!*\
  !*** ./src/lib/deprecated/gltf-builder.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GLTFBuilder; });
/* harmony import */ var _loaders_gl_images__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/images */ "../images/src/index.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/assert */ "./src/lib/utils/assert.js");
/* harmony import */ var _gltf_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../gltf-constants */ "./src/lib/gltf-constants.js");
/* harmony import */ var _glb_builder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./glb-builder */ "./src/lib/deprecated/glb-builder.js");
/* harmony import */ var _packed_json_pack_binary_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./packed-json/pack-binary-json */ "./src/lib/deprecated/packed-json/pack-binary-json.js");






class GLTFBuilder extends _glb_builder__WEBPACK_IMPORTED_MODULE_3__["default"] {
  constructor(options = {}) {
    super(options);

    // Soft dependency on DRACO, app needs to import and supply these
    this.DracoWriter = options.DracoWriter;
    this.DracoLoader = options.DracoLoader;
  }

  // NOTE: encode() inherited from GLBBuilder

  // TODO - support encoding to non-GLB versions of glTF format
  // Encode as a textual JSON file with binary data in base64 data URLs.
  // encodeAsDataURLs(options)
  // Encode as a JSON with all images (and buffers?) in separate binary files
  // encodeAsSeparateFiles(options)

  // Add an extra application-defined key to the top-level data structure
  // By default packs JSON by extracting binary data and replacing it with JSON pointers
  addApplicationData(key, data, packOptions = {}) {
    const jsonData = packOptions.packTypedArrays ? Object(_packed_json_pack_binary_json__WEBPACK_IMPORTED_MODULE_4__["default"])(data, this, packOptions) : data;
    this.json[key] = jsonData;
    return this;
  }

  // `extras` - Standard GLTF field for storing application specific data
  // By default packs JSON by extracting binary data and replacing it with JSON pointers
  addExtraData(key, data, packOptions = {}) {
    const packedJson = packOptions.packedTypedArrays
      ? Object(_packed_json_pack_binary_json__WEBPACK_IMPORTED_MODULE_4__["default"])(data, this, packOptions)
      : data;
    this.json.extras = this.json.extras || {};
    this.json.extras[key] = packedJson;
    return this;
  }

  // Add to standard GLTF top level extension object, mark as used
  // By default packs JSON by extracting binary data and replacing it with JSON pointers
  addExtension(extensionName, data, packOptions = {}) {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(data);
    const packedJson = packOptions.packTypedArrays ? Object(_packed_json_pack_binary_json__WEBPACK_IMPORTED_MODULE_4__["default"])(data, this, packOptions) : data;
    this.json.extensions = this.json.extensions || {};
    this.json.extensions[extensionName] = packedJson;
    this.registerUsedExtension(extensionName);
    return this;
  }

  // Standard GLTF top level extension object, mark as used and required
  // By default packs JSON by extracting binary data and replacing it with JSON pointers
  addRequiredExtension(extensionName, data, packOptions = {}) {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(data);
    const packedJson = packOptions.packTypedArrays ? Object(_packed_json_pack_binary_json__WEBPACK_IMPORTED_MODULE_4__["default"])(data, this, packOptions) : data;
    this.addExtension(extensionName, packedJson);
    this.registerRequiredExtension(extensionName);
    return this;
  }

  // Add extensionName to list of used extensions
  registerUsedExtension(extensionName) {
    this.json.extensionsUsed = this.json.extensionsUsed || [];
    if (!this.json.extensionsUsed.find(ext => ext === extensionName)) {
      this.json.extensionsUsed.push(extensionName);
    }
  }

  // Add extensionName to list of required extensions
  registerRequiredExtension(extensionName) {
    this.registerUsedExtension(extensionName);
    this.json.extensionsRequired = this.json.extensionsRequired || [];
    if (!this.json.extensionsRequired.find(ext => ext === extensionName)) {
      this.json.extensionsRequired.push(extensionName);
    }
  }

  // mode:
  // POINTS:  0x0000,
  // LINES: 0x0001,
  // LINE_LOOP: 0x0002,
  // LINE_STRIP:  0x0003,
  // TRIANGLES: 0x0004,
  // TRIANGLE_STRIP:  0x0005,
  // TRIANGLE_FAN:  0x0006,

  addMesh(attributes, indices, mode = 4) {
    const accessors = this._addAttributes(attributes);

    const glTFMesh = {
      primitives: [
        {
          attributes: accessors,
          indices,
          mode
        }
      ]
    };

    this.json.meshes = this.json.meshes || [];
    this.json.meshes.push(glTFMesh);
    return this.json.meshes.length - 1;
  }

  addPointCloud(attributes) {
    const accessorIndices = this._addAttributes(attributes);

    const glTFMesh = {
      primitives: [
        {
          attributes: accessorIndices,
          mode: 0 // GL.POINTS
        }
      ]
    };

    this.json.meshes = this.json.meshes || [];
    this.json.meshes.push(glTFMesh);
    return this.json.meshes.length - 1;
  }

  // eslint-disable-next-line max-len
  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
  // Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported
  addCompressedMesh(attributes, indices, mode = 4) {
    if (!this.DracoWriter || !this.DracoLoader) {
      throw new Error('DracoWriter/DracoLoader not available');
    }

    // Since we do not add fallback data
    this.registerRequiredExtension(_gltf_constants__WEBPACK_IMPORTED_MODULE_2__["KHR_DRACO_MESH_COMPRESSION"]);

    const compressedData = this.DracoWriter.encodeSync({attributes});

    // Draco compression may change the order and number of vertices in a mesh.
    // To satisfy the requirement that accessors properties be correct for both
    // compressed and uncompressed data, generators should create uncompressed
    // attributes and indices using data that has been decompressed from the Draco buffer,
    // rather than the original source data.
    const decodedData = this.DracoLoader.parseSync({attributes});
    const fauxAccessors = this._addFauxAttributes(decodedData.attributes);

    const bufferViewIndex = this.addBufferView(compressedData);

    const glTFMesh = {
      primitives: [
        {
          attributes: fauxAccessors, // TODO - verify with spec
          mode, // GL.POINTS
          extensions: {
            [_gltf_constants__WEBPACK_IMPORTED_MODULE_2__["KHR_DRACO_MESH_COMPRESSION"]]: {
              bufferView: bufferViewIndex,
              attributes: fauxAccessors // TODO - verify with spec
            }
          }
        }
      ]
    };

    this.json.meshes = this.json.meshes || [];
    this.json.meshes.push(glTFMesh);
    return this.json.meshes.length - 1;
  }

  addCompressedPointCloud(attributes) {
    if (!this.DracoWriter || !this.DracoLoader) {
      throw new Error('DracoWriter/DracoLoader not available');
    }

    attributes.mode = 0;
    const compressedData = this.DracoWriter.encodeSync(attributes, {pointcloud: true});

    const bufferViewIndex = this.addBufferView(compressedData);

    const glTFMesh = {
      primitives: [
        {
          attributes: {}, // This will be populated after decompression
          mode: 0, // GL.POINTS
          extensions: {
            [_gltf_constants__WEBPACK_IMPORTED_MODULE_2__["UBER_POINT_CLOUD_EXTENSION"]]: {
              bufferView: bufferViewIndex
            }
          }
        }
      ]
    };

    this.registerRequiredExtension(_gltf_constants__WEBPACK_IMPORTED_MODULE_2__["UBER_POINT_CLOUD_EXTENSION"]);

    this.json.meshes = this.json.meshes || [];
    this.json.meshes.push(glTFMesh);
    return this.json.meshes.length - 1;
  }

  // Adds a binary image. Builds glTF "JSON metadata" and saves buffer reference
  // Buffer will be copied into BIN chunk during "pack"
  // Currently encodes as glTF image
  addImage(imageData) {
    const bufferViewIndex = this.addBufferView(imageData);

    // Get the properties of the image to add as metadata.
    const sizeAndType = Object(_loaders_gl_images__WEBPACK_IMPORTED_MODULE_0__["getImageMetadata"])(imageData) || {};
    if (sizeAndType) {
      // width and height are non-spec fields
      const {mimeType, width, height} = sizeAndType;
      this.json.images.push({
        bufferView: bufferViewIndex,
        mimeType,
        width,
        height
      });
    } else {
      // TODO: Spec violation, if we are using a bufferView, mimeType must be defined:
      //   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#images
      //   "a reference to a bufferView; in that case mimeType must be defined."
      this.json.images.push({
        bufferView: bufferViewIndex
      });
    }

    return this.json.images.length - 1;
  }
}


/***/ }),

/***/ "./src/lib/deprecated/gltf-parser.js":
/*!*******************************************!*\
  !*** ./src/lib/deprecated/gltf-parser.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GLTFParser; });
/* harmony import */ var _loaders_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/core */ "../core/src/index.js");
/* harmony import */ var _gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../gltf-utils/gltf-utils */ "./src/lib/gltf-utils/gltf-utils.js");
/* harmony import */ var _gltf_utils_gltf_attribute_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../gltf-utils/gltf-attribute-utils */ "./src/lib/gltf-utils/gltf-attribute-utils.js");
/* harmony import */ var _gltf_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../gltf-constants */ "./src/lib/gltf-constants.js");
/* harmony import */ var _glb_parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./glb-parser */ "./src/lib/deprecated/glb-parser.js");
/* harmony import */ var _gltf_post_processor_old__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./gltf-post-processor-old */ "./src/lib/deprecated/gltf-post-processor-old.js");







const DEFAULT_OPTIONS = {
  fetchLinkedResources: true, // Fetch any linked .BIN buffers, decode base64
  fetch: _loaders_gl_core__WEBPACK_IMPORTED_MODULE_0__["fetchFile"],
  decompress: false, // Decompress Draco compressed meshes (if DracoLoader available)
  DracoLoader: null,
  postProcess: true,
  createImages: false, // Create image objects
  log: console // eslint-disable-line
};

class GLTFParser {
  async parse(gltf, options = {}) {
    options = Object.assign({}, DEFAULT_OPTIONS, options);

    // Postpone decompressing/postprocessing to make sure we load any linked files first
    // TODO - is this really needed?
    this.parseSync(gltf, {...options, postProcess: false, decompress: false});

    // Load linked buffers asynchronously and decodes base64 buffers in parallel
    if (options.fetchLinkedResources) {
      await this._loadLinkedAssets(options);
    }

    if (options.decompress) {
      this._decompressMeshes(options);
    }

    if (options.postProcess) {
      const postProcessor = new _gltf_post_processor_old__WEBPACK_IMPORTED_MODULE_5__["default"]();
      postProcessor.postProcess(this.gltf, this.glbParser, options);
    }

    return this.gltf;
  }

  // NOTE: The sync parser cannot handle linked assets or base64 encoded resources
  // gtlf - input can be arrayBuffer (GLB or UTF8 encoded JSON), string (JSON), or parsed JSON.
  parseSync(gltf, options = {}) {
    options = Object.assign({}, DEFAULT_OPTIONS, options);

    // If binary is not starting with magic bytes, convert to string
    if (gltf instanceof ArrayBuffer && !_glb_parser__WEBPACK_IMPORTED_MODULE_4__["default"].isGLB(gltf, options)) {
      const textDecoder = new _loaders_gl_core__WEBPACK_IMPORTED_MODULE_0__["TextDecoder"]();
      gltf = textDecoder.decode(gltf);
    }

    // If string, try to parse as JSON
    if (typeof gltf === 'string') {
      gltf = JSON.parse(gltf);
    }

    if (gltf instanceof ArrayBuffer) {
      // Extract JSON from the GLB container
      this.glbParser = new _glb_parser__WEBPACK_IMPORTED_MODULE_4__["default"]();
      this.gltf = this.glbParser.parseSync(gltf).json;
      this.json = this.gltf;
    } else {
      this.glbParser = null;
      this.gltf = gltf;
      this.json = gltf;
    }

    // TODO: we could handle base64 encoded files in the non-async path
    // await this._loadBuffersSync(options);

    // TODO: we could synchronously decode base64 encoded URIs in the non-async path
    // await this._loadLinkedAssetsSync(options);

    if (options.decompress) {
      this._decompressMeshes(options);
    }

    if (options.postProcess) {
      const postProcessor = new _gltf_post_processor_old__WEBPACK_IMPORTED_MODULE_5__["default"]();
      postProcessor.postProcess(this.gltf, this.glbParser, options);
    }

    return this.gltf;
  }

  // Accessors

  getApplicationData(key) {
    // TODO - Data is already unpacked by GLBParser
    const data = this.json[key];
    return data;
  }

  getExtraData(key) {
    // TODO - Data is already unpacked by GLBParser
    const extras = this.json.extras || {};
    return extras[key];
  }

  getExtension(extensionName) {
    const isExtension = this.getUsedExtensions().find(name => name === extensionName);
    const extensions = this.json.extensions || {};
    return isExtension ? extensions[extensionName] || true : null;
  }

  getRequiredExtension(extensionName) {
    const isRequired = this.getRequiredExtensions().find(name => name === extensionName);
    return isRequired ? this.getExtension(extensionName) : null;
  }

  getRequiredExtensions() {
    return this.json.extensionsRequired || [];
  }

  getUsedExtensions() {
    return this.json.extensionsUsed || [];
  }

  getScene(index) {
    return this._get('scenes', index);
  }

  getNode(index) {
    return this._get('nodes', index);
  }

  getSkin(index) {
    return this._get('skins', index);
  }

  getMesh(index) {
    return this._get('meshes', index);
  }

  getMaterial(index) {
    return this._get('materials', index);
  }

  getAccessor(index) {
    return this._get('accessors', index);
  }

  getCamera(index) {
    return null; // TODO: fix this
  }

  getTexture(index) {
    return this._get('textures', index);
  }

  getSampler(index) {
    return this._get('samplers', index);
  }

  getImage(index) {
    return this._get('images', index);
  }

  getBufferView(index) {
    return this._get('bufferViews', index);
  }

  getBuffer(index) {
    return this._get('buffers', index);
  }

  // PARSING HELPERS

  _get(array, index) {
    // check if already resolved
    if (typeof index === 'object') {
      return index;
    }
    const object = this.gltf[array] && this.gltf[array][index];
    if (!object) {
      console.warn(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line
    }
    return object;
  }

  // PARSING HELPERS

  // Load linked assets
  async _loadLinkedAssets(options) {
    return await Promise.all(this.gltf.buffers.map(buffer => this._loadBuffer(buffer, options)));
  }

  async _loadBuffer(buffer, options) {
    // NOTE: options.uri is not correctly passed, however this class is deprecated...
    if (buffer.uri && options.uri) {
      const fetch = options.fetch || window.fetch;
      const uri = Object(_gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_1__["getFullUri"])(buffer.uri, options.uri);
      const response = await fetch(uri);
      const arrayBuffer = await response.arrayBuffer();
      buffer.data = arrayBuffer;
      buffer.uri = null;
    }
  }

  // POST PROCESSING

  _decompressMeshes(options) {
    // We have a "soft dependency" on Draco to avoid bundling it when not needed
    // DracoEncoder needs to be imported and supplied by app
    if (!options.DracoLoader || !options.decompress) {
      return;
    }

    for (const mesh of this.gltf.meshes || []) {
      // Decompress all the primitives in a mesh
      for (const primitive of mesh.primitives) {
        this._decompressKhronosDracoPrimitive(primitive, options);
        this._decompressUberDracoPrimitive(primitive, options);
        if (!primitive.attributes || Object.keys(primitive.attributes).length === 0) {
          throw new Error('Empty glTF primitive: decompression failure?');
        }
      }
    }

    // We have now decompressed all primitives, we can remove the top-level extensions
    this._removeExtension(_gltf_constants__WEBPACK_IMPORTED_MODULE_3__["KHR_DRACO_MESH_COMPRESSION"]);
    this._removeExtension(_gltf_constants__WEBPACK_IMPORTED_MODULE_3__["UBER_POINT_CLOUD_EXTENSION"]);
  }

  // Unpacks one mesh primitive and removes the extension from the primitive
  // TODO - Implement fallback behavior per KHR_DRACO_MESH_COMPRESSION spec
  // TODO - Decompression could be threaded: Use DracoWorkerLoader?
  //
  // eslint-disable-next-line max-len
  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
  _decompressKhronosDracoPrimitive(primitive, options) {
    const compressedMesh = primitive.extensions && primitive.extensions[_gltf_constants__WEBPACK_IMPORTED_MODULE_3__["KHR_DRACO_MESH_COMPRESSION"]];
    if (!compressedMesh) {
      return;
    }

    // Extension will be processed, delete it
    delete primitive.extensions[_gltf_constants__WEBPACK_IMPORTED_MODULE_3__["KHR_DRACO_MESH_COMPRESSION"]];

    const buffer = this._getBufferViewArray(compressedMesh.bufferView);
    const decodedData = options.DracoLoader.parseSync(buffer);
    primitive.attributes = Object(_gltf_utils_gltf_attribute_utils__WEBPACK_IMPORTED_MODULE_2__["getGLTFAccessors"])(decodedData.attributes);
    if (decodedData.indices) {
      primitive.indices = Object(_gltf_utils_gltf_attribute_utils__WEBPACK_IMPORTED_MODULE_2__["getGLTFAccessor"])(decodedData.indices);
    }
  }

  // Unpacks one mesh primitive and removes the extension from the primitive
  _decompressUberDracoPrimitive(primitive, options) {
    const compressedMesh = primitive.extensions && primitive.extensions[_gltf_constants__WEBPACK_IMPORTED_MODULE_3__["UBER_POINT_CLOUD_EXTENSION"]];
    if (!compressedMesh) {
      return;
    }

    if (primitive.mode !== 0) {
      throw new Error(_gltf_constants__WEBPACK_IMPORTED_MODULE_3__["UBER_POINT_CLOUD_EXTENSION"]);
    }

    // Extension will be processed, delete it
    delete primitive.extensions[_gltf_constants__WEBPACK_IMPORTED_MODULE_3__["UBER_POINT_CLOUD_EXTENSION"]];

    const buffer = this._getBufferViewArray(compressedMesh.bufferView);
    const decodedData = options.DracoLoader.parseSync(buffer);
    primitive.attributes = decodedData.attributes;
  }

  _getBufferViewArray(bufferViewIndex) {
    const bufferView = this.gltf.bufferViews[bufferViewIndex];
    if (this.glbParser) {
      return this.glbParser.getBufferView(bufferView);
    }

    const buffer = this.gltf.buffers[bufferView.buffer].data;
    const byteOffset = bufferView.byteOffset || 0;
    return new Uint8Array(buffer, byteOffset, bufferView.byteLength);
  }

  // Removes an extension from the top-level list
  _removeExtension(extensionName) {
    if (this.json.extensionsRequired) {
      this._removeStringFromArray(this.json.extensionsRequired, extensionName);
    }
    if (this.json.extensionsUsed) {
      this._removeStringFromArray(this.json.extensionsUsed, extensionName);
    }
    if (this.json.extensions) {
      delete this.json.extensions[extensionName];
    }
  }

  _removeStringFromArray(array, string) {
    let found = true;
    while (found) {
      const index = array.indexOf(string);
      if (index > -1) {
        array.splice(index, 1);
      } else {
        found = false;
      }
    }
  }
}


/***/ }),

/***/ "./src/lib/deprecated/gltf-post-processor-old.js":
/*!*******************************************************!*\
  !*** ./src/lib/deprecated/gltf-post-processor-old.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GLTFPostProcessorOld; });
/* harmony import */ var _gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../gltf-utils/gltf-utils */ "./src/lib/gltf-utils/gltf-utils.js");


// This is a post processor for loaded glTF files
// The goal is to make the loaded data easier to use in WebGL applications
//
// Functions:
// * Resolve indexed arrays structure of glTF into a linked tree.
// * Translate stringified enum keys and values into WebGL constants.
// * Load images (optional)

// ENUM LOOKUP

const COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};

const BYTES = {
  5120: 1, // BYTE
  5121: 1, // UNSIGNED_BYTE
  5122: 2, // SHORT
  5123: 2, // UNSIGNED_SHORT
  5125: 4, // UNSIGNED_INT
  5126: 4 // FLOAT
};

const GL_SAMPLER = {
  // Sampler parameters
  TEXTURE_MAG_FILTER: 0x2800,
  TEXTURE_MIN_FILTER: 0x2801,
  TEXTURE_WRAP_S: 0x2802,
  TEXTURE_WRAP_T: 0x2803,

  // Sampler default values
  REPEAT: 0x2901,
  LINEAR: 0x2601,
  NEAREST_MIPMAP_LINEAR: 0x2702
};

const SAMPLER_PARAMETER_GLTF_TO_GL = {
  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,
  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,
  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,
  wrapT: GL_SAMPLER.TEXTURE_WRAP_T
};

// When undefined, a sampler with repeat wrapping and auto filtering should be used.
// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture
const DEFAULT_SAMPLER = {
  [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,
  [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,
  [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,
  [GL_SAMPLER.TEXTURE_WRAP_]: GL_SAMPLER.REPEAT
};

function getBytesFromComponentType(componentType) {
  return BYTES[componentType];
}

function getSizeFromAccessorType(type) {
  return COMPONENTS[type];
}

class GLTFPostProcessorOld {
  postProcess(gltf, glbParser, options = {}) {
    this.gltf = gltf;
    this.glbParser = glbParser;

    this._resolveToTree(options);
    return this.gltf;
  }

  // Convert indexed glTF structure into tree structure
  // PREPARATION STEP: CROSS-LINK INDEX RESOLUTION, ENUM LOOKUP, CONVENIENCE CALCULATIONS
  /* eslint-disable complexity */
  _resolveToTree(options = {}) {
    const {gltf} = this;

    (gltf.bufferViews || []).forEach((bufView, i) => this._resolveBufferView(bufView, i));

    (gltf.images || []).forEach((image, i) => this._resolveImage(image, i, options));
    (gltf.samplers || []).forEach((sampler, i) => this._resolveSampler(sampler, i));
    (gltf.textures || []).forEach((texture, i) => this._resolveTexture(texture, i));

    (gltf.accessors || []).forEach((accessor, i) => this._resolveAccessor(accessor, i));
    (gltf.materials || []).forEach((material, i) => this._resolveMaterial(material, i));
    (gltf.meshes || []).forEach((mesh, i) => this._resolveMesh(mesh, i));

    (gltf.nodes || []).forEach((node, i) => this._resolveNode(node, i));

    (gltf.skins || []).forEach((skin, i) => this._resolveSkin(skin, i));

    (gltf.scenes || []).forEach((scene, i) => this._resolveScene(scene, i));

    if (gltf.scene !== undefined) {
      gltf.scene = gltf.scenes[this.gltf.scene];
    }

    // EXTENSIONS
    this._process_extension_KHR_lights_punctual();

    return gltf;
  }
  /* eslint-enable complexity */

  getScene(index) {
    return this._get('scenes', index);
  }

  getNode(index) {
    return this._get('nodes', index);
  }

  getSkin(index) {
    return this._get('skins', index);
  }

  getMesh(index) {
    return this._get('meshes', index);
  }

  getMaterial(index) {
    return this._get('materials', index);
  }

  getAccessor(index) {
    return this._get('accessors', index);
  }

  getCamera(index) {
    return null; // TODO: fix this
  }

  getTexture(index) {
    return this._get('textures', index);
  }

  getSampler(index) {
    return this._get('samplers', index);
  }

  getImage(index) {
    return this._get('images', index);
  }

  getBufferView(index) {
    return this._get('bufferViews', index);
  }

  getBuffer(index) {
    return this._get('buffers', index);
  }

  _get(array, index) {
    // check if already resolved
    if (typeof index === 'object') {
      return index;
    }
    const object = this.gltf[array] && this.gltf[array][index];
    if (!object) {
      console.warn(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line
    }
    return object;
  }

  // PARSING HELPERS

  _resolveScene(scene, index) {
    scene.id = `scene-${index}`;
    scene.nodes = (scene.nodes || []).map(node => this.getNode(node));
  }

  _resolveNode(node, index) {
    node.id = `node-${index}`;
    node.children = (node.children || []).map(child => this.getNode(child));
    if (node.mesh !== undefined) {
      node.mesh = this.getMesh(node.mesh);
    }
    if (node.camera !== undefined) {
      node.camera = this.getCamera(node.camera);
    }
    if (node.skin !== undefined) {
      node.skin = this.getSkin(node.skin);
    }
  }

  _resolveSkin(skin, index) {
    skin.id = `skin-${index}`;
    skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);
  }

  _resolveMesh(mesh, index) {
    mesh.id = `mesh-${index}`;
    for (const primitive of mesh.primitives) {
      for (const attribute in primitive.attributes) {
        primitive.attributes[attribute] = this.getAccessor(primitive.attributes[attribute]);
      }
      if (primitive.indices !== undefined) {
        primitive.indices = this.getAccessor(primitive.indices);
      }
      if (primitive.material !== undefined) {
        primitive.material = this.getMaterial(primitive.material);
      }
    }
  }

  _resolveMaterial(material, index) {
    material.id = `material-${index}`;
    if (material.normalTexture) {
      material.normalTexture.texture = this.getTexture(material.normalTexture.index);
    }
    if (material.occlusionTexture) {
      material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);
    }
    if (material.emissiveTexture) {
      material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);
    }

    if (material.pbrMetallicRoughness) {
      const mr = material.pbrMetallicRoughness;
      if (mr.baseColorTexture) {
        mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);
      }
      if (mr.metallicRoughnessTexture) {
        mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);
      }
    }
  }

  _resolveAccessor(accessor, index) {
    accessor.id = `accessor-${index}`;
    if (accessor.bufferView !== undefined) {
      // Draco encoded meshes don't have bufferView
      accessor.bufferView = this.getBufferView(accessor.bufferView);
    }

    // Look up enums
    accessor.bytesPerComponent = getBytesFromComponentType(accessor);
    accessor.components = getSizeFromAccessorType(accessor);
    accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;
  }

  _resolveTexture(texture, index) {
    texture.id = `texture-${index}`;
    texture.sampler = 'sampler' in texture ? this.getSampler(texture.sampler) : DEFAULT_SAMPLER;
    texture.source = this.getImage(texture.source);
  }

  _resolveSampler(sampler, index) {
    sampler.id = `sampler-${index}`;
    // Map textual parameters to GL parameter values
    sampler.parameters = {};
    for (const key in sampler) {
      const glEnum = this._enumSamplerParameter(key);
      if (glEnum !== undefined) {
        sampler.parameters[glEnum] = sampler[key];
      }
    }
  }

  _enumSamplerParameter(key) {
    return SAMPLER_PARAMETER_GLTF_TO_GL[key];
  }

  _resolveImage(image, index, options) {
    image.id = `image-${index}`;
    if (image.bufferView !== undefined) {
      image.bufferView = this.getBufferView(image.bufferView);
    }

    // TODO - Handle non-binary-chunk images, data URIs, URLs etc
    // TODO - Image creation could be done on getImage instead of during load
    const {createImages = true} = options;
    if (createImages) {
      image.image = this.glbParser.getImage(image);
    } else {
      image.getImageAsync = () => {
        if (this.glbParser) {
          return this.glbParser.getImageAsync(image);
        } else if (image.uri) {
          // TODO: Maybe just return the URL?
          // TODO: Maybe use loaders.gl/core loadImage?
          return new Promise(resolve => {
            /* global Image */
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => resolve(img);
            img.src = Object(_gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_0__["getFullUri"])(image.uri, options.uri);
          });
        }

        // cannot get image
        return null;
      };
    }
  }

  _resolveBufferView(bufferView, index) {
    bufferView.id = `bufferView-${index}`;
    bufferView.buffer = this.getBuffer(bufferView.buffer);

    if (this.glbParser) {
      bufferView.data = this.glbParser.getBufferView(bufferView);
    } else {
      const byteOffset = bufferView.byteOffset || 0;
      bufferView.data = new Uint8Array(bufferView.buffer.data, byteOffset, bufferView.byteLength);
    }
  }

  _resolveCamera(camera) {
    // TODO - create 4x4 matrices
    if (camera.perspective) {
      // camera.matrix = createPerspectiveMatrix(camera.perspective);
    }
    if (camera.orthographic) {
      // camera.matrix = createOrthographicMatrix(camera.orthographic);
    }
  }

  // EXTENSIONS

  // eslint-disable-next-line camelcase
  _process_extension_KHR_lights_punctual() {
    const {gltf} = this;

    // Move the light array out of the extension and remove the extension
    const extension = gltf.extensions && gltf.extensions.KHR_lights_punctual;
    if (extension) {
      gltf.lights = extension.lights;
    }

    this._removeExtension('KHR_lights_punctual');

    // Any nodes that have the extension, add lights field pointing to light object
    // and remove the extension
    for (const node of gltf.nodes || []) {
      const nodeExtension = node.extensions && node.extensions.KHR_lights_punctual;
      if (nodeExtension) {
        node.light = this._get('lights', nodeExtension.light);
        delete node.extensions.KHR_lights_punctual;
      }
    }

    delete gltf.lights;
  }

  // Removes an extension from the top-level list
  _removeExtension(extensionName) {
    if (this.gltf.extensionsRequired) {
      this._removeStringFromArray(this.gltf.extensionsRequired, extensionName);
    }
    if (this.gltf.extensionsUsed) {
      this._removeStringFromArray(this.gltf.extensionsUsed, extensionName);
    }
    if (this.gltf.extensions) {
      delete this.gltf.extensions[extensionName];
    }
  }

  _removeStringFromArray(array, string) {
    let found = true;
    while (found) {
      const index = array.indexOf(string);
      if (index > -1) {
        array.splice(index, 1);
      } else {
        found = false;
      }
    }
  }
}


/***/ }),

/***/ "./src/lib/deprecated/packed-json/flatten-to-typed-array.js":
/*!******************************************************************!*\
  !*** ./src/lib/deprecated/packed-json/flatten-to-typed-array.js ***!
  \******************************************************************/
/*! exports provided: flattenToTypedArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flattenToTypedArray", function() { return flattenToTypedArray; });
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

function flattenToTypedArray(nestedArray, ArrayType = Float32Array) {
  if (nestedArray.length === 0) {
    return new Float32Array(0);
  }

  if (!checkVertices(nestedArray)) {
    return null;
  }

  const count = countVertices(nestedArray);

  const typedArray = new ArrayType(count);
  flattenVerticesInPlace(nestedArray, typedArray);
  return typedArray;
}

function countVertices(nestedArray, dimensions = 3) {
  let nestedCount = 0;
  let localCount = 0;
  let index = -1;
  while (++index < nestedArray.length) {
    const value = nestedArray[index];
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      nestedCount += countVertices(value);
    } else {
      localCount++;
    }
  }
  return nestedCount + (nestedCount === 0 && localCount < dimensions ? dimensions : localCount);
}

function checkVertices(nestedArray, predicate = Number.isFinite) {
  let index = -1;
  while (++index < nestedArray.length) {
    const value = nestedArray[index];
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      if (!checkVertices(value, predicate)) {
        return false;
      }
    } else if (!predicate(value)) {
      return false;
    }
  }
  return true;
}

function flattenVerticesInPlace(nestedArray, result, dimensions = 3) {
  flattenVerticesInPlaceRecursive(nestedArray, result, dimensions, 0);
  return result;
}

// Flattens nested array of vertices, padding third coordinate as needed
function flattenVerticesInPlaceRecursive(nestedArray, result, dimensions, insert) {
  let index = -1;
  let vertexLength = 0;
  while (++index < nestedArray.length) {
    const value = nestedArray[index];
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      insert = flattenVerticesInPlaceRecursive(value, result, dimensions, insert);
    } else {
      // eslint-disable-next-line
      if (vertexLength < dimensions) {
        result[insert++] = value;
        vertexLength++;
      }
    }
  }
  // Add a third coordinate if needed
  if (vertexLength > 0 && vertexLength < dimensions) {
    result[insert++] = 0;
  }
  return insert;
}


/***/ }),

/***/ "./src/lib/deprecated/packed-json/pack-binary-json.js":
/*!************************************************************!*\
  !*** ./src/lib/deprecated/packed-json/pack-binary-json.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return packBinaryJson; });
/* harmony import */ var _flatten_to_typed_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./flatten-to-typed-array */ "./src/lib/deprecated/packed-json/flatten-to-typed-array.js");


// Recursively packs (replaces) binary objects
// Replaces "typed arrays" with "JSON pointers" to binary chunks tracked by glbBuilder
// eslint-disable-next-line complexity
function packBinaryJson(json, glbBuilder, options = {}) {
  const {flattenArrays = false} = options;
  let object = json;

  // Check if string has same syntax as our "JSON pointers", if so "escape it".
  if (typeof object === 'string' && object.indexOf('#/') === 0) {
    return `#${object}`;
  }

  if (Array.isArray(object)) {
    // TODO - handle numeric arrays, flatten them etc.
    const typedArray = flattenArrays && Object(_flatten_to_typed_array__WEBPACK_IMPORTED_MODULE_0__["flattenToTypedArray"])(object);
    if (typedArray) {
      object = typedArray;
    } else {
      return object.map(element => packBinaryJson(element, glbBuilder, options));
    }
  }

  // Typed arrays, pack them as binary
  if (ArrayBuffer.isView(object) && glbBuilder) {
    if (glbBuilder.isImage(object)) {
      const imageIndex = glbBuilder.addImage(object);
      return `#/images/${imageIndex}`;
    }

    // if not an image, pack as accessor
    const bufferIndex = glbBuilder.addBuffer(object);
    return `#/accessors/${bufferIndex}`;
  }

  if (object !== null && typeof object === 'object') {
    const newObject = {};
    for (const key in object) {
      newObject[key] = packBinaryJson(object[key], glbBuilder, options);
    }
    return newObject;
  }

  return object;
}


/***/ }),

/***/ "./src/lib/deprecated/packed-json/unpack-binary-json.js":
/*!**************************************************************!*\
  !*** ./src/lib/deprecated/packed-json/unpack-binary-json.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return unpackJsonArrays; });
function unpackJsonArrays(json, buffers, options = {}) {
  return unpackJsonArraysRecursive(json, json, buffers, options);
}

// Recursively unpacks objects, replacing "JSON pointers" with typed arrays
function unpackJsonArraysRecursive(json, topJson, buffers, options = {}) {
  const object = json;

  const buffer = decodeJSONPointer(object, buffers);
  if (buffer) {
    return buffer;
  }

  // Copy array
  if (Array.isArray(object)) {
    return object.map(element => unpackJsonArraysRecursive(element, topJson, buffers, options));
  }

  // Copy object
  if (object !== null && typeof object === 'object') {
    const newObject = {};
    for (const key in object) {
      newObject[key] = unpackJsonArraysRecursive(object[key], topJson, buffers, options);
    }
    return newObject;
  }

  return object;
}

function decodeJSONPointer(object, buffers) {
  const pointer = parseJSONPointer(object);
  if (pointer) {
    const [field, index] = pointer;
    const buffer = buffers[field] && buffers[field][index];
    if (buffer) {
      return buffer;
    }
    console.error(`Invalid JSON pointer ${object}: #/${field}/${index}`); // eslint-disable-line
  }
  return null;
}

function parseJSONPointer(value) {
  if (typeof value === 'string') {
    // Remove escape character
    if (value.indexOf('##/') === 0) {
      return value.slice(1);
    }

    let matches = value.match(/#\/([a-z]+)\/([0-9]+)/);
    if (matches) {
      const index = parseInt(matches[2], 10);
      return [matches[1], index];
    }

    // Legacy: `$$$i`
    matches = value.match(/\$\$\$([0-9]+)/);
    if (matches) {
      const index = parseInt(matches[1], 10);
      return ['accessors', index];
    }
  }

  return null;
}


/***/ }),

/***/ "./src/lib/deprecated/packed-json/unpack-gltf-buffers.js":
/*!***************************************************************!*\
  !*** ./src/lib/deprecated/packed-json/unpack-gltf-buffers.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return unpackGLBBuffers; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/assert */ "./src/lib/utils/assert.js");
/* harmony import */ var _gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../gltf-utils/gltf-utils */ "./src/lib/gltf-utils/gltf-utils.js");



function unpackGLBBuffers(arrayBuffer, json, binaryByteOffset) {
  // TODO - really inefficient, should just use the offset into the original array buffer
  if (binaryByteOffset) {
    arrayBuffer = getArrayBufferAtOffset(arrayBuffer, binaryByteOffset);
  }

  const bufferViews = json.bufferViews || [];

  for (let i = 0; i < bufferViews.length; ++i) {
    const bufferView = bufferViews[i];
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(bufferView.byteLength >= 0);
  }

  return {
    // TODO: delete unpackAccessors and use buffer views only?
    accessors: unpackAccessors(arrayBuffer, bufferViews, json),
    images: unpackImages(arrayBuffer, bufferViews, json)
  };
}

function unpackAccessors(arrayBuffer, bufferViews, json) {
  // unpack accessors
  const accessors = json.accessors || [];

  const accessorBuffers = [];

  for (let i = 0; i < accessors.length; ++i) {
    const accessor = accessors[i];
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(accessor);

    const bufferView = bufferViews[accessor.bufferView];
    // Draco encoded meshes don't have bufferView in accessor
    if (bufferView) {
      // Create a new typed array as a view into the combined buffer
      const {ArrayType, length} = Object(_gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_1__["getAccessorArrayTypeAndLength"])(accessor, bufferView);
      const array = new ArrayType(arrayBuffer, bufferView.byteOffset, length);
      // Store the metadata on the array (e.g. needed to determine number of components per element)
      array.accessor = accessor;
      accessorBuffers.push(array);
    }
  }

  return accessorBuffers;
}

function unpackImages(arrayBuffer, bufferViews, json) {
  // unpack images
  const images = json.images || [];

  const imageBuffers = [];

  for (let i = 0; i < images.length; ++i) {
    const image = images[i];
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(image);

    const bufferView = bufferViews[image.bufferView];
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(bufferView);

    // Create a new typed array as a view into the combined buffer
    const array = new Uint8Array(arrayBuffer, bufferView.byteOffset, bufferView.byteLength);
    // Store the metadata on the array (e.g. needed to determine number of components per element)
    array.imate = image;
    imageBuffers.push(array);
  }

  return imageBuffers;
}

// Helper methods

// json.accessors = json.accessors || [];
// json.bufferViews = json.bufferViews || [];

// Creates a new ArrayBuffer starting at the offset, containing all remaining bytes
// TODO - should not be needed, see above
function getArrayBufferAtOffset(arrayBuffer, byteOffset) {
  const length = arrayBuffer.byteLength - byteOffset;
  const binaryBuffer = new ArrayBuffer(length);
  const sourceArray = new Uint8Array(arrayBuffer);
  const binaryArray = new Uint8Array(binaryBuffer);
  for (let i = 0; i < length; i++) {
    binaryArray[i] = sourceArray[byteOffset + i];
  }
  return binaryBuffer;
}


/***/ }),

/***/ "./src/lib/encode-glb.js":
/*!*******************************!*\
  !*** ./src/lib/encode-glb.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return encodeGLBSync; });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../loader-utils/src/index.js");
/* eslint-disable camelcase, max-statements */


const MAGIC_glTF = 0x46546c67; // glTF in ASCII
const MAGIC_JSON = 0x4e4f534a; // JSON in ASCII
const MAGIC_BIN = 0x004e4942; // BIN\0 in ASCII

const LE = true; // Binary GLTF is little endian.

// Encode the full GLB buffer with header etc
// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#
// glb-file-format-specification
function encodeGLBSync(glb, dataView, byteOffset = 0, options = {}) {
  const {magic = MAGIC_glTF, version = 2, json = {}, binary} = glb;

  const byteOffsetStart = byteOffset;

  // Write GLB Header
  if (dataView) {
    dataView.setUint32(byteOffset + 0, magic, LE); // Magic number (the ASCII string 'glTF').
    dataView.setUint32(byteOffset + 4, version, LE); // Version 2 of binary glTF container format uint32
    dataView.setUint32(byteOffset + 8, 0, LE); // Total byte length of generated file (uint32), will be set last
  }
  const byteOffsetFileLength = byteOffset + 8;
  byteOffset += 12; // GLB_FILE_HEADER_SIZE

  // Write the JSON chunk header
  const byteOffsetJsonHeader = byteOffset;
  if (dataView) {
    dataView.setUint32(byteOffset + 0, 0, LE); // Byte length of json chunk (will be written later)
    dataView.setUint32(byteOffset + 4, MAGIC_JSON, LE); // Chunk type
  }
  byteOffset += 8; // GLB_CHUNK_HEADER_SIZE

  // Write the JSON chunk
  const jsonString = JSON.stringify(json);
  byteOffset = Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["copyPaddedStringToDataView"])(dataView, byteOffset, jsonString, 4);

  // Now we know the JSON chunk length so we can write it.
  if (dataView) {
    const jsonByteLength = byteOffset - byteOffsetJsonHeader - 8; // GLB_CHUNK_HEADER_SIZE
    dataView.setUint32(byteOffsetJsonHeader + 0, jsonByteLength, LE); // Byte length of json chunk (uint32)
  }

  // Write the BIN chunk if present. The BIN chunk is optional.
  if (binary) {
    const byteOffsetBinHeader = byteOffset;

    // Write the BIN chunk header
    if (dataView) {
      dataView.setUint32(byteOffset + 0, 0, LE); // Byte length BIN (uint32)
      dataView.setUint32(byteOffset + 4, MAGIC_BIN, LE); // Chunk type
    }
    byteOffset += 8; // GLB_CHUNK_HEADER_SIZE

    byteOffset = Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["copyPaddedArrayBufferToDataView"])(dataView, byteOffset, binary, 4);

    // Now we know the BIN chunk length so we can write it.
    if (dataView) {
      const binByteLength = byteOffset - byteOffsetBinHeader - 8; // GLB_CHUNK_HEADER_SIZE
      dataView.setUint32(byteOffsetBinHeader + 0, binByteLength, LE); // Byte length BIN (uint32)
    }
  }

  // Now we know the glb file length so we can write it.
  if (dataView) {
    const fileByteLength = byteOffset - byteOffsetStart;
    dataView.setUint32(byteOffsetFileLength, fileByteLength, LE); // Total byte length of generated file (uint32)
  }

  return byteOffset;
}


/***/ }),

/***/ "./src/lib/encode-gltf.js":
/*!********************************!*\
  !*** ./src/lib/encode-gltf.js ***!
  \********************************/
/*! exports provided: encodeGLTFSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeGLTFSync", function() { return encodeGLTFSync; });
/* harmony import */ var _encode_glb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./encode-glb */ "./src/lib/encode-glb.js");
/*
import {assert} from '@loaders.gl/core';
import {getImageSize} from '@loaders.gl/images';
import {isImage} from '@loaders.gl/images';

import {getAccessorTypeFromSize, getComponentTypeFromArray} from './gltf-utils/gltf-utils';
import {KHR_DRACO_MESH_COMPRESSION, UBER_POINT_CLOUD_EXTENSION} from './gltf-constants';

const DEFAULT_GTLF = {
  buffers: [],
  bufferViews: [],
  accessors: [],
  images: [],
  meshes: []
};
*/



// Encode the full glTF file as a binary GLB file
// Returns an ArrayBuffer that represents the complete GLB image that can be saved to file
//
// TODO - Does not support encoding to non-GLB versions of glTF format
// - Encode as a textual JSON file with binary data in base64 data URLs.
// - Encode as a JSON with all images (and buffers?) in separate binary files
//
// glb-file-format-specification
// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#

function encodeGLTFSync(gltf, arrayBuffer, byteOffset, options) {
  convertBuffersToBase64(gltf);

  // TODO: Copy buffers to binary

  return Object(_encode_glb__WEBPACK_IMPORTED_MODULE_0__["default"])(gltf, arrayBuffer, byteOffset, options);
}

function convertBuffersToBase64(gltf, {firstBuffer = 0} = {}) {
  if (gltf.buffers && gltf.buffers.length > firstBuffer) {
    throw new Error('encodeGLTF: multiple buffers not yet implemented');
  }
}


/***/ }),

/***/ "./src/lib/extensions/KHR_draco_mesh_compression.js":
/*!**********************************************************!*\
  !*** ./src/lib/extensions/KHR_draco_mesh_compression.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return KHR_draco_mesh_compression; });
/* harmony import */ var _gltf_scenegraph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../gltf-scenegraph */ "./src/lib/gltf-scenegraph.js");
/* harmony import */ var _gltf_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../gltf-constants */ "./src/lib/gltf-constants.js");
/* harmony import */ var _gltf_utils_gltf_attribute_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../gltf-utils/gltf-attribute-utils */ "./src/lib/gltf-utils/gltf-attribute-utils.js");
/* harmony import */ var _loaders_gl_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @loaders.gl/core */ "../core/src/index.js");
// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported

/* eslint-disable camelcase */





class KHR_draco_mesh_compression {
  static get name() {
    return _gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_DRACO_MESH_COMPRESSION"];
  }

  // Note: We have a "soft dependency" on Draco to avoid bundling it when not needed
  static async decode(gltfData, options = {}) {
    if (!options.decompress) {
      return;
    }

    const scenegraph = new _gltf_scenegraph__WEBPACK_IMPORTED_MODULE_0__["default"](gltfData);
    const promises = [];
    for (const primitive of meshPrimitiveIterator(scenegraph)) {
      if (scenegraph.getObjectExtension(primitive, _gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_DRACO_MESH_COMPRESSION"])) {
        promises.push(decompressPrimitive(primitive, scenegraph, options));
      }
    }

    // Decompress meshes in parallel
    await Promise.all(promises);

    // We have now decompressed all primitives, so remove the top-level extensions
    scenegraph.removeExtension(_gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_DRACO_MESH_COMPRESSION"]);
  }

  static decodeSync(gltfData, options) {
    if (!options.decompress) {
      return;
    }
    const scenegraph = new _gltf_scenegraph__WEBPACK_IMPORTED_MODULE_0__["default"](gltfData);
    if (scenegraph.getRequiredExtension(_gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_DRACO_MESH_COMPRESSION"])) {
      throw new Error('Cannot synchronously decode Draco');
    }
    // TODO - we can support sync decoding, let's just keep code/bundle size in check...
  }

  static encode(gltfData, options = {}) {
    const scenegraph = new _gltf_scenegraph__WEBPACK_IMPORTED_MODULE_0__["default"](gltfData);

    for (const mesh of scenegraph.json.meshes || []) {
      // eslint-disable-next-line camelcase
      compressMesh(mesh, options);
      // NOTE: Only add the extension if something was actually compressed
      scenegraph.addRequiredExtension(_gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_DRACO_MESH_COMPRESSION"]);
    }
  }
}

// PRIVATE

// Unpacks one mesh primitive and removes the extension from the primitive
// DracoDecoder needs to be imported and registered by app
// Returns: Promise that resolves when all pending draco decoder jobs for this mesh complete

// TODO - Implement fallback behavior per KHR_DRACO_MESH_COMPRESSION spec

async function decompressPrimitive(primitive, scenegraph, options) {
  const compressedPrimitive = scenegraph.getObjectExtension(primitive, _gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_DRACO_MESH_COMPRESSION"]);

  // eslint-disable-next-line
  const buffer = scenegraph.getTypedArrayForBufferView(compressedPrimitive.bufferView);

  // TODO - parse does not yet deal well with byte offsets embedded in typed arrays. Copy buffer
  const subArray = new Uint8Array(buffer.buffer).subarray(buffer.byteOffset); // , buffer.byteLength);
  const bufferCopy = new Uint8Array(subArray);

  const decodedData = await Object(_loaders_gl_core__WEBPACK_IMPORTED_MODULE_3__["parse"])(bufferCopy);

  primitive.attributes = Object(_gltf_utils_gltf_attribute_utils__WEBPACK_IMPORTED_MODULE_2__["getGLTFAccessors"])(decodedData.attributes);
  if (decodedData.indices) {
    primitive.indices = Object(_gltf_utils_gltf_attribute_utils__WEBPACK_IMPORTED_MODULE_2__["getGLTFAccessor"])(decodedData.indices);
  }

  // Extension has been processed, delete it
  // delete primitive.extensions[KHR_DRACO_MESH_COMPRESSION];

  checkPrimitive(primitive);
}

// eslint-disable-next-line max-len
// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported
function compressMesh(attributes, indices, mode = 4, options = {}) {
  if (!options.DracoWriter || !options.DracoLoader) {
    throw new Error('DracoWriter/DracoLoader not available');
  }

  // TODO - use registered DracoWriter...
  const compressedData = options.DracoWriter.encodeSync({attributes});

  // Draco compression may change the order and number of vertices in a mesh.
  // To satisfy the requirement that accessors properties be correct for both
  // compressed and uncompressed data, generators should create uncompressed
  // attributes and indices using data that has been decompressed from the Draco buffer,
  // rather than the original source data.
  const decodedData = options.DracoLoader.parseSync({attributes});
  const fauxAccessors = options._addFauxAttributes(decodedData.attributes);

  const bufferViewIndex = options.addBufferView(compressedData);

  const glTFMesh = {
    primitives: [
      {
        attributes: fauxAccessors, // TODO - verify with spec
        mode, // GL.POINTS
        extensions: {
          [_gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_DRACO_MESH_COMPRESSION"]]: {
            bufferView: bufferViewIndex,
            attributes: fauxAccessors // TODO - verify with spec
          }
        }
      }
    ]
  };

  return glTFMesh;
}

function checkPrimitive(primitive) {
  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {
    throw new Error('Empty glTF primitive detected: Draco decompression failure?');
  }
}

function* meshPrimitiveIterator(scenegraph) {
  for (const mesh of scenegraph.json.meshes || []) {
    for (const primitive of mesh.primitives) {
      yield primitive;
    }
  }
}


/***/ }),

/***/ "./src/lib/extensions/KHR_lights_punctual.js":
/*!***************************************************!*\
  !*** ./src/lib/extensions/KHR_lights_punctual.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return KHR_lights_punctual; });
/* harmony import */ var _gltf_scenegraph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../gltf-scenegraph */ "./src/lib/gltf-scenegraph.js");
/* harmony import */ var _gltf_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../gltf-constants */ "./src/lib/gltf-constants.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/assert */ "./src/lib/utils/assert.js");




// GLTF EXTENSION: KHR_lights_punctual
// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
// eslint-disable-next-line camelcase
class KHR_lights_punctual {
  static get name() {
    return _gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_LIGHTS_PUNCTUAL"];
  }

  static decode(gltfData, options) {
    const gltfScenegraph = new _gltf_scenegraph__WEBPACK_IMPORTED_MODULE_0__["default"](gltfData);

    // Move the light array out of the extension and remove the extension
    const extension = gltfScenegraph.getExtension(_gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_LIGHTS_PUNCTUAL"]);
    if (extension) {
      gltfScenegraph.json.lights = extension.lights;
      gltfScenegraph.removeExtension(_gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_LIGHTS_PUNCTUAL"]);
    }

    // Any nodes that have the extension, add lights field pointing to light object
    // and remove the extension
    for (const node of gltfScenegraph.nodes || []) {
      const nodeExtension = node.extensions && node.extensions.KHR_lights_punctual;
      if (nodeExtension) {
        node.light = gltfScenegraph._get('lights', nodeExtension.light);
        delete node.extensions.KHR_lights_punctual;
      }
    }
  }

  // Move the light ar ray out of the extension and remove the extension
  static encode(gltfData, options) {
    const gltfScenegraph = new _gltf_scenegraph__WEBPACK_IMPORTED_MODULE_0__["default"](gltfData);
    const {json} = gltfScenegraph;

    if (json.lights) {
      const extension = gltfScenegraph.addExtensions(_gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_LIGHTS_PUNCTUAL"]);
      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(!extension.lights);
      extension.lights = json.lights;
      delete json.lights;
    }

    // Any nodes that have lights field pointing to light object
    // add the extension
    if (gltfScenegraph.json.lights) {
      for (const light of gltfScenegraph.json.lights) {
        const node = light.node;
        gltfScenegraph.addObjectExtension(node, _gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_LIGHTS_PUNCTUAL"], light);
      }
      delete gltfScenegraph.json.lights;
    }
  }
}


/***/ }),

/***/ "./src/lib/extensions/extensions.js":
/*!******************************************!*\
  !*** ./src/lib/extensions/extensions.js ***!
  \******************************************/
/*! exports provided: EXTENSIONS, decodeExtensions, decodeExtensionsSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EXTENSIONS", function() { return EXTENSIONS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeExtensions", function() { return decodeExtensions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeExtensionsSync", function() { return decodeExtensionsSync; });
/* harmony import */ var _KHR_draco_mesh_compression__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./KHR_draco_mesh_compression */ "./src/lib/extensions/KHR_draco_mesh_compression.js");
/* harmony import */ var _KHR_lights_punctual__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./KHR_lights_punctual */ "./src/lib/extensions/KHR_lights_punctual.js");
/* eslint-disable camelcase */


// import UBER_POINT_CLOUD_COMPRESSION from './KHR_draco_mesh_compression';

const EXTENSIONS = {
  KHR_draco_mesh_compression: _KHR_draco_mesh_compression__WEBPACK_IMPORTED_MODULE_0__["default"],
  KHR_lights_punctual: _KHR_lights_punctual__WEBPACK_IMPORTED_MODULE_1__["default"]
};

async function decodeExtensions(gltf, options) {
  for (const extensionName in EXTENSIONS) {
    const disableExtension = extensionName in options && !options[extensionName];
    if (!disableExtension) {
      const extension = EXTENSIONS[extensionName];
      // Note: We decode extensions sequentially, this might not be necessary
      // Currently we only have glTF, but when we add Basis we may revisit
      await extension.decode(gltf, options);
      // TODO - warn if extension cannot be decoded synchronously?
    }
  }
}

function decodeExtensionsSync(gltf, options) {
  for (const extensionName in EXTENSIONS) {
    const disableExtension = extensionName in options && !options[extensionName];
    if (!disableExtension) {
      const extension = EXTENSIONS[extensionName];
      extension.decodeSync(gltf, options);
    }
  }
}


/***/ }),

/***/ "./src/lib/gltf-constants.js":
/*!***********************************!*\
  !*** ./src/lib/gltf-constants.js ***!
  \***********************************/
/*! exports provided: KHR_DRACO_MESH_COMPRESSION, UBER_POINT_CLOUD_EXTENSION, KHR_LIGHTS_PUNCTUAL, getBytesFromComponentType, getSizeFromAccessorType, getGLEnumFromSamplerParameter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KHR_DRACO_MESH_COMPRESSION", function() { return KHR_DRACO_MESH_COMPRESSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UBER_POINT_CLOUD_EXTENSION", function() { return UBER_POINT_CLOUD_EXTENSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KHR_LIGHTS_PUNCTUAL", function() { return KHR_LIGHTS_PUNCTUAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBytesFromComponentType", function() { return getBytesFromComponentType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSizeFromAccessorType", function() { return getSizeFromAccessorType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGLEnumFromSamplerParameter", function() { return getGLEnumFromSamplerParameter; });
// GLTF extension

// Ideally we should just use KHR_draco_mesh_compression, but it does not support point clouds
const KHR_DRACO_MESH_COMPRESSION = 'KHR_draco_mesh_compression';
const UBER_POINT_CLOUD_EXTENSION = 'UBER_draco_point_cloud_compression';
const KHR_LIGHTS_PUNCTUAL = 'KHR_lights_punctual';

const COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};

const BYTES = {
  5120: 1, // BYTE
  5121: 1, // UNSIGNED_BYTE
  5122: 2, // SHORT
  5123: 2, // UNSIGNED_SHORT
  5125: 4, // UNSIGNED_INT
  5126: 4 // FLOAT
};

// ENUM LOOKUP

function getBytesFromComponentType(componentType) {
  return BYTES[componentType];
}

function getSizeFromAccessorType(type) {
  return COMPONENTS[type];
}

function getGLEnumFromSamplerParameter(parameter) {
  const GL_TEXTURE_MAG_FILTER = 0x2800;
  const GL_TEXTURE_MIN_FILTER = 0x2801;
  const GL_TEXTURE_WRAP_S = 0x2802;
  const GL_TEXTURE_WRAP_T = 0x2803;

  const PARAMETER_MAP = {
    magFilter: GL_TEXTURE_MAG_FILTER,
    minFilter: GL_TEXTURE_MIN_FILTER,
    wrapS: GL_TEXTURE_WRAP_S,
    wrapT: GL_TEXTURE_WRAP_T
  };

  return PARAMETER_MAP[parameter];
}


/***/ }),

/***/ "./src/lib/gltf-scenegraph.js":
/*!************************************!*\
  !*** ./src/lib/gltf-scenegraph.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GLTFScenegraph; });
/* harmony import */ var _loaders_gl_images__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/images */ "../images/src/index.js");
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../loader-utils/src/index.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/assert */ "./src/lib/utils/assert.js");
/* harmony import */ var _gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./gltf-utils/gltf-utils */ "./src/lib/gltf-utils/gltf-utils.js");





// Class for structured access to GLTF data
class GLTFScenegraph {
  constructor(gltf) {
    // Signature: new GLTFScenegraph(data : GLTFScenegraph)
    // Allow utilities to create a GLTFScenegraph object from gltf data without checking
    if (gltf instanceof GLTFScenegraph) {
      return gltf;
    }

    if (!gltf) {
      gltf = {
        json: {
          version: 2,
          buffers: []
        },
        buffers: []
      };
    }

    // TODO - this is too sloppy, define inputs more clearly
    this.gltf = gltf;
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(this.gltf.json);
  }

  // Accessors

  get json() {
    return this.gltf.json;
  }

  getApplicationData(key) {
    // TODO - Data is already unpacked by GLBParser
    const data = this.json[key];
    return data;
  }

  getExtraData(key) {
    // TODO - Data is already unpacked by GLBParser
    const extras = this.json.extras || {};
    return extras[key];
  }

  getExtension(extensionName) {
    const isExtension = this.getUsedExtensions().find(name => name === extensionName);
    const extensions = this.json.extensions || {};
    return isExtension ? extensions[extensionName] || true : null;
  }

  getRequiredExtension(extensionName) {
    const isRequired = this.getRequiredExtensions().find(name => name === extensionName);
    return isRequired ? this.getExtension(extensionName) : null;
  }

  getRequiredExtensions() {
    return this.json.extensionsRequired || [];
  }

  getUsedExtensions() {
    return this.json.extensionsUsed || [];
  }

  getObjectExtension(object, extensionName) {
    const extensions = object.extensions || {};
    return extensions[extensionName];
  }

  getScene(index) {
    return this.getObject('scenes', index);
  }

  getNode(index) {
    return this.getObject('nodes', index);
  }

  getSkin(index) {
    return this.getObject('skins', index);
  }

  getMesh(index) {
    return this.getObject('meshes', index);
  }

  getMaterial(index) {
    return this.getObject('materials', index);
  }

  getAccessor(index) {
    return this.getObject('accessors', index);
  }

  getCamera(index) {
    return null; // TODO: fix this
  }

  getTexture(index) {
    return this.getObject('textures', index);
  }

  getSampler(index) {
    return this.getObject('samplers', index);
  }

  getImage(index) {
    return this.getObject('images', index);
  }

  getBufferView(index) {
    return this.getObject('bufferViews', index);
  }

  getBuffer(index) {
    return this.getObject('buffers', index);
  }

  getObject(array, index) {
    // check if already resolved
    if (typeof index === 'object') {
      return index;
    }
    const object = this.json[array] && this.json[array][index];
    if (!object) {
      throw new Error(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line
    }
    return object;
  }

  // accepts buffer view index or buffer view object
  // returns a `Uint8Array`
  getTypedArrayForBufferView(bufferView) {
    bufferView = this.getBufferView(bufferView);
    const bufferIndex = bufferView.buffer;

    // Get hold of the arrayBuffer
    // const buffer = this.getBuffer(bufferIndex);
    const binChunk = this.gltf.buffers[bufferIndex];
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(binChunk);

    const byteOffset = bufferView.byteOffset || 0 + binChunk.byteOffset;
    return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);
  }

  // accepts accessor index or accessor object
  // returns a typed array with type that matches the types
  getTypedArrayForAccessor(accessor) {
    accessor = this.getAccessor(accessor);
    const bufferView = this.getBuffer(accessor.bufferView);
    const buffer = this.getBuffer(bufferView.buffer);
    const arrayBuffer = buffer.data;

    // Create a new typed array as a view into the combined buffer
    const {ArrayType, length} = Object(_gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_3__["getAccessorArrayTypeAndLength"])(accessor, bufferView);
    const byteOffset = bufferView.byteOffset + accessor.byteOffset;
    return new ArrayType(arrayBuffer, byteOffset, length);
  }

  // accepts accessor index or accessor object
  // returns a `Uint8Array`
  getTypedArrayForImageData(image) {
    image = this.getAccessor(image);
    const bufferView = this.getBuffer(image.bufferView);
    const buffer = this.getBuffer(bufferView.buffer);
    const arrayBuffer = buffer.data;

    const byteOffset = bufferView.byteOffset || 0;
    return new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);
  }

  // MODIFERS

  // Add an extra application-defined key to the top-level data structure
  addApplicationData(key, data) {
    this.json[key] = data;
    return this;
  }

  // `extras` - Standard GLTF field for storing application specific data
  addExtraData(key, data) {
    this.json.extras = this.json.extras || {};
    this.json.extras[key] = data;
    return this;
  }

  // Add to standard GLTF top level extension object, mark as used
  addExtension(extensionName, data) {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(data);
    this.json.extensions = this.json.extensions || {};
    this.json.extensions[extensionName] = data;
    this.registerUsedExtension(extensionName);
    return this;
  }

  // Standard GLTF top level extension object, mark as used and required
  addRequiredExtension(extensionName, data) {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(data);
    this.addExtension(extensionName, data);
    this.registerRequiredExtension(extensionName);
    return this;
  }

  // Add extensionName to list of used extensions
  registerUsedExtension(extensionName) {
    this.json.extensionsUsed = this.json.extensionsUsed || [];
    if (!this.json.extensionsUsed.find(ext => ext === extensionName)) {
      this.json.extensionsUsed.push(extensionName);
    }
  }

  // Add extensionName to list of required extensions
  registerRequiredExtension(extensionName) {
    this.registerUsedExtension(extensionName);
    this.json.extensionsRequired = this.json.extensionsRequired || [];
    if (!this.json.extensionsRequired.find(ext => ext === extensionName)) {
      this.json.extensionsRequired.push(extensionName);
    }
  }

  // Removes an extension from the top-level list
  removeExtension(extensionName) {
    if (this.json.extensionsRequired) {
      this._removeStringFromArray(this.json.extensionsRequired, extensionName);
    }
    if (this.json.extensionsUsed) {
      this._removeStringFromArray(this.json.extensionsUsed, extensionName);
    }
    if (this.json.extensions) {
      delete this.json.extensions[extensionName];
    }
  }

  setObjectExtension(object, extensionName, data) {
    const extensions = object.extensions || {};
    extensions[extensionName] = data;
    // TODO - add to usedExtensions...
  }

  addMesh(attributes, indices, mode = 4) {
    const accessors = this._addAttributes(attributes);

    const glTFMesh = {
      primitives: [
        {
          attributes: accessors,
          indices,
          mode
        }
      ]
    };

    this.json.meshes = this.json.meshes || [];
    this.json.meshes.push(glTFMesh);
    return this.json.meshes.length - 1;
  }

  addPointCloud(attributes) {
    const accessorIndices = this._addAttributes(attributes);

    const glTFMesh = {
      primitives: [
        {
          attributes: accessorIndices,
          mode: 0 // GL.POINTS
        }
      ]
    };

    this.json.meshes = this.json.meshes || [];
    this.json.meshes.push(glTFMesh);
    return this.json.meshes.length - 1;
  }

  // Adds a binary image. Builds glTF "JSON metadata" and saves buffer reference
  // Buffer will be copied into BIN chunk during "pack"
  // Currently encodes as glTF image
  addImage(imageData, mimeType) {
    // If image is referencing a bufferView instead of URI, mimeType must be defined:
    //   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#images
    //   "a reference to a bufferView; in that case mimeType must be defined."
    mimeType = mimeType || Object(_loaders_gl_images__WEBPACK_IMPORTED_MODULE_0__["getImageMIMEType"])(imageData);

    const bufferViewIndex = this.addBufferView(imageData);

    const glTFImage = {
      bufferView: bufferViewIndex,
      mimeType
    };

    this.json.images = this.json.images || [];
    this.json.images.push(glTFImage);
    return this.json.images.length - 1;
  }

  // Add one untyped source buffer, create a matching glTF `bufferView`, and return its index
  addBufferView(buffer) {
    const byteLength = buffer.byteLength;
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(Number.isFinite(byteLength));

    // Add this buffer to the list of buffers to be written to the body.
    this.sourceBuffers = this.sourceBuffers || [];
    this.sourceBuffers.push(buffer);

    const glTFBufferView = {
      buffer: 0,
      // Write offset from the start of the binary body
      byteOffset: this.byteLength,
      byteLength
    };

    // We've now added the contents to the body, so update the total length
    // Every sub-chunk needs to be 4-byte align ed
    this.byteLength += Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__["padTo4Bytes"])(byteLength);

    // Add a bufferView indicating start and length of this binary sub-chunk
    this.json.bufferViews = this.json.bufferViews || [];
    this.json.bufferViews.push(glTFBufferView);
    return this.json.bufferViews.length - 1;
  }

  // Adds an accessor to a bufferView
  addAccessor(bufferViewIndex, accessor) {
    const glTFAccessor = {
      bufferView: bufferViewIndex,
      type: Object(_gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_3__["getAccessorTypeFromSize"])(accessor.size),
      componentType: accessor.componentType,
      count: accessor.count
    };

    this.json.accessors = this.json.accessors || [];
    this.json.accessors.push(glTFAccessor);
    return this.json.accessors.length - 1;
  }

  // Add a binary buffer. Builds glTF "JSON metadata" and saves buffer reference
  // Buffer will be copied into BIN chunk during "pack"
  // Currently encodes buffers as glTF accessors, but this could be optimized
  addBinaryBuffer(sourceBuffer, accessor = {size: 3}) {
    const bufferViewIndex = this.addBufferView(sourceBuffer);

    const accessorDefaults = {
      size: accessor.size,
      componentType: Object(_gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_3__["getComponentTypeFromArray"])(sourceBuffer),
      count: Math.round(sourceBuffer.length / accessor.size)
    };

    return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));
  }

  // Pack the binary chunk
  createBinaryChunk() {
    // Already packed
    if (this.arrayBuffer) {
      return;
    }

    // Allocate total array
    const totalByteLength = this.byteLength;
    const arrayBuffer = new ArrayBuffer(totalByteLength);
    const targetArray = new Uint8Array(arrayBuffer);

    // Copy each array into
    let dstByteOffset = 0;
    for (let i = 0; i < this.sourceBuffers.length; i++) {
      const sourceBuffer = this.sourceBuffers[i];
      dstByteOffset = Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__["copyToArray"])(sourceBuffer, targetArray, dstByteOffset);
    }

    // Update the glTF BIN CHUNK byte length
    this.json.buffers[0].byteLength = totalByteLength;

    // Save generated arrayBuffer
    this.arrayBuffer = arrayBuffer;

    // Clear out sourceBuffers
    this.sourceBuffers = [];
  }

  // PRIVATE

  _removeStringFromArray(array, string) {
    let found = true;
    while (found) {
      const index = array.indexOf(string);
      if (index > -1) {
        array.splice(index, 1);
      } else {
        found = false;
      }
    }
  }
}


/***/ }),

/***/ "./src/lib/gltf-utils/gltf-attribute-utils.js":
/*!****************************************************!*\
  !*** ./src/lib/gltf-utils/gltf-attribute-utils.js ***!
  \****************************************************/
/*! exports provided: getGLTFAccessors, getGLTFAccessor, getGLTFAttribute */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGLTFAccessors", function() { return getGLTFAccessors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGLTFAccessor", function() { return getGLTFAccessor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGLTFAttribute", function() { return getGLTFAttribute; });
/* harmony import */ var _gltf_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gltf-utils */ "./src/lib/gltf-utils/gltf-utils.js");
// TODO - remove


// Returns a fresh attributes object with glTF-standardized attributes names
// Attributes that cannot be identified will not be included
// Removes `indices` if present, as it should be stored separately from the attributes
function getGLTFAccessors(attributes) {
  const accessors = {};
  for (const name in attributes) {
    const attribute = attributes[name];
    if (name !== 'indices') {
      const glTFAccessor = getGLTFAccessor(attribute);
      accessors[name] = glTFAccessor;
    }
  }
  return accessors;
}

// Fix up a single accessor.
// Input: typed array or a partial accessor object
// Return: accessor object
function getGLTFAccessor(attribute, gltfAttributeName) {
  const {buffer, size, count} = getAccessorData(attribute, gltfAttributeName);

  const glTFAccessor = {
    // TODO: Deprecate `value` in favor of bufferView?
    value: buffer,
    size, // Decoded `type` (e.g. SCALAR)

    // glTF Accessor values
    // TODO: Instead of a bufferView index we could have an actual buffer (typed array)
    bufferView: null,
    byteOffset: 0,
    count,
    type: Object(_gltf_utils__WEBPACK_IMPORTED_MODULE_0__["getAccessorTypeFromSize"])(size),
    componentType: Object(_gltf_utils__WEBPACK_IMPORTED_MODULE_0__["getComponentTypeFromArray"])(buffer)
  };

  return glTFAccessor;
}

function getGLTFAttribute(data, gltfAttributeName) {
  return data.attributes[data.glTFAttributeMap[gltfAttributeName]];
}

function getAccessorData(attribute, attributeName) {
  let buffer = attribute;
  let size = 1;
  let count = 0;

  if (attribute && attribute.value) {
    buffer = attribute.value;
    size = attribute.size || 1;
  }

  if (buffer) {
    if (!ArrayBuffer.isView(buffer)) {
      buffer = toTypedArray(buffer, Float32Array);
    }
    count = buffer.length / size;
  }

  return {buffer, size, count};
}

// Convert non-typed arrays to arrays of specified format
function toTypedArray(array, ArrayType, convertTypedArrays = false) {
  if (!array) {
    return null;
  }
  if (Array.isArray(array)) {
    return new ArrayType(array);
  }
  if (convertTypedArrays && !(array instanceof ArrayType)) {
    return new ArrayType(array);
  }
  return array;
}


/***/ }),

/***/ "./src/lib/gltf-utils/gltf-utils.js":
/*!******************************************!*\
  !*** ./src/lib/gltf-utils/gltf-utils.js ***!
  \******************************************/
/*! exports provided: ATTRIBUTE_TYPE_TO_COMPONENTS, ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE, ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY, getAccessorTypeFromSize, getComponentTypeFromArray, getAccessorArrayTypeAndLength, getFullUri */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ATTRIBUTE_TYPE_TO_COMPONENTS", function() { return ATTRIBUTE_TYPE_TO_COMPONENTS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE", function() { return ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY", function() { return ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAccessorTypeFromSize", function() { return getAccessorTypeFromSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getComponentTypeFromArray", function() { return getComponentTypeFromArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAccessorArrayTypeAndLength", function() { return getAccessorArrayTypeAndLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFullUri", function() { return getFullUri; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "./src/lib/utils/assert.js");


const TYPES = ['SCALAR', 'VEC2', 'VEC3', 'VEC4'];

const ARRAY_TO_COMPONENT_TYPE = new Map([
  [Int8Array, 5120],
  [Uint8Array, 5121],
  [Int16Array, 5122],
  [Uint16Array, 5123],
  [Uint32Array, 5125],
  [Float32Array, 5126]
]);

const ATTRIBUTE_TYPE_TO_COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};

const ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
};

const ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};

function getAccessorTypeFromSize(size) {
  const type = TYPES[size - 1];
  return type || TYPES[0];
}

function getComponentTypeFromArray(typedArray) {
  const componentType = ARRAY_TO_COMPONENT_TYPE.get(typedArray.constructor);
  if (!componentType) {
    throw new Error('Illegal typed array');
  }
  return componentType;
}

function getAccessorArrayTypeAndLength(accessor, bufferView) {
  const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];
  const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];
  const bytesPerComponent = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[accessor.componentType];
  const length = accessor.count * components;
  const byteLength = accessor.count * components * bytesPerComponent;
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(byteLength >= 0 && byteLength <= bufferView.byteLength);
  return {ArrayType, length, byteLength};
}

function getFullUri(uri, base) {
  // TODO: Use better logic to handle all protocols plus not delay on data
  const absolute = uri.startsWith('data:') || uri.startsWith('http:') || uri.startsWith('https:');
  return absolute ? uri : base.substr(0, base.lastIndexOf('/') + 1) + uri;
}


/***/ }),

/***/ "./src/lib/parse-glb.js":
/*!******************************!*\
  !*** ./src/lib/parse-glb.js ***!
  \******************************/
/*! exports provided: isGLB, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isGLB", function() { return isGLB; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseGLBSync; });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../loader-utils/src/index.js");
/* eslint-disable camelcase, max-statements */
/* global TextDecoder */


const MAGIC_glTF = 0x676c5446; // glTF in Big-Endian ASCII

const GLB_FILE_HEADER_SIZE = 12;
const GLB_CHUNK_HEADER_SIZE = 8;

const GLB_CHUNK_TYPE_JSON = 0x4e4f534a;
const GLB_CHUNK_TYPE_BIN = 0x004e4942;

const LE = true; // Binary GLTF is little endian.

function getMagicString(dataView, byteOffset = 0) {
  return `\
${String.fromCharCode(dataView.getUint8(byteOffset + 0))}\
${String.fromCharCode(dataView.getUint8(byteOffset + 1))}\
${String.fromCharCode(dataView.getUint8(byteOffset + 2))}\
${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;
}

// Check if a data view is a GLB
function isGLB(arrayBuffer, byteOffset = 0, options = {}) {
  const dataView = new DataView(arrayBuffer);
  // Check that GLB Header starts with the magic number
  const {magic = MAGIC_glTF} = options;
  const magic1 = dataView.getUint32(byteOffset, false);
  return magic1 === magic || magic1 === MAGIC_glTF;
}

// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#glb-file-format-specification

// Compare with GLB loader documentation
/*
Returns {
  header: {
    type: string,
    magic: number,
    byteLength: number,
    byteOffset: number
  },

  version: number,

  // JSON Chunk
  json: any,

  // BIN Chunk
  hasBinChunk: boolean,
  binChunks: [{
    arrayBuffer,
    byteOffset,
    byteLength
  }],

  // Deprecated (duplicates header)
  type: string,
  magic: number,
  version: number,
  byteLength: number,
  byteOffset: number,
  binChunkByteOffset: number,
  binChunkLength: number
}
*/

function parseGLBSync(glb, arrayBuffer, byteOffset = 0, options = {}) {
  // Check that GLB Header starts with the magic number
  const dataView = new DataView(arrayBuffer);

  glb.type = getMagicString(dataView, byteOffset + 0);
  glb.version = dataView.getUint32(byteOffset + 4, LE); // Version 2 of binary glTF container format
  const byteLength = dataView.getUint32(byteOffset + 8, LE); // Total byte length of generated file

  // Less important stuff in a header
  glb.header = {
    byteOffset, // Byte offset into the initial arrayBuffer
    byteLength
  };

  if (glb.type !== 'glTF') {
    console.warn(`Invalid GLB magic string ${glb.type}`); // eslint-disable-line
  }

  Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(glb.version === 2, `Invalid GLB version ${glb.version}. Only .glb v2 supported`);
  Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);

  // Per spec we must iterate over chunks, ignoring all except JSON and BIN
  glb.json = {};
  glb.hasBinChunk = false;
  glb.binChunks = [];

  parseGLBChunksSync(glb, dataView, byteOffset + 12, options);

  // DEPRECATED - duplicate header fields in root of returned object
  addDeprecatedFields(glb);

  return byteOffset + glb.header.byteLength;
}

function parseGLBChunksSync(glb, dataView, byteOffset, options) {
  // Iterate as long as there is space left for another chunk header
  while (byteOffset + 8 <= glb.header.byteLength) {
    const chunkLength = dataView.getUint32(byteOffset + 0, LE); // Byte length of chunk
    const chunkFormat = dataView.getUint32(byteOffset + 4, LE); // Chunk format as uint32
    byteOffset += GLB_CHUNK_HEADER_SIZE;

    // Per spec we must iterate over chunks, ignoring all except JSON and BIN
    switch (chunkFormat) {
      case GLB_CHUNK_TYPE_JSON:
        parseJSONChunk(glb, dataView, byteOffset, chunkLength, options);
        break;
      case GLB_CHUNK_TYPE_BIN:
        parseBINChunk(glb, dataView, byteOffset, chunkLength, options);
        break;
      default:
        // Ignore, per spec
        // console.warn(`Unknown GLB chunk type`); // eslint-disable-line
        break;
    }

    // DEPRECATED - Backward compatibility for very old xviz files
    switch (chunkFormat) {
      case 0:
        if (!options.strict) {
          parseJSONChunk(glb, dataView, byteOffset, chunkLength, options);
        }
        break;
      case 1:
        if (!options.strict) {
          parseBINChunk(glb, dataView, byteOffset, chunkLength, options);
        }
        break;
      default:
    }

    byteOffset += Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["padTo4Bytes"])(chunkLength);
  }

  return byteOffset;
}

// Parse a GLB JSON chunk
function parseJSONChunk(glb, dataView, byteOffset, chunkLength, options) {
  // 1. Create a "view" of the binary encoded JSON data inside the GLB
  const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);

  // 2. Decode the JSON binary array into clear text
  const textDecoder = new TextDecoder('utf8');
  const jsonText = textDecoder.decode(jsonChunk);

  // 3. Parse the JSON text into a JavaScript data structure
  glb.json = JSON.parse(jsonText);
}

// Parse a GLB BIN chunk
function parseBINChunk(glb, dataView, byteOffset, chunkLength, options) {
  // Note: BIN chunk can be optional
  glb.header.hasBinChunk = true;
  glb.binChunks.push({
    byteOffset,
    byteLength: chunkLength,
    arrayBuffer: dataView.buffer
    // TODO - copy, or create typed array view?
  });
}

function addDeprecatedFields(glb) {
  glb.byteOffset = glb.header.byteOffset;
  glb.magic = glb.header.magic;
  glb.version = glb.header.version;
  glb.byteLength = glb.header.byteLength;
  glb.hasBinChunk = glb.binChunks.length >= 1;
  glb.binChunkByteOffset = glb.header.hasBinChunk ? glb.binChunks[0].byteOffset : 0;
  glb.binChunkLength = glb.header.hasBinChunk ? glb.binChunks[0].byteLength : 0;
}


/***/ }),

/***/ "./src/lib/parse-gltf.js":
/*!*******************************!*\
  !*** ./src/lib/parse-gltf.js ***!
  \*******************************/
/*! exports provided: isGLTF, parseGLTF, parseGLTFSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isGLTF", function() { return isGLTF; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseGLTF", function() { return parseGLTF; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseGLTFSync", function() { return parseGLTFSync; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/assert */ "./src/lib/utils/assert.js");
/* harmony import */ var _gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gltf-utils/gltf-utils */ "./src/lib/gltf-utils/gltf-utils.js");
/* harmony import */ var _extensions_extensions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extensions/extensions */ "./src/lib/extensions/extensions.js");
/* harmony import */ var _parse_glb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parse-glb */ "./src/lib/parse-glb.js");
/* harmony import */ var _post_process_gltf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./post-process-gltf */ "./src/lib/post-process-gltf.js");
/* eslint-disable camelcase, max-statements, no-restricted-globals */
/* global TextDecoder */






const DEFAULT_OPTIONS = {
  fetchLinkedResources: true, // Fetch any linked .BIN buffers, decode base64
  fetchImages: false, // Fetch any linked .BIN buffers, decode base64
  createImages: false, // Create image objects
  decompress: false, // Decompress Draco compressed meshes
  postProcess: false,
  log: console // eslint-disable-line
};

function isGLTF(arrayBuffer, options = {}) {
  const dataView = new DataView(arrayBuffer);
  const byteOffset = 0;
  return Object(_parse_glb__WEBPACK_IMPORTED_MODULE_3__["isGLB"])(dataView, byteOffset);
}

async function parseGLTF(gltf, arrayBufferOrString, byteOffset = 0, options, context) {
  options = {...DEFAULT_OPTIONS, ...options.gltf};

  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);

  const promises = [];

  if (options.fetchImages) {
    const promise = fetchImages(gltf, options, context);
    promises.push(promise);
  }

  // Load linked buffers asynchronously and decodes base64 buffers in parallel
  if (options.fetchLinkedResources) {
    await fetchBuffers(gltf, options, context);
  }

  const promise = Object(_extensions_extensions__WEBPACK_IMPORTED_MODULE_2__["decodeExtensions"])(gltf, options, context);
  promises.push(promise);

  // Parallelize image loading and buffer loading/extension decoding
  await Promise.all(promises);

  // Post processing resolves indices to objects, buffers
  return options.postProcess ? Object(_post_process_gltf__WEBPACK_IMPORTED_MODULE_4__["default"])(gltf, options) : gltf;
}

// NOTE: The sync parser cannot handle linked assets or base64 encoded resources
// gtlf - input can be arrayBuffer (GLB or UTF8 encoded JSON), string (JSON), or parsed JSON.
// eslint-disable-next-line complexity
function parseGLTFSync(gltf, arrayBufferOrString, byteOffset = 0, options, context) {
  options = {...DEFAULT_OPTIONS, ...options};

  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);

  // TODO: we could synchronously decode base64 encoded data URIs in this non-async path
  if (options.fetchLinkedResources) {
    fetchBuffersSync(gltf, options);
  }

  // Whether this is possible can depends on whether sync loaders are registered
  // e.g. the `DracoWorkerLoader` cannot be called synchronously
  if (options.decodeExtensions) {
    Object(_extensions_extensions__WEBPACK_IMPORTED_MODULE_2__["decodeExtensionsSync"])(gltf, options);
  }

  // Post processing resolves indices to objects, buffers
  return options.postProcess ? Object(_post_process_gltf__WEBPACK_IMPORTED_MODULE_4__["default"])(gltf, options) : gltf;
}

// `data` - can be ArrayBuffer (GLB), ArrayBuffer (Binary JSON), String (JSON), or Object (parsed JSON)
function parseGLTFContainerSync(gltf, data, byteOffset, options) {
  // Initialize gltf container
  if (options.uri) {
    gltf.baseUri = options.uri;
  }

  // If data is binary and starting with magic bytes, assume binary JSON text, convert to string
  if (data instanceof ArrayBuffer && !Object(_parse_glb__WEBPACK_IMPORTED_MODULE_3__["isGLB"])(data, byteOffset, options)) {
    const textDecoder = new TextDecoder();
    data = textDecoder.decode(data);
  }

  if (typeof data === 'string') {
    // If string, try to parse as JSON
    gltf.json = JSON.parse(data);
  } else if (data instanceof ArrayBuffer) {
    // If still ArrayBuffer, parse as GLB container
    gltf._glb = {};
    byteOffset = Object(_parse_glb__WEBPACK_IMPORTED_MODULE_3__["default"])(gltf._glb, data, byteOffset, options);
    gltf.json = gltf._glb.json;
  } else {
    // Assume input is already parsed JSON
    // TODO - should we throw instead?
    gltf.json = data;
  }

  // Populate buffers
  // Create an external buffers array to hold binary data
  const buffers = gltf.json.buffers || [];
  gltf.buffers = new Array(buffers.length).fill({});

  // Populates JSON and some bin chunk info
  if (gltf._glb && gltf._glb.hasBinChunk) {
    gltf.buffers[0] = {
      // TODO - standardize on `arrayBuffer`
      arrayBuffer: gltf._glb.binChunks[0].arrayBuffer,
      byteOffset: gltf._glb.binChunks[0].byteOffset,
      byteLength: gltf._glb.binChunks[0].byteLength
    };

    gltf.json.buffers[0].data = gltf.buffers[0].arrayBuffer;
    gltf.json.buffers[0].byteOffset = gltf.buffers[0].byteOffset;
  }

  // Populate images
  const images = gltf.json.images || [];
  gltf.images = new Array(images.length).fill({});
}

// Asynchronously fetch and parse buffers, store in buffers array outside of json
async function fetchBuffers(gltf, options, context) {
  for (let i = 0; i < gltf.json.buffers.length; ++i) {
    const buffer = gltf.json.buffers[i];
    if (buffer.uri) {
      if (!options.uri) {
        // TODO - remove this defensive hack and auto-infer the base URI
        // eslint-disable-next-line
        console.warn('options.uri must be set to decode embedded glTF buffers');
        return;
      }

      const {fetch} = context;
      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(fetch);

      const uri = Object(_gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_1__["getFullUri"])(buffer.uri, options.uri);
      const response = await fetch(uri);
      const arrayBuffer = await response.arrayBuffer();

      gltf.buffers[i] = {
        arrayBuffer,
        byteOffset: 0,
        byteLength: arrayBuffer.byteLength
      };

      delete buffer.uri;
    }
  }
}

function fetchBuffersSync(gltf, options) {
  for (const buffer of gltf.json.buffers || []) {
    if (buffer.uri) {
      throw new Error('parseGLTFSync: Cannot decode uri buffers');
    }
  }
}

async function fetchImages(gltf, options, context) {
  const images = gltf.json.images || [];

  const promises = [];
  for (let i = 0; i < images.length; ++i) {
    const image = images[i];
    if ('uri' in image) {
      promises.push(fetchAndParseLinkedImage(gltf, image, i, options));
    }
  }
  return await Promise.all(promises);
}

// Asynchronously fetches and parses one image, store in images array outside of json
async function fetchAndParseLinkedImage(gltf, image, i, options, context) {
  // const fetch = options.fetch || window.fetch;
  // assert(fetch);

  /*
  if (image.bufferView) {
    gltf.images[i] = await new Promise(resolve => {
      const arrayBufferView = this.getBufferView(image.bufferView);
      const mimeType = image.mimeType || 'image/jpeg';
      const blob = new Blob([arrayBufferView], { type: mimeType });
      const urlCreator = self.URL || self.webkitURL;
      const imageUrl = urlCreator.createObjectURL(blob);
      const img = new Image();
      img.onload = () => resolve(img);
      img.src = imageUrl;
    });
  }
  */

  const uri = Object(_gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_1__["getFullUri"])(image.uri, options.uri);

  // TODO - Call `parse` and use registered image loaders?
  // const response = await fetch(uri);
  // const arrayBuffer = await response.arrayBuffer();
  // Create a new 'buffer' to hold the arrayBuffer?
  // const image = parse(arrayBuffer);

  gltf.images[i] = await new Promise((resolve, reject) => {
    /* global Image */
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => resolve(img);
    img.onerror = error => reject(error);
    img.src = uri;
  });
}


/***/ }),

/***/ "./src/lib/post-process-gltf.js":
/*!**************************************!*\
  !*** ./src/lib/post-process-gltf.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return postProcessGLTF; });
/* harmony import */ var _gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gltf-utils/gltf-utils */ "./src/lib/gltf-utils/gltf-utils.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/assert */ "./src/lib/utils/assert.js");



// This is a post processor for loaded glTF files
// The goal is to make the loaded data easier to use in WebGL applications
//
// Functions:
// * Resolve indexed arrays structure of glTF into a linked tree.
// * Translate stringified enum keys and values into WebGL constants.
// * Load images (optional)

// ENUM LOOKUP

const COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};

const BYTES = {
  5120: 1, // BYTE
  5121: 1, // UNSIGNED_BYTE
  5122: 2, // SHORT
  5123: 2, // UNSIGNED_SHORT
  5125: 4, // UNSIGNED_INT
  5126: 4 // FLOAT
};

const GL_SAMPLER = {
  // Sampler parameters
  TEXTURE_MAG_FILTER: 0x2800,
  TEXTURE_MIN_FILTER: 0x2801,
  TEXTURE_WRAP_S: 0x2802,
  TEXTURE_WRAP_T: 0x2803,

  // Sampler default values
  REPEAT: 0x2901,
  LINEAR: 0x2601,
  NEAREST_MIPMAP_LINEAR: 0x2702
};

const SAMPLER_PARAMETER_GLTF_TO_GL = {
  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,
  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,
  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,
  wrapT: GL_SAMPLER.TEXTURE_WRAP_T
};

// When undefined, a sampler with repeat wrapping and auto filtering should be used.
// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture
const DEFAULT_SAMPLER = {
  [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,
  [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,
  [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,
  [GL_SAMPLER.TEXTURE_WRAP_]: GL_SAMPLER.REPEAT
};

function getBytesFromComponentType(componentType) {
  return BYTES[componentType];
}

function getSizeFromAccessorType(type) {
  return COMPONENTS[type];
}

class GLTFPostProcessor {
  postProcess(gltf, options = {}) {
    const {json, buffers = [], images = [], baseUri = ''} = gltf;
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(json);

    this.baseUri = baseUri;
    this.json = json;
    this.buffers = buffers;
    this.images = images;

    this._resolveTree(this.json, options);

    return this.json;
  }

  // Convert indexed glTF structure into tree structure
  // cross-link index resolution, enum lookup, convenience calculations
  // eslint-disable-next-line complexity
  _resolveTree(json, options = {}) {
    if (json.bufferViews) {
      json.bufferViews = json.bufferViews.map((bufView, i) => this._resolveBufferView(bufView, i));
    }
    if (json.images) {
      json.images = json.images.map((image, i) => this._resolveImage(image, i, options));
    }
    if (json.samplers) {
      json.samplers = json.samplers.map((sampler, i) => this._resolveSampler(sampler, i));
    }
    if (json.textures) {
      json.textures = json.textures.map((texture, i) => this._resolveTexture(texture, i));
    }
    if (json.accessors) {
      json.accessors = json.accessors.map((accessor, i) => this._resolveAccessor(accessor, i));
    }
    if (json.materials) {
      json.materials = json.materials.map((material, i) => this._resolveMaterial(material, i));
    }
    if (json.meshes) {
      json.meshes = json.meshes.map((mesh, i) => this._resolveMesh(mesh, i));
    }
    if (json.nodes) {
      json.nodes = json.nodes.map((node, i) => this._resolveNode(node, i));
    }
    if (json.skins) {
      json.skins = json.skins.map((skin, i) => this._resolveSkin(skin, i));
    }
    if (json.scenes) {
      json.scenes = json.scenes.map((scene, i) => this._resolveScene(scene, i));
    }
    if (json.scene !== undefined) {
      json.scene = json.scenes[this.json.scene];
    }
  }

  getScene(index) {
    return this._get('scenes', index);
  }

  getNode(index) {
    return this._get('nodes', index);
  }

  getSkin(index) {
    return this._get('skins', index);
  }

  getMesh(index) {
    return this._get('meshes', index);
  }

  getMaterial(index) {
    return this._get('materials', index);
  }

  getAccessor(index) {
    return this._get('accessors', index);
  }

  getCamera(index) {
    return null; // TODO: fix this
  }

  getTexture(index) {
    return this._get('textures', index);
  }

  getSampler(index) {
    return this._get('samplers', index);
  }

  getImage(index) {
    return this._get('images', index);
  }

  getBufferView(index) {
    return this._get('bufferViews', index);
  }

  getBuffer(index) {
    return this._get('buffers', index);
  }

  _get(array, index) {
    // check if already resolved
    if (typeof index === 'object') {
      return index;
    }
    const object = this.json[array] && this.json[array][index];
    if (!object) {
      console.warn(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line
    }
    return object;
  }

  // PARSING HELPERS

  _resolveScene(scene, index) {
    // scene = {...scene};
    scene.id = scene.id || `scene-${index}`;
    scene.nodes = (scene.nodes || []).map(node => this.getNode(node));
    return scene;
  }

  _resolveNode(node, index) {
    // node = {...node};
    node.id = node.id || `node-${index}`;
    if (node.children) {
      node.children = node.children.map(child => this.getNode(child));
    }
    if (node.mesh !== undefined) {
      node.mesh = this.getMesh(node.mesh);
    }
    if (node.camera !== undefined) {
      node.camera = this.getCamera(node.camera);
    }
    if (node.skin !== undefined) {
      node.skin = this.getSkin(node.skin);
    }
    return node;
  }

  _resolveSkin(skin, index) {
    // skin = {...skin};
    skin.id = skin.id || `skin-${index}`;
    skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);
    return skin;
  }

  _resolveMesh(mesh, index) {
    // mesh = {...mesh};
    mesh.id = mesh.id || `mesh-${index}`;
    if (mesh.primitives) {
      mesh.primitives = mesh.primitives.map(primitive => {
        primitive = {...primitive};
        const attributes = primitive.attributes;
        primitive.attributes = {};
        for (const attribute in attributes) {
          primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);
        }
        if (primitive.indices !== undefined) {
          primitive.indices = this.getAccessor(primitive.indices);
        }
        if (primitive.material !== undefined) {
          primitive.material = this.getMaterial(primitive.material);
        }
        return primitive;
      });
    }
    return mesh;
  }

  _resolveMaterial(material, index) {
    // material = {...material};
    material.id = material.id || `material-${index}`;
    if (material.normalTexture) {
      material.normalTexture = {...material.normalTexture};
      material.normalTexture.texture = this.getTexture(material.normalTexture.index);
    }
    if (material.occlusionTexture) {
      material.occlustionTexture = {...material.occlustionTexture};
      material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);
    }
    if (material.emissiveTexture) {
      material.emmisiveTexture = {...material.emmisiveTexture};
      material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);
    }

    if (material.pbrMetallicRoughness) {
      material.pbrMetallicRoughness = {...material.pbrMetallicRoughness};
      const mr = material.pbrMetallicRoughness;
      if (mr.baseColorTexture) {
        mr.baseColorTexture = {...mr.baseColorTexture};
        mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);
      }
      if (mr.metallicRoughnessTexture) {
        mr.metallicRoughnessTexture = {...mr.metallicRoughnessTexture};
        mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);
      }
    }
    return material;
  }

  _resolveAccessor(accessor, index) {
    // accessor = {...accessor};
    accessor.id = accessor.id || `accessor-${index}`;
    if (accessor.bufferView !== undefined) {
      // Draco encoded meshes don't have bufferView
      accessor.bufferView = this.getBufferView(accessor.bufferView);
    }

    // Look up enums
    accessor.bytesPerComponent = getBytesFromComponentType(accessor.componentType);
    accessor.components = getSizeFromAccessorType(accessor.type);
    accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;

    // TODO - Create TypedArray for the accessor

    return accessor;
  }

  _resolveTexture(texture, index) {
    // texture = {...texture};
    texture.id = texture.id || `texture-${index}`;
    texture.sampler = 'sampler' in texture ? this.getSampler(texture.sampler) : DEFAULT_SAMPLER;
    texture.source = this.getImage(texture.source);
    return texture;
  }

  _resolveSampler(sampler, index) {
    // sampler = {...sampler};
    sampler.id = sampler.id || `sampler-${index}`;
    // Map textual parameters to GL parameter values
    sampler.parameters = {};
    for (const key in sampler) {
      const glEnum = this._enumSamplerParameter(key);
      if (glEnum !== undefined) {
        sampler.parameters[glEnum] = sampler[key];
      }
    }
    return sampler;
  }

  _enumSamplerParameter(key) {
    return SAMPLER_PARAMETER_GLTF_TO_GL[key];
  }

  _resolveImage(image, index, options) {
    // image = {...image};
    image.id = image.id || `image-${index}`;
    if (image.bufferView !== undefined) {
      image.bufferView = this.getBufferView(image.bufferView);
    }

    if ('uri' in image) {
      // Check if image has been preloaded by the GLTFLoader
      // If so, link it into the JSON and drop the URI
      const preloadedImage = this.images[index];
      if (preloadedImage && preloadedImage.image) {
        image.image = preloadedImage.image;
        delete image.uri;
      }

      // If not, resolve the relative URI using the baseName
      const baseUri = options.uri || this.baseUri;
      if (baseUri) {
        const uri = image.uri;
        image.uri = Object(_gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_0__["getFullUri"])(image.uri, baseUri);

        // Deprecated
        image.originalUri = uri;
        image.baseUri = baseUri;
        image.fullUri = image.uri;
      }
    }

    // Deprecated, use image.image or image.uri or image loaders instead
    image.getImageAsync = () => {
      /* global self, Blob, Image */
      if (image.bufferView) {
        return new Promise(resolve => {
          const arrayBufferView = this.getBufferView(image.bufferView);
          const mimeType = image.mimeType || 'image/jpeg';
          const blob = new Blob([arrayBufferView.data], {type: mimeType});
          const urlCreator = self.URL || self.webkitURL;
          const imageUrl = urlCreator.createObjectURL(blob);
          const img = new Image();
          img.onload = () => resolve(img);
          img.src = imageUrl;
        });
      }

      return image.uri
        ? new Promise(resolve => {
            /* global Image */
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => resolve(img);
            img.src = image.fullUri || image.uri;
          })
        : null;
    };

    return image;
  }

  _resolveBufferView(bufferView, index) {
    // bufferView = {...bufferView};
    bufferView.id = bufferView.id || `bufferView-${index}`;
    const bufferIndex = bufferView.buffer;
    bufferView.buffer = this.getBuffer(bufferIndex);

    const arrayBuffer = this.buffers[bufferIndex].arrayBuffer;
    let byteOffset = this.buffers[bufferIndex].byteOffset || 0;

    if ('byteOffset' in bufferView) {
      byteOffset += bufferView.byteOffset;
    }

    bufferView.data = new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);
    return bufferView;
  }

  _resolveCamera(camera, index) {
    camera.id = camera.id || `camera-${index}`;
    // TODO - create 4x4 matrices
    if (camera.perspective) {
      // camera.matrix = createPerspectiveMatrix(camera.perspective);
    }
    if (camera.orthographic) {
      // camera.matrix = createOrthographicMatrix(camera.orthographic);
    }
    return camera;
  }
}

function postProcessGLTF(gltf, options) {
  return new GLTFPostProcessor().postProcess(gltf, options);
}


/***/ }),

/***/ "./src/lib/utils/assert.js":
/*!*********************************!*\
  !*** ./src/lib/utils/assert.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
// Replacement for the external assert method to reduce bundle size
// Note: We don't use the second "message" argument in calling code,
// so no need to support it here
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'gltf/glb assertion failed.');
  }
}


/***/ }),

/***/ 0:
/*!****************************************************!*\
  !*** ../node/utils/to-array-buffer.node (ignored) ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1:
/*!************************************************!*\
  !*** ../../node/read-file-sync.node (ignored) ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 2:
/*!********************************************!*\
  !*** ../../node/write-file.node (ignored) ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
});