import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import GLTFScenegraph from '../gltf-scenegraph';
import { KHR_LIGHTS_PUNCTUAL } from '../gltf-constants';
import assert from '../utils/assert';

var KHR_lights_punctual = function () {
  function KHR_lights_punctual() {
    _classCallCheck(this, KHR_lights_punctual);
  }

  _createClass(KHR_lights_punctual, null, [{
    key: "decode",
    value: function decode(gltfData, options) {
      var gltfScenegraph = new GLTFScenegraph(gltfData);
      var extension = gltfScenegraph.getExtension(KHR_LIGHTS_PUNCTUAL);

      if (extension) {
        gltfScenegraph.json.lights = extension.lights;
        gltfScenegraph.removeExtension(KHR_LIGHTS_PUNCTUAL);
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (gltfScenegraph.nodes || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var node = _step.value;
          var nodeExtension = node.extensions && node.extensions.KHR_lights_punctual;

          if (nodeExtension) {
            node.light = gltfScenegraph._get('lights', nodeExtension.light);
            delete node.extensions.KHR_lights_punctual;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "encode",
    value: function encode(gltfData, options) {
      var gltfScenegraph = new GLTFScenegraph(gltfData);
      var json = gltfScenegraph.json;

      if (json.lights) {
        var extension = gltfScenegraph.addExtensions(KHR_LIGHTS_PUNCTUAL);
        assert(!extension.lights);
        extension.lights = json.lights;
        delete json.lights;
      }

      if (gltfScenegraph.json.lights) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = gltfScenegraph.json.lights[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var light = _step2.value;
            var node = light.node;
            gltfScenegraph.addObjectExtension(node, KHR_LIGHTS_PUNCTUAL, light);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        delete gltfScenegraph.json.lights;
      }
    }
  }, {
    key: "name",
    get: function get() {
      return KHR_LIGHTS_PUNCTUAL;
    }
  }]);

  return KHR_lights_punctual;
}();

export { KHR_lights_punctual as default };
//# sourceMappingURL=KHR_lights_punctual.js.map