{"version":3,"sources":["../../../../../src/lib/deprecated/packed-json/unpack-gltf-buffers.js"],"names":["assert","getAccessorArrayTypeAndLength","unpackGLBBuffers","arrayBuffer","json","binaryByteOffset","getArrayBufferAtOffset","bufferViews","i","length","bufferView","byteLength","accessors","unpackAccessors","images","unpackImages","accessorBuffers","accessor","ArrayType","array","byteOffset","push","imageBuffers","image","Uint8Array","imate","binaryBuffer","ArrayBuffer","sourceArray","binaryArray"],"mappings":"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","sourcesContent":["import assert from '../../utils/assert';\nimport {getAccessorArrayTypeAndLength} from '../../gltf-utils/gltf-utils';\n\nexport default function unpackGLBBuffers(arrayBuffer, json, binaryByteOffset) {\n  // TODO - really inefficient, should just use the offset into the original array buffer\n  if (binaryByteOffset) {\n    arrayBuffer = getArrayBufferAtOffset(arrayBuffer, binaryByteOffset);\n  }\n\n  const bufferViews = json.bufferViews || [];\n\n  for (let i = 0; i < bufferViews.length; ++i) {\n    const bufferView = bufferViews[i];\n    assert(bufferView.byteLength >= 0);\n  }\n\n  return {\n    // TODO: delete unpackAccessors and use buffer views only?\n    accessors: unpackAccessors(arrayBuffer, bufferViews, json),\n    images: unpackImages(arrayBuffer, bufferViews, json)\n  };\n}\n\nfunction unpackAccessors(arrayBuffer, bufferViews, json) {\n  // unpack accessors\n  const accessors = json.accessors || [];\n\n  const accessorBuffers = [];\n\n  for (let i = 0; i < accessors.length; ++i) {\n    const accessor = accessors[i];\n    assert(accessor);\n\n    const bufferView = bufferViews[accessor.bufferView];\n    // Draco encoded meshes don't have bufferView in accessor\n    if (bufferView) {\n      // Create a new typed array as a view into the combined buffer\n      const {ArrayType, length} = getAccessorArrayTypeAndLength(accessor, bufferView);\n      const array = new ArrayType(arrayBuffer, bufferView.byteOffset, length);\n      // Store the metadata on the array (e.g. needed to determine number of components per element)\n      array.accessor = accessor;\n      accessorBuffers.push(array);\n    }\n  }\n\n  return accessorBuffers;\n}\n\nfunction unpackImages(arrayBuffer, bufferViews, json) {\n  // unpack images\n  const images = json.images || [];\n\n  const imageBuffers = [];\n\n  for (let i = 0; i < images.length; ++i) {\n    const image = images[i];\n    assert(image);\n\n    const bufferView = bufferViews[image.bufferView];\n    assert(bufferView);\n\n    // Create a new typed array as a view into the combined buffer\n    const array = new Uint8Array(arrayBuffer, bufferView.byteOffset, bufferView.byteLength);\n    // Store the metadata on the array (e.g. needed to determine number of components per element)\n    array.imate = image;\n    imageBuffers.push(array);\n  }\n\n  return imageBuffers;\n}\n\n// Helper methods\n\n// json.accessors = json.accessors || [];\n// json.bufferViews = json.bufferViews || [];\n\n// Creates a new ArrayBuffer starting at the offset, containing all remaining bytes\n// TODO - should not be needed, see above\nfunction getArrayBufferAtOffset(arrayBuffer, byteOffset) {\n  const length = arrayBuffer.byteLength - byteOffset;\n  const binaryBuffer = new ArrayBuffer(length);\n  const sourceArray = new Uint8Array(arrayBuffer);\n  const binaryArray = new Uint8Array(binaryBuffer);\n  for (let i = 0; i < length; i++) {\n    binaryArray[i] = sourceArray[byteOffset + i];\n  }\n  return binaryBuffer;\n}\n"],"file":"unpack-gltf-buffers.js"}