import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import assert from './utils/assert';
import { getFullUri } from './gltf-utils/gltf-utils';
import { decodeExtensions, decodeExtensionsSync } from './extensions/extensions';
import parseGLBSync, { isGLB } from './parse-glb';
import postProcessGLTF from './post-process-gltf';
const DEFAULT_OPTIONS = {
  fetchLinkedResources: true,
  fetchImages: false,
  createImages: false,
  decompress: false,
  postProcess: false,
  log: console
};
export function isGLTF(arrayBuffer, options = {}) {
  const dataView = new DataView(arrayBuffer);
  const byteOffset = 0;
  return isGLB(dataView, byteOffset);
}
export async function parseGLTF(gltf, arrayBufferOrString, byteOffset = 0, options, context) {
  options = _objectSpread({}, DEFAULT_OPTIONS, {}, options.gltf);
  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);
  const promises = [];

  if (options.fetchImages) {
    const promise = fetchImages(gltf, options, context);
    promises.push(promise);
  }

  if (options.fetchLinkedResources) {
    await fetchBuffers(gltf, options, context);
  }

  const promise = decodeExtensions(gltf, options, context);
  promises.push(promise);
  await Promise.all(promises);
  return options.postProcess ? postProcessGLTF(gltf, options) : gltf;
}
export function parseGLTFSync(gltf, arrayBufferOrString, byteOffset = 0, options, context) {
  options = _objectSpread({}, DEFAULT_OPTIONS, {}, options);
  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);

  if (options.fetchLinkedResources) {
    fetchBuffersSync(gltf, options);
  }

  if (options.decodeExtensions) {
    decodeExtensionsSync(gltf, options);
  }

  return options.postProcess ? postProcessGLTF(gltf, options) : gltf;
}

function parseGLTFContainerSync(gltf, data, byteOffset, options) {
  if (options.uri) {
    gltf.baseUri = options.uri;
  }

  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {
    const textDecoder = new TextDecoder();
    data = textDecoder.decode(data);
  }

  if (typeof data === 'string') {
    gltf.json = JSON.parse(data);
  } else if (data instanceof ArrayBuffer) {
    gltf._glb = {};
    byteOffset = parseGLBSync(gltf._glb, data, byteOffset, options);
    gltf.json = gltf._glb.json;
  } else {
    gltf.json = data;
  }

  const buffers = gltf.json.buffers || [];
  gltf.buffers = new Array(buffers.length).fill({});

  if (gltf._glb && gltf._glb.hasBinChunk) {
    gltf.buffers[0] = {
      arrayBuffer: gltf._glb.binChunks[0].arrayBuffer,
      byteOffset: gltf._glb.binChunks[0].byteOffset,
      byteLength: gltf._glb.binChunks[0].byteLength
    };
    gltf.json.buffers[0].data = gltf.buffers[0].arrayBuffer;
    gltf.json.buffers[0].byteOffset = gltf.buffers[0].byteOffset;
  }

  const images = gltf.json.images || [];
  gltf.images = new Array(images.length).fill({});
}

async function fetchBuffers(gltf, options, context) {
  for (let i = 0; i < gltf.json.buffers.length; ++i) {
    const buffer = gltf.json.buffers[i];

    if (buffer.uri) {
      if (!options.uri) {
        console.warn('options.uri must be set to decode embedded glTF buffers');
        return;
      }

      const {
        fetch
      } = context;
      assert(fetch);
      const uri = getFullUri(buffer.uri, options.uri);
      const response = await fetch(uri);
      const arrayBuffer = await response.arrayBuffer();
      gltf.buffers[i] = {
        arrayBuffer,
        byteOffset: 0,
        byteLength: arrayBuffer.byteLength
      };
      delete buffer.uri;
    }
  }
}

function fetchBuffersSync(gltf, options) {
  for (const buffer of gltf.json.buffers || []) {
    if (buffer.uri) {
      throw new Error('parseGLTFSync: Cannot decode uri buffers');
    }
  }
}

async function fetchImages(gltf, options, context) {
  const images = gltf.json.images || [];
  const promises = [];

  for (let i = 0; i < images.length; ++i) {
    const image = images[i];

    if ('uri' in image) {
      promises.push(fetchAndParseLinkedImage(gltf, image, i, options));
    }
  }

  return await Promise.all(promises);
}

async function fetchAndParseLinkedImage(gltf, image, i, options, context) {
  const uri = getFullUri(image.uri, options.uri);
  gltf.images[i] = await new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'anonymous';

    img.onload = () => resolve(img);

    img.onerror = error => reject(error);

    img.src = uri;
  });
}
//# sourceMappingURL=parse-gltf.js.map