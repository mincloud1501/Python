{"version":3,"sources":["../../../../../src/lib/deprecated/packed-json/unpack-gltf-buffers.js"],"names":["unpackGLBBuffers","arrayBuffer","json","binaryByteOffset","getArrayBufferAtOffset","bufferViews","i","length","bufferView","byteLength","accessors","unpackAccessors","images","unpackImages","accessorBuffers","accessor","ArrayType","array","byteOffset","push","imageBuffers","image","Uint8Array","imate","binaryBuffer","ArrayBuffer","sourceArray","binaryArray"],"mappings":"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","sourcesContent":["import assert from '../../utils/assert';\nimport {getAccessorArrayTypeAndLength} from '../../gltf-utils/gltf-utils';\n\nexport default function unpackGLBBuffers(arrayBuffer, json, binaryByteOffset) {\n  // TODO - really inefficient, should just use the offset into the original array buffer\n  if (binaryByteOffset) {\n    arrayBuffer = getArrayBufferAtOffset(arrayBuffer, binaryByteOffset);\n  }\n\n  const bufferViews = json.bufferViews || [];\n\n  for (let i = 0; i < bufferViews.length; ++i) {\n    const bufferView = bufferViews[i];\n    assert(bufferView.byteLength >= 0);\n  }\n\n  return {\n    // TODO: delete unpackAccessors and use buffer views only?\n    accessors: unpackAccessors(arrayBuffer, bufferViews, json),\n    images: unpackImages(arrayBuffer, bufferViews, json)\n  };\n}\n\nfunction unpackAccessors(arrayBuffer, bufferViews, json) {\n  // unpack accessors\n  const accessors = json.accessors || [];\n\n  const accessorBuffers = [];\n\n  for (let i = 0; i < accessors.length; ++i) {\n    const accessor = accessors[i];\n    assert(accessor);\n\n    const bufferView = bufferViews[accessor.bufferView];\n    // Draco encoded meshes don't have bufferView in accessor\n    if (bufferView) {\n      // Create a new typed array as a view into the combined buffer\n      const {ArrayType, length} = getAccessorArrayTypeAndLength(accessor, bufferView);\n      const array = new ArrayType(arrayBuffer, bufferView.byteOffset, length);\n      // Store the metadata on the array (e.g. needed to determine number of components per element)\n      array.accessor = accessor;\n      accessorBuffers.push(array);\n    }\n  }\n\n  return accessorBuffers;\n}\n\nfunction unpackImages(arrayBuffer, bufferViews, json) {\n  // unpack images\n  const images = json.images || [];\n\n  const imageBuffers = [];\n\n  for (let i = 0; i < images.length; ++i) {\n    const image = images[i];\n    assert(image);\n\n    const bufferView = bufferViews[image.bufferView];\n    assert(bufferView);\n\n    // Create a new typed array as a view into the combined buffer\n    const array = new Uint8Array(arrayBuffer, bufferView.byteOffset, bufferView.byteLength);\n    // Store the metadata on the array (e.g. needed to determine number of components per element)\n    array.imate = image;\n    imageBuffers.push(array);\n  }\n\n  return imageBuffers;\n}\n\n// Helper methods\n\n// json.accessors = json.accessors || [];\n// json.bufferViews = json.bufferViews || [];\n\n// Creates a new ArrayBuffer starting at the offset, containing all remaining bytes\n// TODO - should not be needed, see above\nfunction getArrayBufferAtOffset(arrayBuffer, byteOffset) {\n  const length = arrayBuffer.byteLength - byteOffset;\n  const binaryBuffer = new ArrayBuffer(length);\n  const sourceArray = new Uint8Array(arrayBuffer);\n  const binaryArray = new Uint8Array(binaryBuffer);\n  for (let i = 0; i < length; i++) {\n    binaryArray[i] = sourceArray[byteOffset + i];\n  }\n  return binaryBuffer;\n}\n"],"file":"unpack-gltf-buffers.js"}