{"version":3,"sources":["../../../src/worker-utils/create-worker.js"],"names":["getTransferList","createWorker","loader","self","onmessage","evt","data","isKnownMessage","name","arraybuffer","byteOffset","byteLength","options","parseData","result","transferList","postMessage","type","message","requestId","parse","url","Promise","resolve","reject","id","onMessage","removeEventListener","addEventListener","parseSync","parser","parseTextSync","textDecoder","TextDecoder","decode","Error","source"],"mappings":";;AAEA,OAAOA,eAAP,MAA4B,qBAA5B;AAGA,eAAe,SAASC,YAAT,CAAsBC,MAAtB,EAA8B;AAE3C,MAAI,OAAOC,IAAP,KAAgB,WAApB,EAAiC;AAC/B;AACD;;AAEDA,EAAAA,IAAI,CAACC,SAAL;AAAA,0DAAiB,iBAAMC,GAAN;AAAA;;AAAA;AAAA;AAAA;AAAA;AACRC,cAAAA,IADQ,GACAD,GADA,CACRC,IADQ;AAAA;;AAAA,kBAIRC,cAAc,CAACD,IAAD,EAAOJ,MAAM,CAACM,IAAd,CAJN;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAQNC,cAAAA,WARM,GAQuDH,IARvD,CAQNG,WARM,qBAQuDH,IARvD,CAQOI,UARP,EAQOA,UARP,iCAQoB,CARpB,wCAQuDJ,IARvD,CAQuBK,UARvB,EAQuBA,UARvB,iCAQoC,CARpC,qCAQuDL,IARvD,CAQuCM,OARvC,EAQuCA,OARvC,8BAQiD,EARjD;AAAA;AAAA,qBAUQC,SAAS,CAACX,MAAD,EAASO,WAAT,EAAsBC,UAAtB,EAAkCC,UAAlC,EAA8CC,OAA9C,CAVjB;;AAAA;AAUPE,cAAAA,MAVO;AAWPC,cAAAA,YAXO,GAWQf,eAAe,CAACc,MAAD,CAXvB;AAYbX,cAAAA,IAAI,CAACa,WAAL,CAAiB;AAACC,gBAAAA,IAAI,EAAE,MAAP;AAAeH,gBAAAA,MAAM,EAANA;AAAf,eAAjB,EAAyCC,YAAzC;AAZa;AAAA;;AAAA;AAAA;AAAA;AAcbZ,cAAAA,IAAI,CAACa,WAAL,CAAiB;AAACC,gBAAAA,IAAI,EAAE,OAAP;AAAgBC,gBAAAA,OAAO,EAAE,YAAMA;AAA/B,eAAjB;;AAda;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAjB;;AAAA;AAAA;AAAA;AAAA;;AAkBA,MAAIC,SAAS,GAAG,CAAhB;;AACAhB,EAAAA,IAAI,CAACiB,KAAL,GAAa,UAACX,WAAD;AAAA,QAAcG,OAAd,uEAAwB,EAAxB;AAAA,QAA4BS,GAA5B;AAAA,WACX,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AAC/B,UAAMC,EAAE,GAAGN,SAAS,EAApB;;AAEA,UAAMO,SAAS,GAAG,SAAZA,SAAY,QAAY;AAAA,YAAVpB,IAAU,SAAVA,IAAU;;AAC5B,YAAI,CAACA,IAAD,IAASA,IAAI,CAACmB,EAAL,KAAYA,EAAzB,EAA6B;AAE3B;AACD;;AACD,gBAAQnB,IAAI,CAACW,IAAb;AACE,eAAK,cAAL;AACEd,YAAAA,IAAI,CAACwB,mBAAL,CAAyB,SAAzB,EAAoCD,SAApC;AACAH,YAAAA,OAAO,CAACjB,IAAI,CAACQ,MAAN,CAAP;AACA;;AAEF,eAAK,eAAL;AACEX,YAAAA,IAAI,CAACwB,mBAAL,CAAyB,SAAzB,EAAoCD,SAApC;AACAF,YAAAA,MAAM,CAAClB,IAAI,CAACY,OAAN,CAAN;AACA;;AAEF;AAXF;AAcD,OAnBD;;AAoBAf,MAAAA,IAAI,CAACyB,gBAAL,CAAsB,SAAtB,EAAiCF,SAAjC;AAEAvB,MAAAA,IAAI,CAACa,WAAL,CAAiB;AAACC,QAAAA,IAAI,EAAE,SAAP;AAAkBQ,QAAAA,EAAE,EAAFA,EAAlB;AAAsBhB,QAAAA,WAAW,EAAXA,WAAtB;AAAmCG,QAAAA,OAAO,EAAPA,OAAnC;AAA4CS,QAAAA,GAAG,EAAHA;AAA5C,OAAjB,EAAmE,CAACZ,WAAD,CAAnE;AACD,KA1BD,CADW;AAAA,GAAb;AA4BD;;SAMcI,S;;;;;0DAAf,kBAAyBX,MAAzB,EAAiCO,WAAjC,EAA8CC,UAA9C,EAA0DC,UAA1D,EAAsEC,OAAtE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAGMV,MAAM,CAAC2B,SAAP,IAAoB3B,MAAM,CAACkB,KAHjC;AAAA;AAAA;AAAA;;AAIId,YAAAA,IAAI,GAAGG,WAAP;AACAqB,YAAAA,MAAM,GAAG5B,MAAM,CAAC2B,SAAP,IAAoB3B,MAAM,CAACkB,KAApC;AALJ;AAAA;;AAAA;AAAA,iBAMalB,MAAM,CAAC6B,aANpB;AAAA;AAAA;AAAA;;AAOUC,YAAAA,WAPV,GAOwB,IAAIC,WAAJ,EAPxB;AAQI3B,YAAAA,IAAI,GAAG0B,WAAW,CAACE,MAAZ,CAAmBzB,WAAnB,CAAP;AACAqB,YAAAA,MAAM,GAAG5B,MAAM,CAAC6B,aAAhB;AATJ;AAAA;;AAAA;AAAA,kBAWU,IAAII,KAAJ,oCAAsCjC,MAAM,CAACM,IAA7C,aAXV;;AAAA;AAAA;AAAA,mBAcesB,MAAM,CAACxB,IAAD,EAAOM,OAAP,CAdrB;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAkBA,SAASL,cAAT,CAAwBD,IAAxB,EAA8BE,IAA9B,EAAoC;AAClC,SAAOF,IAAI,IAAIA,IAAI,CAACW,IAAL,KAAc,SAAtB,IAAmCX,IAAI,CAAC8B,MAAL,KAAgB,YAA1D;AACD","sourcesContent":["/* eslint-disable no-restricted-globals */\n/* global TextDecoder, self */\nimport getTransferList from './get-transfer-list';\n\n// Set up a WebWorkerGlobalScope to talk with the main thread\nexport default function createWorker(loader) {\n  // TODO - explain when this happens? Just a sanity check? Throw an error or log a warning?\n  if (typeof self === 'undefined') {\n    return;\n  }\n\n  self.onmessage = async evt => {\n    const {data} = evt;\n\n    try {\n      if (!isKnownMessage(data, loader.name)) {\n        return;\n      }\n\n      const {arraybuffer, byteOffset = 0, byteLength = 0, options = {}} = data;\n\n      const result = await parseData(loader, arraybuffer, byteOffset, byteLength, options);\n      const transferList = getTransferList(result);\n      self.postMessage({type: 'done', result}, transferList);\n    } catch (error) {\n      self.postMessage({type: 'error', message: error.message});\n    }\n  };\n\n  let requestId = 0;\n  self.parse = (arraybuffer, options = {}, url) =>\n    new Promise((resolve, reject) => {\n      const id = requestId++;\n\n      const onMessage = ({data}) => {\n        if (!data || data.id !== id) {\n          // not ours\n          return;\n        }\n        switch (data.type) {\n          case 'process-done':\n            self.removeEventListener('message', onMessage);\n            resolve(data.result);\n            break;\n\n          case 'process-error':\n            self.removeEventListener('message', onMessage);\n            reject(data.message);\n            break;\n\n          default:\n          // ignore\n        }\n      };\n      self.addEventListener('message', onMessage);\n      // Ask the main thread to decode data\n      self.postMessage({type: 'process', id, arraybuffer, options, url}, [arraybuffer]);\n    });\n}\n\n// TODO - Support byteOffset and byteLength (enabling parsing of embedded binaries without copies)\n// TODO - Why not support async loader.parse* funcs here?\n// TODO - Why not reuse a common function instead of reimplementing loader.parse* selection logic? Keeping loader small?\n// TODO - Lack of appropriate parser functions can be detected when we create worker, no need to wait until parse\nasync function parseData(loader, arraybuffer, byteOffset, byteLength, options) {\n  let data;\n  let parser;\n  if (loader.parseSync || loader.parse) {\n    data = arraybuffer;\n    parser = loader.parseSync || loader.parse;\n  } else if (loader.parseTextSync) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(arraybuffer);\n    parser = loader.parseTextSync;\n  } else {\n    throw new Error(`Could not load data with ${loader.name} loader`);\n  }\n\n  return await parser(data, options);\n}\n\n// Filter out noise messages sent to workers\nfunction isKnownMessage(data, name) {\n  return data && data.type === 'process' && data.source === 'loaders.gl';\n}\n\n/*\nfunction checkMessage(evt, name) {\n  switch (evt.data && evt.data.source) {\n    // Ignore known noise event from react-dev-tools bridge, webpack build progress etc...\n    case 'react-devtools-bridge':\n    case 'react-devtools-content-script':\n    case 'react-devtools-detector':\n      return false;\n    default:\n      // fall through\n  }\n\n  switch (evt.data && evt.data.type) {\n    case 'webpackProgress':\n    case 'webpackOk':\n      return false;\n    default:\n      // Enable to debug messages\n      // const message = `${name.toLowerCase()}-worker: ignoring unknown message`;\n      // console.log(message, evt.data, evt); // eslint-disable-line\n      return false;\n  }\n}\n*/\n"],"file":"create-worker.js"}