import { VERSION, isBrowser } from '../utils/globals';
import LocalStorage from '../utils/local-storage';
import { formatImage, formatTime, leftPad } from '../utils/formatters';
import { addColor } from '../utils/color';
import { autobind } from '../utils/autobind';
import assert from '../utils/assert';
import getHiResTimestamp from '../utils/hi-res-timestamp';
const originalConsole = {
  debug: isBrowser ? console.debug || console.log : console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
};
const DEFAULT_SETTINGS = {
  enabled: false,
  priority: 0
};

function noop() {}

const cache = {};

function getTableHeader(table) {
  for (const key in table) {
    for (const title in table[key]) {
      return title || 'untitled';
    }
  }

  return 'empty';
}

export default class Log {
  constructor() {
    let _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        id = _ref.id;

    this.id = id;
    this.VERSION = VERSION;
    this._startTs = getHiResTimestamp();
    this._deltaTs = getHiResTimestamp();
    this.LOG_THROTTLE_TIMEOUT = 0;
    this._storage = new LocalStorage("__probe-".concat(this.id, "__"), DEFAULT_SETTINGS);
    this.userData = {};
    this.timeStamp("".concat(this.id, " started"));
    autobind(this);
    Object.seal(this);
  }

  set priority(newPriority) {
    this._storage.updateConfiguration({
      priority: newPriority
    });

    return this;
  }

  get priority() {
    return this._storage.config.priority;
  }

  isEnabled() {
    return this._storage.config.enabled;
  }

  getPriority() {
    return this._storage.config.priority;
  }

  getLevel() {
    return this._storage.config.priority;
  }

  getTotal() {
    return Number((getHiResTimestamp() - this._startTs).toPrecision(10));
  }

  getDelta() {
    return Number((getHiResTimestamp() - this._deltaTs).toPrecision(10));
  }

  enable() {
    let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    this._storage.updateConfiguration({
      enabled
    });

    return this;
  }

  setLevel(level) {
    this._storage.updateConfiguration({
      priority: level
    });

    return this;
  }

  assert(condition, message) {
    assert(condition, message);
  }

  warn(message) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return this._getLogFunction({
      message,
      args,
      method: originalConsole.warn,
      once: true
    });
  }

  error(message) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    return this._getLogFunction({
      message,
      args,
      method: originalConsole.error
    });
  }

  deprecated(oldUsage, newUsage) {
    return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
  }

  removed(oldUsage, newUsage) {
    return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
  }

  probe(priority, message) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
      args[_key3 - 2] = arguments[_key3];
    }

    return this._getLogFunction({
      priority,
      message,
      args,
      method: originalConsole.log,
      time: true,
      once: true
    });
  }

  log(priority, message) {
    for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
      args[_key4 - 2] = arguments[_key4];
    }

    return this._getLogFunction({
      priority,
      message,
      args,
      method: originalConsole.debug
    });
  }

  info(priority, message) {
    for (var _len5 = arguments.length, args = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {
      args[_key5 - 2] = arguments[_key5];
    }

    return this._getLogFunction({
      priority,
      message,
      args,
      method: console.info
    });
  }

  once(priority, message) {
    for (var _len6 = arguments.length, args = new Array(_len6 > 2 ? _len6 - 2 : 0), _key6 = 2; _key6 < _len6; _key6++) {
      args[_key6 - 2] = arguments[_key6];
    }

    return this._getLogFunction({
      priority,
      message,
      args,
      method: originalConsole.debug || originalConsole.info,
      once: true
    });
  }

  table(priority, table, columns) {
    if (table) {
      const tag = getTableHeader(table);
      return this._getLogFunction({
        priority,
        message: table,
        args: columns && [columns],
        tag,
        method: console.table || noop
      });
    }

    return noop;
  }

  image(_ref2) {
    let priority = _ref2.priority,
        image = _ref2.image,
        _ref2$message = _ref2.message,
        message = _ref2$message === void 0 ? '' : _ref2$message,
        _ref2$scale = _ref2.scale,
        scale = _ref2$scale === void 0 ? 1 : _ref2$scale;

    if (priority > this.getPriority()) {
      return noop;
    }

    return isBrowser ? this._logImageInBrowser({
      image,
      message,
      scale
    }) : this._logImageInNode({
      image,
      message,
      scale
    });
  }

  settings() {
    if (console.table) {
      console.table(this._storage.config);
    } else {
      console.log(this._storage.config);
    }
  }

  get(setting) {
    return this._storage.config[setting];
  }

  set(setting, value) {
    this._storage.updateConfiguration({
      [setting]: value
    });
  }

  _logImageInNode(_ref3) {
    let image = _ref3.image,
        _ref3$message = _ref3.message,
        message = _ref3$message === void 0 ? '' : _ref3$message,
        _ref3$scale = _ref3.scale,
        scale = _ref3$scale === void 0 ? 1 : _ref3$scale;
    let asciify = null;

    try {
      asciify = module.require('asciify-image');
    } catch (error) {}

    if (asciify) {
      return () => asciify(image, {
        fit: 'box',
        width: "".concat(Math.round(80 * scale), "%")
      }).then(data => console.log(data));
    }

    return noop;
  }

  _logImageInBrowser(_ref4) {
    let image = _ref4.image,
        _ref4$message = _ref4.message,
        message = _ref4$message === void 0 ? '' : _ref4$message,
        _ref4$scale = _ref4.scale,
        scale = _ref4$scale === void 0 ? 1 : _ref4$scale;

    if (typeof image === 'string') {
      const img = new Image();

      img.onload = () => {
        const args = formatImage(img, message, scale);
        console.log(...args);
      };

      img.src = image;
      return noop;
    }

    const element = image.nodeName || '';

    if (element.toLowerCase() === 'img') {
      console.log(...formatImage(image, message, scale));
      return noop;
    }

    if (element.toLowerCase() === 'canvas') {
      const img = new Image();

      img.onload = () => console.log(...formatImage(img, message, scale));

      img.src = image.toDataURL();
      return noop;
    }

    return noop;
  }

  time(priority, message) {
    return this._getLogFunction({
      priority,
      message,
      method: console.time ? console.time : console.info
    });
  }

  timeEnd(priority, message) {
    return this._getLogFunction({
      priority,
      message,
      method: console.timeEnd ? console.timeEnd : console.info
    });
  }

  timeStamp(priority, message) {
    return this._getLogFunction({
      priority,
      message,
      method: console.timeStamp || noop
    });
  }

  group(priority, message) {
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      collapsed: false
    };
    opts = this._normalizeArguments({
      priority,
      message,
      opts
    });
    const _opts = opts,
          collapsed = _opts.collapsed;
    return this._getLogFunction({
      priority,
      message,
      opts,
      method: (collapsed ? console.groupCollapsed : console.group) || console.info
    });
  }

  groupCollapsed(priority, message) {
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return this.group(priority, message, Object.assign({}, opts, {
      collapsed: true
    }));
  }

  groupEnd(priority) {
    return this._getLogFunction({
      priority,
      message: '',
      method: console.groupEnd || noop
    });
  }

  withGroup(priority, message, func) {
    const opts = this._normalizeArguments({
      priority,
      message
    });

    this.group(opts);

    try {
      func();
    } finally {
      this.groupEnd(opts.message);
    }
  }

  trace() {
    if (console.trace) {
      console.trace();
    }
  }

  _shouldLog(priority) {
    priority = this._normalizePriority(priority);
    return priority === 0 || this.isEnabled() && this.getPriority() >= priority;
  }

  _getElapsedTime() {
    const total = this.getTotal();
    const delta = this.getDelta();
    this._deltaTs = getHiResTimestamp();
    return {
      total,
      delta
    };
  }

  _getLogFunction(opts) {
    if (this._shouldLog(opts.priority)) {
      const _opts2 = opts,
            method = _opts2.method;
      opts = this._parseArguments(opts);
      assert(method);
      let _opts3 = opts,
          message = _opts3.message;
      const tag = opts.tag || opts.message;

      if (opts.once) {
        if (!cache[tag]) {
          cache[tag] = getHiResTimestamp();
        } else {
          return noop;
        }
      }

      message = this._decorateMessage(message, opts);
      return method.bind(console, message, ...opts.args);
    }

    return noop;
  }

  _parseArguments(options) {
    const normOpts = this._normalizeArguments(options);

    const _this$_getElapsedTime = this._getElapsedTime(),
          delta = _this$_getElapsedTime.delta,
          total = _this$_getElapsedTime.total;

    return Object.assign(options, normOpts, {
      delta,
      total
    });
  }

  _normalizePriority(priority) {
    let resolvedPriority;

    switch (typeof priority) {
      case 'number':
        resolvedPriority = priority;
        break;

      case 'object':
        resolvedPriority = priority.priority || 0;
        break;

      default:
        resolvedPriority = 0;
    }

    assert(Number.isFinite(resolvedPriority) && resolvedPriority >= 0);
    return resolvedPriority;
  }

  _normalizeArguments(_ref5) {
    let priority = _ref5.priority,
        message = _ref5.message,
        _ref5$args = _ref5.args,
        args = _ref5$args === void 0 ? [] : _ref5$args,
        opts = _ref5.opts;
    const newOpts = {
      priority: this._normalizePriority(priority),
      message,
      args
    };

    switch (typeof priority) {
      case 'string':
      case 'function':
        if (message !== undefined) {
          args.unshift(message);
        }

        Object.assign(newOpts, {
          message: priority
        });
        break;

      case 'object':
        Object.assign(newOpts, priority);
        break;

      default:
    }

    if (typeof newOpts.message === 'function') {
      newOpts.message = this._shouldLog(newOpts.priority) ? newOpts.message() : '';
    }

    assert(typeof newOpts.message === 'string' || typeof newOpts.message === 'object');
    return Object.assign(newOpts, opts);
  }

  _decorateMessage(message, opts) {
    if (typeof message === 'string') {
      let time = '';

      if (opts.time) {
        const _this$_getElapsedTime2 = this._getElapsedTime(),
              total = _this$_getElapsedTime2.total;

        time = leftPad(formatTime(total));
      }

      message = opts.time ? "".concat(this.id, ": ").concat(time, "  ").concat(message) : "".concat(this.id, ": ").concat(message);
      message = addColor(message, opts.color, opts.background);
    }

    return message;
  }

}
Log.VERSION = VERSION;
//# sourceMappingURL=log.js.map